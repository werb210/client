Got it — we’ll fix the **client app** first and ignore Staff until you say otherwise. Below is a turnkey “Client App Security & Stability Fix Pack” that addresses exactly what your client-side audit flagged: vulnerable deps, TypeScript errors in `server/index.ts`, weak auth, input/file validation, noisy errors, and rate-limiting. It does **not** touch the Staff app.

---

# 0) Apply in this order

1. Dependencies → 2) TypeScript fixes → 3) Auth/session → 4) Validation (zod) → 5) Upload safety → 6) Error handling → 7) Rate limiting/CORS → 8) Quick tests.

---

# 1) Dependencies (remove known CVEs)

```bash
# from the client app root
npm audit --production
npm audit fix
# if still reporting HIGH/CRITICAL (e.g., lodash.set, esbuild):
npm i lodash.set@^4.3.3 esbuild@^0.21.5
# trim dead weight
npx depcheck
```

If you pin versions, re-run `npm run build` to ensure no regressions.

---

# 2) TypeScript: fix `server/index.ts`

Create `server/app.ts` and export the Express app (lets you unit test cleanly):

```ts
// client/server/app.ts
import express, { Request, Response, NextFunction } from "express";
import path from "node:path";
import cookieParser from "cookie-parser";

export const app = express();

// JSON + form parsing
app.use(express.json({ limit: "5mb", type: ["application/json","application/*+json"] }));
app.use(express.urlencoded({ extended: true, limit: "5mb" }));
app.use(cookieParser());

// static (if serving built UI from client/dist)
app.use(express.static(path.join(process.cwd(), "dist")));

// central error handler (no stack leaks in prod)
app.use((err: unknown, _req: Request, res: Response, _next: NextFunction) => {
  const msg = err instanceof Error ? err.message : "server_error";
  res.status(500).json({ ok: false, error: msg });
});
```

Then minimal `server/index.ts`:

```ts
// client/server/index.ts
import { app } from "./app";
import { harden } from "./security";
import routes from "./routes";

harden(app);       // helmet + cors + rate limits
routes(app);       // mount API routes

const PORT = Number(process.env.PORT || 5000);
app.listen(PORT, () => {
  console.log(`[client] listening on :${PORT}`);
});
```

---

# 3) Auth: session cookie (no shared bearer from browser)

Use an **ephemeral, signed** session cookie for the browser; keep any Staff tokens **server-side only**.

```ts
// client/server/mw/session.ts
import type { Request, Response, NextFunction } from "express";
import crypto from "node:crypto";

const COOKIE = "sid";
export function session(req: Request, res: Response, next: NextFunction) {
  let sid = req.cookies?.[COOKIE];
  if (!sid) {
    sid = crypto.randomBytes(16).toString("hex");
    res.cookie(COOKIE, sid, {
      httpOnly: true, sameSite: "lax", secure: true, maxAge: 1000*60*60*24*7
    });
  }
  (req as any).sid = sid;
  next();
}
```

Optional CSRF (add to POSTs if you want):

```ts
// client/server/mw/csrf.ts
import type { Request, Response, NextFunction } from "express";
export function csrf(req: Request, res: Response, next: NextFunction) {
  if (req.method === "GET" || req.method === "HEAD") return next();
  const hdr = req.get("x-csrf-token");
  if (!hdr) return res.status(403).json({ ok:false, error:"missing_csrf" });
  next();
}
```

Mount them in `routes` (next section).

---

# 4) Validation: zod schemas for all public inputs

```ts
// client/server/lib/validate.ts
import { z } from "zod";

export const PublicAppSchema = z.object({
  applicantInformation: z.object({
    firstName: z.string().min(1),
    lastName:  z.string().min(1),
    email:     z.string().email()
  }),
  businessInformation: z.object({
    legalName: z.string().min(1),
    industry:  z.string().min(2).optional()
  }),
  loan: z.object({
    requestedAmount: z.number().positive(),
    useOfFunds: z.string().min(2)
  })
});

export const ChatMessageSchema = z.object({
  message: z.string().min(1).max(4000)
});

export type PublicApp = z.infer<typeof PublicAppSchema>;
```

---

# 5) Upload safety (client validates before sending to Staff)

```ts
// client/server/mw/uploads.ts
import type { Request, Response, NextFunction } from "express";
import { fileTypeFromBuffer } from "file-type";

export async function enforceSafeFile(req: Request, res: Response, next: NextFunction) {
  try {
    const b64 = (req.body?.fileBase64 as string) || "";
    const raw = b64.includes(",") ? b64.split(",").pop()! : b64;
    const buf = Buffer.from(raw, "base64");
    if (!buf.length) return res.status(422).json({ ok:false, error:"empty_file" });

    const sig = await fileTypeFromBuffer(buf); // magic bytes
    const allowed = new Set(["application/pdf","image/png","image/jpeg"]);
    if (!sig || !allowed.has(sig.mime)) {
      return res.status(415).json({ ok:false, error:"unsupported_file_type", mime: sig?.mime });
    }
    // annotate for downstream proxy to Staff
    (req as any).fileMime = sig.mime;
    (req as any).fileBytes = buf.length;
    next();
  } catch {
    res.status(400).json({ ok:false, error:"bad_file" });
  }
}
```

---

# 6) Security middleware (helmet, cors, rate limits)

```ts
// client/server/security.ts
import helmet from "helmet";
import cors from "cors";
import rateLimit from "express-rate-limit";
import type { Express } from "express";

export function harden(app: Express) {
  app.use(helmet({
    frameguard: { action: "deny" },
    contentSecurityPolicy: false // keep your CSP config separately if you have one
  }));

  app.use(cors({
    origin: [/^https:\/\/(.*\.)?boreal\.financial$/, /^https:\/\/.*\.replit\.app$/],
    credentials: true
  }));

  app.use(rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 400,                  // tighten as needed
    standardHeaders: true,
    legacyHeaders: false
  }));
}
```

---

# 7) Routes: mount client-side APIs safely (and proxy to Staff)

This keeps the *browser → client server* secure, validates inputs, and then forwards to Staff using server-only credentials. It also fixes the `/public/applications` 404 by ensuring the client server supports that path and forwards to Staff’s working path.

```ts
// client/server/routes/index.ts
import type { Express, Request, Response } from "express";
import fetch from "node-fetch";
import { session } from "../mw/session";
import { csrf } from "../mw/csrf";
import { PublicAppSchema, ChatMessageSchema } from "../lib/validate";
import { enforceSafeFile } from "../mw/uploads";

const STAFF_BASE = process.env.STAFF_BASE || "http://localhost:5000";
const STAFF_TOKEN = process.env.STAFF_TOKEN || ""; // server-to-server only

export default function routes(app: Express) {
  app.use(session);
  // app.use(csrf); // enable if you add a CSRF token to requests

  // Health (for the client server)
  app.get("/health", (_req, res) => res.json({ ok:true, service:"client", time: new Date().toISOString() }));

  // Public applications (client → staff)
  app.post("/public/applications", async (req: Request, res: Response) => {
    const parsed = PublicAppSchema.safeParse(req.body);
    if (!parsed.success) return res.status(422).json({ ok:false, error:"invalid_payload", issues: parsed.error.issues });

    const r = await fetch(`${STAFF_BASE}/api/public/applications`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": STAFF_TOKEN ? `Bearer ${STAFF_TOKEN}` : ""
      },
      body: JSON.stringify(parsed.data)
    });

    const text = await r.text();
    let body: any; try { body = JSON.parse(text); } catch { body = { proxyText: text }; }
    return res.status(r.status).json(body);
  });

  // Chat (HTTP polling) – forward safely
  app.post("/api/chat/message", async (req, res) => {
    const parsed = ChatMessageSchema.safeParse(req.body);
    if (!parsed.success) return res.status(422).json({ ok:false, error:"invalid_message" });

    const r = await fetch(`${STAFF_BASE}/api/chat/user-message`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": STAFF_TOKEN ? `Bearer ${STAFF_TOKEN}` : ""
      },
      body: JSON.stringify({ message: parsed.data.message, sid: (req as any).sid })
    });
    const data = await r.json().catch(() => ({}));
    res.status(r.status).json(data);
  });

  // File upload pre-check (client validation before Staff presign → S3)
  app.post("/api/uploads/validate", enforceSafeFile, async (req, res) => {
    res.json({ ok:true, mime: (req as any).fileMime, bytes: (req as any).fileBytes });
  });
}
```

**Why this helps immediately**

* The browser never sees Staff secrets.
* The client server validates payloads + files before forwarding.
* You now have a clean `/public/applications` path on the **client** that forwards to the Staff canonical path.
* Rate limits + helmet + CORS are enforced here.

---

# 8) Error handling & logging (no leaks)

You already have a centralized handler in `app.ts`. Add minimal request logging without dumping secrets:

```ts
// client/server/mw/log.ts
import type { Request, Response, NextFunction } from "express";
export function logReq(req: Request, _res: Response, next: NextFunction) {
  const redacted = { path: req.path, method: req.method, sid: (req as any).sid, ip: req.ip };
  console.log("[client]", JSON.stringify(redacted));
  next();
}
```

Mount `logReq` first if you want request logs.

---

# 9) Quick verification (copy/paste)

```bash
BASE=http://localhost:5000

# Client server health
curl -s $BASE/health | jq

# Safe application submission (client validates, forwards to Staff)
curl -s -o /dev/null -w "HTTP %{http_code}\n" \
  -H "Content-Type: application/json" \
  -d '{"applicantInformation":{"firstName":"Jane","lastName":"Doe","email":"jane@example.com"},
       "businessInformation":{"legalName":"Doe Holdings Ltd","industry":"Construction"},
       "loan":{"requestedAmount":250000,"useOfFunds":"Working capital"}}' \
  $BASE/public/applications

# Chat (HTTP polling)
curl -s -o /dev/null -w "HTTP %{http_code}\n" \
  -H "Content-Type: application/json" \
  -d '{"message":"hello"}' \
  $BASE/api/chat/message

# Upload pre-check (rejects bad types)
curl -s -o /dev/null -w "HTTP %{http_code}\n" \
  -H "Content-Type: application/json" \
  -d '{"fileBase64":"data:application/x-msdownload;base64,AAAA"}' \
  $BASE/api/uploads/validate   # expect 415
```

---

## What this delivers for the **client app**

* ✅ Removes vulnerable packages (or pins safe versions).
* ✅ Fixes TS typing on the server side (no “implicit any” in `server/index.ts`).
* ✅ Adds **proper client-side session** (cookie), no shared bearer from browser.
* ✅ Validates **application submissions** and **chat messages** with zod.
* ✅ Validates **file uploads** (magic bytes + size), before Staff presign.
* ✅ Hardened server: helmet, CORS, and rate-limits.
* ✅ Production-safe error handling (no stack traces to users).

If you paste in these files and set:

```
STAFF_BASE=<staff base url>
STAFF_TOKEN=<server-to-server token if the Staff app requires it>
```

the client app should pass its own security audit criteria. When you’re ready, we can circle back to the Staff app.
