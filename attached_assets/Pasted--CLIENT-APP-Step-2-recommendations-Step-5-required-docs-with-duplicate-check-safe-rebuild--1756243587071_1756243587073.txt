// CLIENT APP: Step 2 recommendations + Step 5 required-docs, with duplicate-check,
// safe rebuild trigger (server-side), and "ask-when-uncertain" handling.
// Drop this into a shared client module, e.g. src/lib/intake-client.ts

// ---------- 1) Types ----------
export type IntakeAnswers = {
  desired_amount: number | null;
  time_in_business_months: number | null;
  monthly_revenue: number | null;
  credit_score: number | null;
  has_invoices?: boolean;
  has_equipment_quote?: boolean;
  has_purchase_order?: boolean;
  country?: 'US' | 'CA';
  tenant_id?: string;
};

export type RecommendedProduct = {
  id: string;
  name: string;
  country: 'US' | 'CA';
  category: string;
  tenant_id: string;
  lender_id: string;
  lender_name?: string;
  min_amount: number | null;
  max_amount: number | null;
  active: boolean | null;
  variant_sig?: string | null; // presence implies a distinct variant
  score: number;
  reasons: string[];
};

export type RequiredDocsResult = {
  inputs: Partial<IntakeAnswers>;
  checklist: { category: string; documents: string[] }[];
  selected_product_ids: string[];
};

export type DedupeRunResult =
  | { uncertain: true; asks: string[] }
  | { entity: 'lender_products'; dry_run: boolean; duplicates_found: number; rows?: any[]; removed?: number }
  | { entity: 'applications'; report_only: true; duplicate_groups: number; groups: any[] };

// ---------- 2) Open questions (explicit, so the UI can prompt if needed) ----------
export const OPEN_QUESTIONS: string[] = [
  // Step 2 scoping
  "Should recommendations default-filter by tenant_id?",
  "Should recommendations default-filter by applicant country, or show cross-border options?",
  "Any categories to exclude (e.g., SBA Loan) from consumer journeys?",
  // Step 5 scoping
  "Are there lender-specific document add-ons beyond category defaults?",
  // Dedupe policy confirmation
  "Confirm: Applications may duplicate freely; lender_products should remove exact duplicates only.",
];

// ---------- 3) Fetch helpers (handles 412 Ask pattern) ----------
async function postJSON<T>(url: string, body: any): Promise<T> {
  const res = await fetch(url, {
    method: 'POST',
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body ?? {}),
  });
  if (res.status === 412) {
    const j = await res.json().catch(() => ({}));
    const asks = Array.isArray(j?.asks) ? j.asks : ["Missing required inputs"];
    throw Object.assign(new Error('Precondition Required'), { type: 'ASK', asks });
  }
  if (!res.ok) {
    const text = await res.text().catch(() => '');
    throw new Error(`${url} failed: ${res.status} ${text}`);
  }
  return res.json() as Promise<T>;
}

// ---------- 4) Step 2 — Product Recommendations ----------
export async function getRecommendations(answers: IntakeAnswers, opts?: {
  tenantId?: string; // override answers.tenant_id
  country?: 'US'|'CA'; // override answers.country
}) {
  const payload: IntakeAnswers = {
    ...answers,
    ...(opts?.tenantId ? { tenant_id: opts.tenantId } : null),
    ...(opts?.country ? { country: opts.country } : null),
  };
  return postJSON<{ input: IntakeAnswers; recommended: RecommendedProduct[]; total_considered: number }>(
    '/api/recommendations',
    payload
  );
}

// ---------- 5) Step 5 — Required Documents ----------
export async function getRequiredDocs(opts: {
  selected_product_ids?: string[];
  categories?: string[];
  inputs?: Partial<IntakeAnswers>;
}) {
  return postJSON<RequiredDocsResult>('/api/required-docs', opts);
}

// ---------- 6) Client-side duplicate handling (display-level only) ----------
// Policy: DO NOT collapse legitimate variants. Only remove exact duplicates.
// We define an "exact duplicate" as sharing (id) OR (lender_id, name, country, variant_sig) completely.
export function dedupeRecommended(products: RecommendedProduct[]): RecommendedProduct[] {
  const seen = new Set<string>();
  const out: RecommendedProduct[] = [];
  for (const p of products) {
    const key = p.id
      ? `id:${p.id}`
      : `k:${p.lender_id}|${(p.name || '').toLowerCase()}|${p.country}|${p.variant_sig ?? ''}`;
    if (seen.has(key)) continue;
    seen.add(key);
    out.push(p);
  }
  return out;
}

// Optional: collapse visually-similar variants to the single best-scoring row (if UX requests it).
export function collapseVisualVariants(products: RecommendedProduct[]): RecommendedProduct[] {
  const groups = new Map<string, RecommendedProduct[]>();
  for (const p of products) {
    const gk = `g:${p.lender_id}|${(p.name || '').toLowerCase()}|${p.country}`;
    if (!groups.has(gk)) groups.set(gk, []);
    groups.get(gk)!.push(p);
  }
  const out: RecommendedProduct[] = [];
  for (const arr of groups.values()) {
    // Keep the best by (score desc, max_amount desc)
    const best = arr.slice().sort(
      (a, b) => (b.score - a.score) || ((b.max_amount ?? 0) - (a.max_amount ?? 0))
    )[0];
    out.push(best);
  }
  return out;
}

// ---------- 7) End-of-flow duplicate check + rebuild trigger ----------
// - For applications: REPORT ONLY (we must accept duplicates).
// - For lender_products: remove EXACT duplicates only; variants remain.
// - confirm() is a UI callback that returns true/false for destructive actions.
export async function runEndOfFlowCleanup(confirm: (message: string) => Promise<boolean>) {
  // Report-only for applications
  const appReport = await postJSON<DedupeRunResult>('/api/dedupe/run', { entity: 'applications', dry_run: true });
  if ('report_only' in appReport) {
    // You can surface appReport.groups (sample limited on server) in the UI for awareness.
    // No deletion occurs for applications by policy.
  }

  // Products: dry-run first
  const prodReport = await postJSON<DedupeRunResult>('/api/dedupe/run', { entity: 'lender_products', dry_run: true });
  if ('duplicates_found' in prodReport && prodReport.duplicates_found > 0) {
    const proceed = await confirm(
      `Found ${prodReport.duplicates_found} exact duplicate product rows.\n` +
      `Remove them now (variants will be preserved)?`
    );
    if (proceed) {
      await postJSON<DedupeRunResult>('/api/dedupe/run', { entity: 'lender_products', dry_run: false });
    }
  }
}

// ---------- 8) Example wiring in React (pseudo) ----------
/*
import { useState } from 'react';
import {
  IntakeAnswers,
  getRecommendations,
  dedupeRecommended,
  collapseVisualVariants,
  getRequiredDocs,
  runEndOfFlowCleanup
} from '@/lib/intake-client';

export function useAsk(err: any): string[] | null {
  return err?.type === 'ASK' ? (err.asks as string[]) : null;
}

export async function step2Flow(answers: IntakeAnswers) {
  try {
    const { recommended } = await getRecommendations(answers);
    const unique = dedupeRecommended(recommended);
    // If UX wants fewer rows, optionally collapse visual variants:
    // const simplified = collapseVisualVariants(unique);
    return unique;
  } catch (e:any) {
    const asks = useAsk(e);
    if (asks) { /* show asks in modal and collect responses */ }
    throw e;
  }
}

export async function step5Flow(selectedProductIds: string[], inputs: Partial<IntakeAnswers>) {
  try {
    const res = await getRequiredDocs({ selected_product_ids: selectedProductIds, inputs });
    return res.checklist; // [{category, documents[]}, ...]
  } catch (e:any) {
    const asks = useAsk(e);
    if (asks) { /* prompt user for missing inputs */ }
    throw e;
  }
}

export async function finalizeFlow(confirm: (msg:string)=>Promise<boolean>) {
  await runEndOfFlowCleanup(confirm);
}
*/
