CLIENT APP (web) — POI BLOCKS
A) Force same-origin, staff-only API usage
// client/src/lib/api.ts  (simple hard rules)
const BASE = "";

export async function uploadDocument(appId: string, file: File, documentType: string) {
  const fd = new FormData();
  fd.append("file", file);
  fd.append("document_type", documentType);
  const r = await fetch(`${BASE}/api/applications/${appId}/documents/upload`, {
    method: "POST",
    body: fd,
    credentials: "include",
  });
  if (!r.ok) throw new Error(`upload failed: ${r.status}`);
  return r.json();
}

export async function listDocuments(appId: string) {
  // In production use the staff-protected route:
  const path = import.meta.env.PROD ? `/api/applications/${appId}/documents`
                                    : `/api/public/applications/${appId}/documents`; // dev-only helper
  const r = await fetch(path, { credentials: "include" });
  if (!r.ok) throw new Error(`list failed: ${r.status}`);
  return r.json();
}

export async function setDocumentStatus(docId: string, status: "accepted"|"rejected"|"pending") {
  const r = await fetch(`/api/documents/${docId}`, {
    method: "PATCH",
    headers: { "Content-Type": "application/json" },
    credentials: "include",
    body: JSON.stringify({ status }),
  });
  if (!r.ok) throw new Error(`status failed: ${r.status}`);
  return r.json();
}

B) Runtime guard (already in place—keep it)
// client/src/lib/fetch-guard.ts
const DEV = import.meta.env.DEV;
const ALLOW = [/^\/(api|staff|_int)\b/i, /^\/$/, /^\/[?#]/];
const original = window.fetch;
window.fetch = async (input: RequestInfo | URL, init?: RequestInit) => {
  if (DEV) {
    const url = typeof input === "string" ? input : (input as any).url;
    const isExternal = /^https?:\/\//i.test(url) && !/^https?:\/\/(localhost|127\.0\.0\.1)(:\d{2,5})?\//i.test(url);
    if (isExternal) throw new Error(`External fetch blocked in dev: ${url}`);
    if (typeof input === "string" && !ALLOW.some(rx => rx.test(input)))
      throw new Error(`Non-API path blocked in dev: ${input}`);
  }
  return original(input as any, init);
};

// client/src/main.tsx
import "./lib/fetch-guard";

C) Upload widget uses Staff API (no S3)
// client/src/components/upload/DocumentUploadWidget.tsx (key call sites)
import { uploadDocument, listDocuments, setDocumentStatus } from "@/lib/api";

// onUpload:
await uploadDocument(applicationId, file, documentType);
const docs = await listDocuments(applicationId);
// onApprove:
await setDocumentStatus(docId, "accepted");

D) Quick client sanity (manual)
1) Open /staff pipeline → select Black Label app (server id: 2ebf6120-512e-428f-b1c1-094acf4b6edc)
2) Upload a small file → should appear in the drawer list
3) Approve it → status changes to accepted
4) View → opens presigned URL (prod) or dev local URL (dev)

✅ What this locks down (right now)

Client never talks to S3 or any external host.
Only same-origin /api/... calls to the Staff app.

Dev conveniences are gated (DOCS_DEV_BYPASS=1, WS_ALLOW_DEV_NO_TOKEN=1) and OFF in prod.

Public documents list route is disabled in production (you still have it for local dev).

View URLs are secure (presigned S3 in prod; local handler in dev).

DB protections (name trigger + indexes) and a path to set file_key NOT NULL once you’re satisfied.

If you want, I can also give you a one-liner “prod harden check” that asserts:

both bypass envs are unset,

public docs route returns 404/403,

protected routes return 401/403 without a token,

and presign returns a time-limited URL.