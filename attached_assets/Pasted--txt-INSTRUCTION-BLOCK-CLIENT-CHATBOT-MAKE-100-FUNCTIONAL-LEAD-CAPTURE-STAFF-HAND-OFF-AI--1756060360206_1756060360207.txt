```txt
INSTRUCTION BLOCK — CLIENT CHATBOT: MAKE 100% FUNCTIONAL (LEAD CAPTURE + STAFF HAND-OFF + AI HELP)

GOAL
- Bot greets, captures name+email+consent, creates/updates a contact in Staff app, then answers funding questions and offers actions (start application, upload docs, book meeting, talk to human). All buttons work, no console errors, security in place.

PREP
- ENV: STAFF_API_URL (e.g., https://staff.boreal.financial)
- Ensure client server has sessions + security middleware (helmet, rate limit, CORS), and CSRF pair (issue on GET, require on state-changing POST/PUT/DELETE).

PATCHES

1) Add CSRF helpers (client gateway / Express)
  - server/security/csrf.ts
    - issueCsrf(req,res,next): set __Host-bf_csrf cookie (Secure, Lax, path=/) + x-csrf-token header
    - requireCsrf(req,res,next): compare cookie vs header; 403 on mismatch
  - Wire: 
    - app.get("/*", issueCsrf, serve SPA)
    - app.use("/api", requireCsrf) for mutating routes only (keep GETs public)

2) Lead upsert route (client → staff)
  - server/routes/leads.ts
    - POST /api/leads  (zod-validate: {name,email,consent,source,page,tenant})
    - Forward to `${STAFF_API_URL}/api/chat/log-contact`
    - On failure, queue in memory: app.set("leadQueue", []) and push {at,payload}; always return 202 {ok:true,queued?:true}
  - Mount: app.use("/api", leadsRouter)

3) Chatbot component (React)
  - Replace ChatBot.tsx content with a 4-phase flow:
    - welcome → askName → askEmail (email regex) → askConsent (yes/no) → ready
    - On consent completion: POST /api/leads with x-csrf-token from window.__CSRF__
    - After “ready”, POST /api/chat/message for AI replies
  - Buttons:
    - Quick actions row when phase === "ready":
      [Start Application] → navigate("/apply?prefill=name,email")
      [Upload Docs] → open uploader modal (uses existing presign)
      [Book Meeting] → open O365 picker (if connected)
      [Talk to Human] → POST `${STAFF_API_URL}/api/chat/request-staff`
  - Accessibility: input has aria-label; auto-scroll on new messages; enter to send.

4) Handoff + timeline context (optional but recommended)
  - After each user message (when phase === "ready"):
    - POST `${STAFF_API_URL}/api/chat/user-message` { email,name,text,source:"chat",tenant,page }
    - Non-blocking: ignore failure in UI; console.warn only.

5) Security hardening specific to chat
  - Drop any PII like SIN/SSN: before send, if message matches sensitive patterns, block and prompt “please use secure upload.”
  - File uploads from chat: client gate checks MIME ∈ {application/pdf,image/png,image/jpeg} and size ≤ 10MB; server returns 415 on others.

6) Lender suggestions in-chat (lights-on feature)
  - When a message contains financing intent (loan|funding|working capital|equipment), fetch /api/lender-products and reply with top 3 chips:
    - “View Product” → opens product modal/details
    - “Match Me” → deep-link to /apply?intent=productId

7) Meeting booking (O365)
  - Button opens modal → GET available slots → POST booking (client → staff O365 proxy). If O365 not connected, show “Connect calendar” CTA.

8) Language toggle
  - Add “EN | FR” in chat header. Store lang in local state and include in /api/chat/message payload as { lang }. Render system prompts in selected language.

9) Analytics
  - Emit events: chat_opened, lead_captured, handoff_requested, application_started, doc_upload_from_chat, meeting_booked. Include tenant + UTM if available.

10) Error boundaries & UI polish
  - Wrap ChatBot root in an ErrorBoundary that shows “We hit a snag; please try again.” Log sanitized error to Sentry (if configured).
  - Zero console warnings/errors in preview.

ACCEPTANCE TESTS (run all)

A. Lead capture
  1. Open homepage → bot appears → sends greeting.
  2. Enter name “Jane Smith” → bot asks for email.
  3. Enter “jane@acme.com” → bot asks consent (yes/no).
  4. Reply “yes” → UI shows confirmation; network: POST /api/leads = 202/200.
  5. Staff app contact card shows Jane with source “chat” (if staff endpoint live), or client leadQueue length increments if staff down.

B. CSRF
  - Attempt POST /api/leads without x-csrf-token → 403.
  - With header matching cookie → 202/200.

C. Quick actions
  - Start Application: navigates with ?prefill=; fields prefilled in client app.
  - Upload Docs: opens uploader; upload PDF → allowed; upload EXE → blocked (client) + server 415.
  - Talk to Human: POST `${STAFF_API_URL}/api/chat/request-staff` → 202/200; UI shows “We’ve pinged a specialist.”
  - Book Meeting: slot selected → booking POST succeeds → confirmation message appears.

D. AI replies
  - Ask “Do you offer equipment financing?” → bot returns answer + suggests 2–3 products.
  - Switch to FR → responses come in FR.

E. No console errors
  - Open DevTools: no red errors; CSP warnings absent; service worker ok.

F. Offline safety
  - Temporarily block network to STAFF_API_URL; submit lead → /api/leads returns 202 queued; on reconnect, queue drains (logs in server).

ROLLBACK / SAFETY
- All new routes are additive. If staff endpoints are missing, leads are queued (no data loss).
- Chat continues to work for answers even if staff handoff fails.

DONE WHEN
- Greeting → name → email → consent always flows and creates (or queues) a contact.
- Buttons (Start Application, Upload Docs, Book Meeting, Talk to Human) all execute their action.
- Lender suggestions appear on financing queries.
- No console errors; CSRF and upload validation enforced.
- Analytics events emitted for core actions.

(End of instruction block)
```
