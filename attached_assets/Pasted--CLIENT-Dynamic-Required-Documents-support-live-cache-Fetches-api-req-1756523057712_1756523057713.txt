# ┏━━━━━━━━ CLIENT: Dynamic Required Documents support (live & cache) ━━━━━━━━┓
# • Fetches /api/required-docs?productId=&lenderId= dynamically (Step 5)
# • Optional SQLite cache (Drizzle) to persist doc definitions/snapshots
# • Replaces any legacy hardcoded lists (NO-DUP)
# • Smoke: proves a newly added doc (e.g., 'void_cheque') appears in Step 5
# ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
set -euo pipefail

echo "== CLIENT ENV =="
echo "VITE_STAFF_API_URL=${VITE_STAFF_API_URL:-https://staff.boreal.financial/api}"
echo "VITE_CLIENT_APP_SHARED_TOKEN set? $([ -n "${VITE_CLIENT_APP_SHARED_TOKEN:-}" ] && echo yes || echo no)"
BASE="${VITE_STAFF_API_URL:-https://staff.boreal.financial/api}"

mkdir -p src/lib/api src/lib/docs src/db scripts

# 0) NO-DUP CLEANUP: remove old hardcoded required-docs lists (if any)
rm -f src/lib/docs/requiredDocs.fallback.ts src/lib/docs/requiredDocs.static.ts 2>/dev/null || true

# 1) API CALL: canonical fetcher for required docs (productId,lenderId)
cat > src/lib/api/requiredDocs.ts <<'TS'
export type RequiredDoc = {
  key: string; name: string; description?: string|null;
  required: boolean; category?: string|null;
  allowed_mime?: string[]|null; min_count?: number|null; max_count?: number|null; meta?: any;
  source?: "product"|"lender"|"master";
};
const BASE = (import.meta.env.VITE_STAFF_API_URL || "https://staff.boreal.financial/api").replace(/\/+$/,"");
const TOK  = import.meta.env.VITE_CLIENT_APP_SHARED_TOKEN || "";
export async function fetchRequiredDocs(opts: { productId?: string; lenderId?: string }): Promise<RequiredDoc[]> {
  const params = new URLSearchParams();
  if (opts.productId) params.set("productId", opts.productId);
  if (opts.lenderId)  params.set("lenderId",  opts.lenderId);
  const url = `${BASE}/required-docs?${params.toString()}`;
  const r = await fetch(url, { headers: { Authorization: `Bearer ${TOK}` }, cache:"no-store" });
  if (!r.ok) { throw new Error(`required-docs fetch failed: ${r.status}`); }
  const docs = await r.json();
  return Array.isArray(docs) ? docs : [];
}
TS

# 2) OPTIONAL CACHE (SQLite + Drizzle) — safe to skip if you prefer stateless
cat > src/db/docs.schema.ts <<'TS'
/* Minimal local cache (OPTIONAL). Keep small to avoid duplication creep. */
import { sqliteTable, text, integer } from "drizzle-orm/sqlite-core";
export const doc_master = sqliteTable("doc_master", {
  key: text("key").primaryKey(),
  name: text("name").notNull(),
  description: text("description"),
  category: text("category"),
});
export const doc_snapshot = sqliteTable("doc_snapshot", {
  context_hash: text("context_hash").primaryKey(),  // e.g., `${productId}:${lenderId}`
  json: text("json").notNull(),                      // raw array JSON for quick restore
  updated_at: integer("updated_at", { mode:"timestamp_ms" })
});
TS

# 3) STEP 5 INTEGRATION UTIL: normalize & dedupe live docs
cat > src/lib/docs/normalize.ts <<'TS'
import type { RequiredDoc } from "../api/requiredDocs";
export function normalizeDocs(docs: RequiredDoc[]): RequiredDoc[] {
  const map = new Map<string, RequiredDoc>();
  for (const d of docs) {
    const k = d.key.trim().toLowerCase();
    const prev = map.get(k);
    // product > lender > master priority already applied server-side, this just dedupes
    if (!prev) map.set(k, d);
  }
  // stable UX ordering: product first, then lender, then master
  const weight = (s?:string)=> s==="product"?0 : s==="lender"?1 : 2;
  return [...map.values()].sort((a,b)=> weight(a.source)-weight(b.source) || a.key.localeCompare(b.key));
}
TS

# 4) WIRING INTO STEP 5 (example hook used by Step5Documents.tsx)
cat > src/lib/docs/useRequiredDocs.ts <<'TS'
import { useEffect, useState } from "react";
import { fetchRequiredDocs, type RequiredDoc } from "../api/requiredDocs";
import { normalizeDocs } from "./normalize";

type Params = { productId?: string; lenderId?: string };
export function useRequiredDocs({ productId, lenderId }: Params) {
  const [docs, setDocs] = useState<RequiredDoc[] | null>(null);
  const [error, setError] = useState<Error | null>(null);
  useEffect(() => {
    let ok = true;
    (async () => {
      try {
        const raw = await fetchRequiredDocs({ productId, lenderId });
        const norm = normalizeDocs(raw);
        if (ok) setDocs(norm);
      } catch (e:any) { if (ok) setError(e); }
    })();
    return () => { ok = false; };
  }, [productId, lenderId]);
  return { docs, error, loading: docs===null && error===null };
}
TS

# NOTE: In your Step5Documents.tsx, replace any static list with:
#   const { docs, loading, error } = useRequiredDocs({ productId, lenderId });
#   // render dynamic doc items; require uploads for every `docs[i].key`

# 5) NO-DUP ENFORCEMENT: ensure no static lists remain
if command -v rg >/dev/null 2>&1; then
  echo "== Scanning for static required-doc lists =="
  if rg -n "requiredDocs\\.(fallback|static)|\\[\\s*\\{\\s*key\\s*:" src; then
    echo "❌ Found hardcoded required-docs. Remove them and rely on fetchRequiredDocs()."
    exit 2
  else
    echo "✔ No static lists detected."
  fi
fi

# 6) SMOKE: prove new doc appears (e.g., 'void_cheque' attached to first product on Staff)
echo "== CLIENT SMOKE =="
PID=$(curl -sS -H "Authorization: Bearer ${VITE_CLIENT_APP_SHARED_TOKEN:-}" "$BASE/v1/products" | jq -r '.[0].id // empty')
if [ -n "$PID" ]; then
  curl -sS -H "Authorization: Bearer ${VITE_CLIENT_APP_SHARED_TOKEN:-}" "$BASE/required-docs?productId=$PID" | jq '[.[] | {key,name,source}]'
  echo "→ Confirm above list contains 'void_cheque' (source may be 'product')."
else
  echo "No products visible to client yet. Once Staff exposes 44 products, rerun this smoke."
fi

echo "✅ CLIENT: Step 5 now fully dynamic; new lender/product docs flow through automatically."
