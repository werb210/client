Short answer: **I added new modules; I didn’t overwrite your existing Step 2/Step 5 code.** That means nothing runs twice **unless** you import both the old and new implementations. Here’s how to wire it so there’s **one source of truth** and no duplicates.

---

## Make Step 2 single-source (no dupes)

1. **Pick the canonical engine** → use the new one:

   * `src/lib/reco/engine.ts`
   * `src/lib/products/normalize.ts`

2. **Repoint imports** (one place only—wherever the UI builds recommendations):

   * Replace any old imports (e.g. `utils/recommendation`, `services/reco`) with:

     ```ts
     import { recommend } from '@/lib/reco/engine';
     import { normalizeProducts } from '@/lib/products/normalize';
     ```

3. **Verify only one definition exists**

   ```bash
   rg -n "export function recommend" src | wc -l   # should be 1
   rg -n "recommend\(" src | rg -v "engine.ts"     # should show only call sites, not another engine
   ```

4. (Optional) **Deprecate/remove** old engine file after the app compiles:

   * Rename old file to `.old` or delete it once tests are green.

---

## Make Step 5 single-source (no dupes)

Your current client **does not persist required-docs** and fetches dynamically. I provided **pure in-memory** logic plus an **optional** DB-backed path. Use **one** of these:

### Option A (no DB, matches your current architecture) — RECOMMENDED now

* Keep only:

  * `src/lib/docs/requirements.ts` (computes union of docs)
  * `src/lib/docs/validate.ts` (checks completeness)
* In Step 5 code, import **only**:

  ```ts
  import { eligibleProductsForDocs, computeRequiredDocs } from '@/lib/docs/requirements';
  import { allRequiredDocsComplete } from '@/lib/docs/validate';
  ```
* **Do not** add `required_docs` or `application_docs` tables yet.

### Option B (DB-backed, for later)

* If/when you decide to persist docs, add the tables/migrations and the hydrator. Until then, **don’t create those tables** to avoid a second path.

### Sanity checks (whichever option you choose)

```bash
# Only one implementation of doc computation
rg -n "export function computeRequiredDocs" src | wc -l   # should be 1
rg -n "computeRequiredDocs\(" src | rg -v "requirements.ts"

# Only one completeness check
rg -n "allRequiredDocsComplete" src | wc -l               # should be 1
```

---

## Keep audit utilities non-intrusive

* The audit hooks I shared (`auditHook.ts`, `auditDocsHook.ts`, `docPollingAudit.ts`) are **disabled by default** and only attach when `VITE_AUDIT=1`.
* If you added them, they **don’t replace** app logic and won’t cause duplicates. You can delete them anytime; they’re for diagnostics only.

---

## Quick “duplication guard” before pushing

```bash
# Step 2: engine defined once
rg -n "export function recommend" src

# Step 5: requirements defined once
rg -n "export function computeRequiredDocs" src

# Ensure the app imports the new modules (and not old utils)
rg -n "from .*/reco/engine" src
rg -n "from .*/docs/requirements" src
```

If any command returns more than one definition or shows imports to old paths, update those imports or remove the old files. After this, you’ll have **exactly one** implementation for Step 2 and Step 5—no duplicates, no drift.
