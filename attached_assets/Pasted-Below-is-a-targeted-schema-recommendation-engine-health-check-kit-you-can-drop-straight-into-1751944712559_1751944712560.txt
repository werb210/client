Below is a **targeted “schema-+-recommendation-engine health-check” kit** you can drop straight into the *client* repo (nothing touches Staff).

---

### 1.  What we’re trying to prove

| Concern                   | What a passing test proves                                                                                                                        | Typical root-cause if it fails                                                                       |
| ------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------- |
| **Category mapping**      | Every lender product’s `category` matches one of the canonical enum values in the unified schema **and** the recommendation engine recognises it. | Stray, misspelled or legacy category strings (e.g. `"working_capital_loan"` vs `"working_capital"`). |
| **Country mapping**       | The product says `countries: ["US","CA"]` etc. and the engine respects the user’s `businessLocation`.                                             | Old `"country":"Canada"` strings or lowercase `"us" / "ca"`.                                         |
| **Amount band mapping**   | Given a form request for `$X`, the filter picks only products whose `minAmount ≤ X ≤ maxAmount`.                                                  | `min_amount`, `max_amount`, or `loanAmount` renamed without adapting the filter.                     |
| **Document intersection** | For the *filtered* product set, `requiredDocuments` = intersection of all their document arrays.                                                  | Wrong field name (`docRequirements` vs `requiredDocuments`) or a product missing the field entirely. |

---

### 2.  One-file smoke test you can run in the browser console

*(Paste at `/apply/step-2` or any page where `window.borealApp` exists.)*

```javascript
(async () => {
  // ------------- helpers -----------------
  const ok   = msg => console.log(`%c✔ ${msg}`,'color:lime');
  const fail = msg => console.error(`✖ ${msg}`);

  // pull live data already fetched by TanStack Query
  const products = await window.borealApp?.debug?.getAllLenderProducts?.() 
                 ?? [];

  const schemaCategories = [
    'term_loan','line_of_credit','working_capital',
    'equipment_finance','invoice_factoring','merchant_cash_advance',
    'real_estate'
  ];

  // ---------- CATEGORY + COUNTRY AUDIT ----------
  const badCats   = products.filter(p => !schemaCategories.includes(p.category));
  const badCntry  = products.filter(p => !['US','CA','US,CA','CA,US']
                                    .some(c => (p.countries ?? '').includes(c)));

  badCats.length  ? fail(`Bad categories: ${badCats.map(p=>p.category)}`) 
                  : ok('All products use canonical categories');

  badCntry.length ? fail(`Bad country tags on ${badCntry.length} products`) 
                  : ok('All products use canonical country codes');

  // ---------- AMOUNT FILTER SANITY CHECK ----------
  const formState   = JSON.parse(localStorage.getItem('boreal-application-form')||'{}');
  const wanted      = Number(formState.fundingAmount||0);

  const enginePick  = window.borealApp?.debug?.recommend?.(formState) ?? [];
  const badAmounts  = enginePick.filter(
        p => !(p.minAmount <= wanted && wanted <= p.maxAmount)
  );

  badAmounts.length ? fail(`Engine returned ${badAmounts.length} product(s) outside the amount range`)
                    : ok('Amount filter working');

  // ---------- DOCUMENT INTERSECTION CHECK ----------
  const intersection = enginePick.reduce((acc,p) =>
        acc.filter(doc => (p.requiredDocuments||[]).includes(doc)),
        enginePick[0]?.requiredDocuments || []);

  const engineDocList = window.borealApp?.debug?.currentRequiredDocs?.() ?? [];

  (JSON.stringify(intersection) === JSON.stringify(engineDocList))
        ? ok('Document intersection logic matches engine output')
        : fail('Document list mismatch – intersection logic broken');

})();
```

**Reading the result**

* Green ✔ → that aspect is solid.
* Red ✖ → shows the exact offending values so you can trace them back to the raw product JSON, the unified schema file, or the filter in `recommend.ts`.

---

### 3.  Deeper automated regression – Jest script (optional)

If you want this in CI instead of a browser snippet, drop `schema-health.test.ts` under `client/tests/`:

```ts
import { lenderProducts } from '@/lib/mockData';   // or fetch from staff API
import { recommend }       from '@/lib/recommend';
import { ApplicationForm } from '@/shared/schema';

const canonCats = ['term_loan','line_of_credit','working_capital', /* … */ ];

test('every product has canonical category & country', () => {
  lenderProducts.forEach(p => {
    expect(canonCats).toContain(p.category);
    expect(['US','CA','US,CA','CA,US']).toEqual(
        expect.arrayContaining(p.countries.split(',')));
  });
});

test.each([10_000, 75_000, 1_000_000])(
  'amount filter respects min/max for %i', amount => {
    const form = { fundingAmount: amount, businessLocation:'CA' } as Partial<ApplicationForm>;
    recommend(form).forEach(p => {
       expect(amount).toBeGreaterThanOrEqual(p.minAmount);
       expect(amount).toBeLessThanOrEqual(p.maxAmount);
    });
});

test('document intersection matches engine output', () => {
  const form = { fundingAmount: 75_000, businessLocation:'CA' } as Partial<ApplicationForm>;
  const picks = recommend(form);
  const docs  = picks.reduce(
      (acc,p) => acc.filter(d => p.requiredDocuments.includes(d)),
      picks[0].requiredDocuments);
  expect(docs).toEqual(requireIntersectionFromEngine(form)); // your actual fn
});
```

Run with `npm run test` – if any assertion fails you’ll see **exactly** which field or product row is out of alignment.

---

### 4.  What to fix when a check fails

| Failing check         | Likely culprit                                                          | Quick fix                                                   |
| --------------------- | ----------------------------------------------------------------------- | ----------------------------------------------------------- |
| **Bad categories**    | Old data in PostgreSQL `lender_products` table                          | Run an `UPDATE` script or patch seed data to canonical enum |
| **Bad country tags**  | Field renamed (`country`, `locale`) or free-text values                 | Normalise to `countries: "US"` / `"CA"`                     |
| **Amount range miss** | `minAmount` / `maxAmount` renamed or stored as strings                  | Ensure numeric columns; update engine to parse `Number()`   |
| **Document mismatch** | Product missing `requiredDocuments` or filter reading `docRequirements` | Standardise field name & update intersection algorithm      |

Once these tests show all green, the recommendation engine will **have enough clean data** to produce reliable lender matches *and* the downstream required-document list.

---

### 5.  When to run these tests

* **Locally (dev)** after every schema change – they run in seconds.
* **CI pipeline** – fail the build if any red flags appear.
* **Staging** just before you hit *Deploy* on Replit to guarantee production quality.

Run them **before** you redeploy – it’s faster to catch a schema slip locally than roll back a bad production build.

---

These checks will give you **hard evidence** that categories, countries, amounts and document logic are correctly wired from schema → recommendation engine → UI.
