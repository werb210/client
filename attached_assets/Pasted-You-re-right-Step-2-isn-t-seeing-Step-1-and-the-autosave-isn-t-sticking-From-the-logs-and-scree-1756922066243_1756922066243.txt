You‚Äôre right: Step 2 isn‚Äôt ‚Äúseeing‚Äù Step 1, and the autosave isn‚Äôt sticking. From the logs and screenshots, this is almost certainly a **state plumbing problem**, not a browser/CSP one.

# What‚Äôs actually broken (in order of likelihood)

1. **The canonical store/provider never boots (or isn‚Äôt mounted for every page).**
   You expected logs like `[MAIN] Starting canonical store bootstrap‚Ä¶` but the only custom log I see is ‚Äúüî• MAIN.TSX ERROR LOG‚Äù. That means the Step 2 filter code is reading from an empty/default store, so it can‚Äôt hide ‚ÄúEquipment Financing‚Äù / ‚ÄúInvoice Factoring‚Äù.

2. **Step 1 writes to one keyspace, Step 2 reads from another.**
   Step 1 autosave is (still) writing to something like `bf:step1` / `bf:intake`, while Step 2 reads from `canon.*`. Unless you rehydrate `canon` from that same storage key on every page load, filters will not apply.

3. **The consent banner used to reload the page and duplicate-mount itself.**
   That would have nuked in-memory state earlier. You removed the duplicate‚Äîgood‚Äîbut because #1/#2 aren‚Äôt fixed, it still feels broken.

4. **CSP warnings are noisy but not the cause.**
   The `'unsafe-dynamic'` at `default-src`, bad `report-uri`, and the font 404s don‚Äôt block `localStorage` or `console.log`. They should be cleaned up, but they‚Äôre not why Step 2 rules don‚Äôt trigger.

# Fix: make Step 1 ‚Üí Step 2 state canonical, persistent, and global

## 1) Mount a provider **once** at the app root and rehydrate from localStorage

Make sure this wrapper is present for **every** route (Step 1..7). If you‚Äôre on Next.js ‚Äúapp/‚Äù ‚Äì put it in `app/layout.tsx`. If ‚Äúpages/‚Äù ‚Äì in `_app.tsx`.

```tsx
// app/providers/CanonProvider.tsx (or src/shared/CanonProvider.tsx)
'use client';

import React, {createContext, useContext, useEffect, useMemo, useState} from 'react';

type Canon = {
  intent?: { fundingType?: string; amount?: number };
  business?: { country?: string; industry?: string };
  metrics?: { revenue12m?: string; monthlyRevenue?: string; yearsHistory?: string };
  // add more as needed
};

const KEY = 'bf:canon:v1';

const Ctx = createContext<{
  canon: Canon;
  setCanon: (patch: Partial<Canon>) => void;
}>({ canon: {}, setCanon: () => {} });

export function CanonProvider({ children }: { children: React.ReactNode }) {
  const [canon, setCanonState] = useState<Canon>(() => {
    try { return JSON.parse(localStorage.getItem(KEY) || '{}'); } catch { return {}; }
  });

  const setCanon = (patch: Partial<Canon>) =>
    setCanonState(prev => ({ ...prev, ...patch }));

  // persist on change
  useEffect(() => {
    try { localStorage.setItem(KEY, JSON.stringify(canon)); } catch {}
  }, [canon]);

  // visible, unmistakable boot log
  useEffect(() => {
    console.info('[CANON] bootstrap OK. keys=', Object.keys(canon));
  }, []);

  return <Ctx.Provider value={{ canon, setCanon }}>{children}</Ctx.Provider>;
}

export const useCanon = () => useContext(Ctx);
```

Mount it once:

```tsx
// app/layout.tsx or pages/_app.tsx
import { CanonProvider } from '@/app/providers/CanonProvider';

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body>
        <CanonProvider>
          {children}
        </CanonProvider>
      </body>
    </html>
  );
}
```

## 2) Step 1: write directly into the canonical store **and** local state

Don‚Äôt write to a different localStorage key. Always update `canon` as the single source of truth.

```tsx
// step-1 component
'use client';
import { useCanon } from '@/app/providers/CanonProvider';
import { useState, useEffect } from 'react';

export default function Step1() {
  const { canon, setCanon } = useCanon();
  const [form, setForm] = useState({
    fundingType: canon.intent?.fundingType ?? '',
    amount: canon.intent?.amount ?? undefined,
    country: canon.business?.country ?? '',
    industry: canon.business?.industry ?? '',
    revenue12m: canon.metrics?.revenue12m ?? '',
    monthlyRevenue: canon.metrics?.monthlyRevenue ?? '',
    yearsHistory: canon.metrics?.yearsHistory ?? '',
  });

  // a single update path keeps things in sync AND persists
  const update = (patch: Partial<typeof form>) => {
    setForm(prev => ({ ...prev, ...patch }));
    // write the same data into canon immediately
    const intentPatch: any = {};
    if ('fundingType' in patch) intentPatch.fundingType = patch.fundingType;
    if ('amount' in patch) intentPatch.amount = patch.amount;

    const businessPatch: any = {};
    if ('country' in patch) businessPatch.country = patch.country;
    if ('industry' in patch) businessPatch.industry = patch.industry;

    const metricsPatch: any = {};
    if ('revenue12m' in patch) metricsPatch.revenue12m = patch.revenue12m;
    if ('monthlyRevenue' in patch) metricsPatch.monthlyRevenue = patch.monthlyRevenue;
    if ('yearsHistory' in patch) metricsPatch.yearsHistory = patch.yearsHistory;

    setCanon({
      ...(Object.keys(intentPatch).length ? { intent: { ...canon.intent, ...intentPatch } } : {}),
      ...(Object.keys(businessPatch).length ? { business: { ...canon.business, ...businessPatch } } : {}),
      ...(Object.keys(metricsPatch).length ? { metrics: { ...canon.metrics, ...metricsPatch } } : {}),
    });
  };

  // ‚Ä¶bind to inputs:
  // <select value={form.fundingType} onChange={e=>update({fundingType: e.target.value})} />
  // <input type="number" value={form.amount ?? ''} onChange={e=>update({amount: +e.target.value})}/>
}
```

## 3) Step 2: read from the same canonical store to filter categories

```tsx
// step-2 component
'use client';
import { useCanon } from '@/app/providers/CanonProvider';

const ALL = [
  { slug: 'working-capital', name: 'Working Capital' },
  { slug: 'line-of-credit', name: 'Line Of Credit' },
  { slug: 'equipment-financing', name: 'Equipment Financing' },
  { slug: 'invoice-factoring', name: 'Invoice Factoring' },
  { slug: 'purchase-order', name: 'Purchase Order Financing' },
  { slug: 'term-loan', name: 'Term Loan' },
];

export default function Step2() {
  const { canon } = useCanon();
  const ft = canon.intent?.fundingType;

  const filtered = ALL.filter(x => {
    if (ft === 'Capital' && (x.slug === 'equipment-financing' || x.slug === 'invoice-factoring')) {
      return false;
    }
    return true;
  });

  // render "filtered" instead of ALL
}
```

> With this in place:
>
> * You will see **`[CANON] bootstrap OK‚Ä¶`** once (no matter which page you land on first).
> * Typing/selecting in Step 1 immediately updates `localStorage['bf:canon:v1']`.
> * Navigating to Step 2 reads the same object and applies the hide rules.

## 4) Keep the cookie/CMP banner from interfering

* Mount it **once** at the app root (same place as the provider).
* **Never** call `location.reload()` on accept/deny.
* Do **not** gate `localStorage` writes behind consent in dev; persist state regardless.
* If you must gate, detect storage capability first:

  ```ts
  const ok = (() => { try { const t='__t'; localStorage.setItem(t,'1'); localStorage.removeItem(t); return true } catch { return false } })();
  ```
* In dev, consider forcing consent: `localStorage.setItem('cmp:consent','{"necessary":true,"analytics":false}')`.

## 5) (Optional) Clean up CSP so the noise goes away

Your current `<meta http-equiv="Content-Security-Policy" ‚Ä¶>` is malformed. Use proper directives; don‚Äôt put `'unsafe-dynamic'` under `default-src`, and don‚Äôt put `report-uri` in `default-src`.

A safe dev header:

```
Content-Security-Policy:
  default-src 'self';
  script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net https://cdnjs.cloudflare.com;
  style-src  'self' 'unsafe-inline' https://fonts.googleapis.com;
  img-src    'self' data: blob:;
  font-src   'self' https://fonts.gstatic.com;
  connect-src 'self' https://api.YOUR-STAFF-APP.com https://*.launchdarkly.com https://sentry.io https://sp.replit.com;
  frame-ancestors 'self';
  report-uri https://YOUR-REPORT-ENDPOINT.example/csp;
```

(Those warnings won‚Äôt affect autosave, but they drown your useful logs.)

# Quick verification checklist

1. Open devtools Console and confirm you see **`[CANON] bootstrap OK`** exactly once.
2. Type values in Step 1, then run:

   * `JSON.parse(localStorage.getItem('bf:canon:v1')).intent` ‚Üí should show `{ fundingType: 'Capital', amount: 73000, ‚Ä¶ }`
3. Navigate to Step 2 ‚Üí confirm ‚ÄúEquipment Financing‚Äù / ‚ÄúInvoice Factoring‚Äù are hidden when `fundingType === 'Capital'`.
4. Navigate Back to Step 1 ‚Üí fields should be repopulated from `canon`.
5. Submit ‚Üí the payload you POST to staff should include the whole `canon` snapshot (or a mapped version), not a different keyspace.

# If it still doesn‚Äôt work

* You‚Äôre likely running Step 1 inside a route segment that doesn‚Äôt use the shared layout (provider isn‚Äôt mounted there). Ensure **every** step route sits under the same root layout where `CanonProvider` and the CMP banner live.
* Or Step 1 fields are controlled by a form library (e.g., RHF/Formik) and you‚Äôre only persisting on blur/submit. Wire `onChange` ‚Üí `update()` as shown so persistence is immediate.

Want me to draft the exact `_app.tsx` / `layout.tsx` patch + Step 1/2 components in your structure? If you paste your file paths (or the relevant snippets), I‚Äôll drop in copy-pasteable diffs.
