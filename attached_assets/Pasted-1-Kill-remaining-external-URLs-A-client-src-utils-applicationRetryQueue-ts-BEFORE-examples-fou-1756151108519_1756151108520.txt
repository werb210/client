1) Kill remaining external URLs
A) client/src/utils/applicationRetryQueue.ts
// BEFORE (examples found by audit):
// const STAFF = "https://staff.boreal.financial";
// fetch(`${STAFF}/api/public/applications`, ...)

const BASE = ""; // same-origin only

export async function retrySubmitApplication(payload: any) {
  // All staff calls are relative paths:
  const res = await fetch(`/api/public/applications`, {
    method: "POST",
    credentials: "include",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });
  if (!res.ok) throw new Error(`Retry submit failed: ${res.status}`);
  return res.json();
}

B) client/src/utils/uploadDocument.ts
// Replace everything with a thin wrapper around the Staff API uploader.
import { uploadDocument } from "@/lib/api";

export async function uploadDocumentToStaff(appId: string, file: File, documentType: string) {
  return uploadDocument(appId, file, documentType);
}
export default uploadDocumentToStaff;

C) client/src/components/DynamicDocumentRequirements.tsx
// BEFORE: referenced S3/presigners
// AFTER: strictly Staff API
import React from "react";
import { listDocuments, getDocumentViewUrl, setDocumentStatus } from "@/lib/api";

export function DynamicDocumentRequirements({ applicationId }: { applicationId: string }) {
  const [docs, setDocs] = React.useState<any[]>([]);
  const [loading, setLoading] = React.useState(false);

  async function refresh() {
    setLoading(true);
    try {
      const res = await listDocuments(applicationId);
      setDocs(res.data || []);
    } finally {
      setLoading(false);
    }
  }
  React.useEffect(() => { refresh(); }, [applicationId]);

  async function view(docId: string) {
    const { url } = await getDocumentViewUrl(docId);
    if (url) window.open(url, "_blank", "noopener,noreferrer");
  }
  async function accept(docId: string) {
    await setDocumentStatus(docId, "accepted");
    refresh();
  }
  async function reject(docId: string) {
    await setDocumentStatus(docId, "rejected");
    refresh();
  }

  if (loading) return <div>Loading documents…</div>;
  return (
    <div className="space-y-2">
      {docs.map(d => (
        <div key={d.id} className="flex items-center justify-between gap-2 border p-2 rounded">
          <div>
            <div className="font-medium">{d.file_name}</div>
            <div className="text-xs text-gray-500">{d.document_type} · {d.status}</div>
          </div>
          <div className="flex gap-2">
            <button onClick={() => view(d.id)} className="btn btn-light">View</button>
            <button onClick={() => accept(d.id)} className="btn btn-success">Accept</button>
            <button onClick={() => reject(d.id)} className="btn btn-danger">Reject</button>
          </div>
        </div>
      ))}
      {docs.length === 0 && <div className="text-sm text-gray-500">No documents yet.</div>}
    </div>
  );
}

D) client/src/components/upload/DocumentUploadWidget.tsx
// Remove S3 imports and call Staff API uploader
import React from "react";
import { uploadDocument, listDocuments } from "@/lib/api";

export default function DocumentUploadWidget({ applicationId }: { applicationId: string }) {
  const [busy, setBusy] = React.useState(false);
  const [type, setType] = React.useState("bank_statements");
  const [files, setFiles] = React.useState<FileList | null>(null);

  async function onSubmit(e: React.FormEvent) {
    e.preventDefault();
    if (!files || files.length === 0) return;
    setBusy(true);
    try {
      for (const f of Array.from(files)) {
        await uploadDocument(applicationId, f, type);
      }
      // optional: force refresh elsewhere with a callback/event
      await listDocuments(applicationId);
      alert("Upload complete");
    } catch (err: any) {
      console.error(err);
      alert(`Upload failed: ${err?.message || err}`);
    } finally {
      setBusy(false);
    }
  }

  return (
    <form onSubmit={onSubmit} className="space-y-3">
      <select value={type} onChange={e => setType(e.target.value)} className="input">
        <option value="bank_statements">Bank Statements</option>
        <option value="financial_statements">Financial Statements</option>
        <option value="tax_returns">Tax Returns</option>
        <option value="business_license">Business License</option>
      </select>
      <input type="file" multiple onChange={e => setFiles(e.currentTarget.files)} />
      <button disabled={busy} className="btn btn-primary">{busy ? "Uploading…" : "Upload"}</button>
    </form>
  );
}

2) Ensure the runtime guard is active

In client/src/main.tsx (or the app’s root entry), import the guard once:

import "@/lib/fetch-guard"; // blocks any external origin fetch at runtime

3) Optional: make “S3” imports a compile-time error

Create client/src/types/block-s3.d.ts:

declare module "@/lib/s3Upload" {
  // Any import will fail typechecking loudly
  const __FORBIDDEN__: never;
  export default __FORBIDDEN__;
}

4) Client-side audit (copy/paste)
echo "== Expect no S3 references (other than the deprecated file throwing) =="
rg -n "s3|AWS|presign|presignedUrl|S3_" client/src | grep -v "s3Upload.ts" || true

echo "== Expect no hard-coded external URLs in client =="
rg -n "https?://(?!localhost|127\.0\.0\.1)" client/src || true
