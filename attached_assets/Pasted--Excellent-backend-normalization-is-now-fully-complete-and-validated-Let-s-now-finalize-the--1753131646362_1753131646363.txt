‚úÖ **Excellent ‚Äî backend normalization is now fully complete and validated.** Let's now finalize the next steps to ensure **client-side filtering works consistently** across all categories and input types.

---

## üîÑ Final Instructions for Replit Agent

### üîß CLIENT APPLICATION

Please proceed with the following final fixes and validations:

---

### ‚úÖ STEP 1: Update Filtering Engine to Use Dual Field Support

**Target File:** `client/src/hooks/useRecommendations.ts`

#### Implement:

```ts
function getAmountRange(product) {
  return {
    min: product.amount_min ?? product.minAmount ?? product.min_amount ?? 0,
    max: product.amount_max ?? product.maxAmount ?? product.max_amount ?? Infinity,
  };
}

function getRevenueMin(product) {
  return product.revenue_min ?? product.revenueMin ?? product.min_revenue ?? 0;
}
```

Use these inside the filtering logic for:

* `amountMatch`
* `revenueMatch`

---

### ‚úÖ STEP 2: Verify Filtering Across Categories

1. Navigate to **Step 2** (`/apply/step-2`)
2. Run in console:

   ```js
   validateProducts(); // already implemented in /public/validate-step2-filtering.js
   ```
3. Ensure output shows:

   * All **Working Capital**, **Term Loans**, **MCA**, etc. correctly filtered
   * Print **category**, **range**, and **pass/fail reason** for each

---

### ‚úÖ STEP 3: Fix Fallback Console Helper (Optional)

If `validateProducts()` does not exist, re-implement it using:

```js
function validateProducts() {
  fetch('/api/public/lenders')
    .then(res => res.json())
    .then(data => {
      const testAmount = 49999;
      const selectedCountryCode = 'CA';
      const categories = new Set();
      const passing = [];

      for (const p of data.products) {
        const min = p.amount_min ?? p.minAmount ?? 0;
        const max = p.amount_max ?? p.maxAmount ?? Infinity;
        const revenueMin = p.revenue_min ?? p.revenueMin ?? 0;

        const amountMatch = testAmount >= min && testAmount <= max;
        const revenueMatch = 200000 >= revenueMin;
        const countryMatch = p.country === selectedCountryCode || p.country === 'US/CA';

        if (amountMatch && revenueMatch && countryMatch) {
          passing.push(p.name);
          categories.add(p.category);
        } else {
          console.log(`‚ùå ${p.name} filtered out ‚Äî reason: ${!amountMatch ? 'amount' : !revenueMatch ? 'revenue' : 'country'}`);
        }
      }

      console.log('‚úÖ Passing Products:', passing);
      console.log('üß≠ Categories:', [...categories]);
    });
}
```

---

### ‚úÖ STEP 4: Run Manual Tests

Please test these scenarios:

| Country | Amount    | Revenue   | Category        | Expected Products |
| ------- | --------- | --------- | --------------- | ----------------- |
| CA      | \$40,000  | \$200,000 | Working Capital | 2 products        |
| CA      | \$100,000 | \$300,000 | Term Loans      | multiple          |
| US      | \$50,000  | \$100,000 | MCA             | at least 1        |

---

### üì© Final Confirmation Needed:

Once Replit confirms:

* Dual field access is live in `useRecommendations.ts`
* All tests above pass
* Console tool (`validateProducts()`) is working

‚Ä¶we will mark the full matching engine implementation ‚úÖ **production-ready**.

Let me know when you‚Äôre ready to instruct Replit to proceed with all steps.
