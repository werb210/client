// PURPOSE
// Receive Staff push and replace the in-memory catalog used by the client.
// Serve products at GET /api/lender-products (no more legacy/fallback pulls).
// Guarantees correct CA/US mapping and up-to-date list after Staff “Sync to Client”.

// ──────────────────────────────────────────────────────────────────────────────
// 0) ENV (client)
// ──────────────────────────────────────────────────────────────────────────────
// Add a shared token to authenticate Staff → Client push:
//   SYNC_TOKEN=super-long-random-string
// (must exactly match the Staff SYNC_TOKEN)

// ──────────────────────────────────────────────────────────────────────────────
// 1) SERVICE: In-memory catalog (client/server/services/lenderProductsCache.ts)
// ──────────────────────────────────────────────────────────────────────────────
import crypto from "crypto";

export type Canonical = {
  id: string;
  name: string;
  lender_name: string;
  country: "CA"|"US"|string;
  category: string;
  min_amount: number;
  max_amount: number;
  active: boolean;
  updated_at: string;
};

const STATE:{ data: Canonical[]; ts: number; sig: string } = { data: [], ts: 0, sig: "" };

const normCountry = (c = "") =>
  String(c).trim().toUpperCase()
    .replace("CANADA","CA")
    .replace("UNITED STATES","US");

function toCanonical(p:any): Canonical {
  return {
    id: String(p.id),
    name: p.name ?? "",
    lender_name: p.lender_name ?? "",
    country: normCountry(p.country ?? ""),
    category: p.category ?? "",
    min_amount: Number(p.min_amount ?? 0),
    max_amount: Number(p.max_amount ?? 0),
    active: Boolean(p.active ?? true),
    updated_at: new Date().toISOString()
  };
}

function signature(items: Canonical[]): string {
  const base = items.map(i=>[i.id,i.country,i.category,i.min_amount,i.max_amount,i.active?1:0].join("|")).sort().join("\n");
  return crypto.createHash("sha256").update(base).digest("hex");
}

export function replaceAll(incoming:any[]): { saved:number; CA:number; US:number; sig:string } {
  const canon = (Array.isArray(incoming) ? incoming : []).map(toCanonical)
    .filter(p => p.name && p.lender_name && p.country && p.category);

  const CA = canon.filter(p=>p.country==="CA").length;
  const US = canon.filter(p=>p.country==="US").length;

  STATE.data = canon;
  STATE.ts = Date.now();
  STATE.sig = signature(canon);

  return { saved: canon.length, CA, US, sig: STATE.sig };
}

export function getAll(): Canonical[] {
  return STATE.data;
}

// ──────────────────────────────────────────────────────────────────────────────
// 2) ROUTES: receive push + serve products
//    (client/server/routes/sync-lender-products.mjs)
// ──────────────────────────────────────────────────────────────────────────────
import express from "express";
import { replaceAll, getAll } from "../services/lenderProductsCache.ts";

const router = express.Router();

router.post("/api/sync/lender-products", express.json({ limit:"2mb" }), (req, res) => {
  try {
    const AUTH = req.get("authorization") || "";
    const token = (AUTH.startsWith("Bearer ") ? AUTH.slice(7) : "");
    if (!token || token !== (process.env.SYNC_TOKEN || "")) {
      return res.status(401).json({ ok:false, error:"unauthorized" });
    }

    const products = req.body?.products;
    if (!Array.isArray(products) || !products.length) {
      return res.status(400).json({ ok:false, error:"invalid_payload" });
    }

    const r = replaceAll(products);
    return res.json({ ok:true, ...r });
  } catch(e:any){
    return res.status(500).json({ ok:false, error:String(e?.message||e) });
  }
});

router.get("/api/lender-products", (_req, res) => {
  try {
    const items = getAll();
    res.json({ success:true, total: items.length, products: items });
  } catch(e:any){
    res.status(500).json({ success:false, error:String(e?.message||e) });
  }
});

export default router;

// ──────────────────────────────────────────────────────────────────────────────
// 3) MOUNT routes in client server entry (client/server/index.ts)
// ──────────────────────────────────────────────────────────────────────────────
import syncRoutes from "./routes/sync-lender-products.mjs";
app.use(syncRoutes);

// ──────────────────────────────────────────────────────────────────────────────
// 4) CLIENT UI reads ONLY from GET /api/lender-products
//    (no direct calls to staff; remove legacy pulls).
//    Example hook:
// ──────────────────────────────────────────────────────────────────────────────
/*
import { useQuery } from "@tanstack/react-query";

export function useLenderProducts(){
  return useQuery({
    queryKey:["lender-products"],
    queryFn: async () => {
      const r = await fetch("/api/lender-products");
      if (!r.ok) throw new Error("lender_products_failed");
      const j = await r.json();
      return j.products as Canonical[];
    }
  });
}
*/

// ──────────────────────────────────────────────────────────────────────────────
// 5) QUICK TESTS (Client shell)
// ──────────────────────────────────────────────────────────────────────────────
// Expect unauthorized (no token)
/// curl -s -X POST http://localhost:5000/api/sync/lender-products -d '{}' -H 'Content-Type: application/json' | jq .
// Push from Staff (will include token) → after that:
/// curl -s http://localhost:5000/api/lender-products | jq '{total, byCountry: ([.products[].country] | sort | unique)}'
