You’re seeing **“Product Matching Pending”** because **Step 2 isn’t receiving any intake data from Step 1**. In the preview you’re using, the app does a full page reload (service-worker + form submit), your in-memory `FormDataContext` is re-mounted, and nothing is persisted—so Step 2 has nothing to match against even though products are available.

Here’s the quickest, deterministic fix.

# Fix (Client app)

### 1) Persist Step 1 to storage (and keep SPA navigation)

In your Step 1 submit handler (or form context), normalize → save to both storages → push route via the router (no `<form action>` and no full page reload).

```ts
// client/src/context/FormDataContext.tsx (or Step1 submit file)
type Intake = {
  country: 'US'|'CA';
  amountRequested: number;
  industry?: string;
  yearsInBusiness?: number;
  revenue12m?: number;
  avgMonthlyRevenue?: number;
  purpose?: string;
  arBalance?: number;
  collateralValue?: number;
};

const toNumber = (v:any) => typeof v === 'number' ? v : Number(String(v ?? '').replace(/[^0-9.]/g,''));

export function normalizeIntake(raw:any): Intake {
  return {
    country: raw.country ?? 'US',
    amountRequested: toNumber(raw.fundingAmount ?? raw.requestedAmount ?? raw.amountRequested),
    industry: raw.industry ?? raw.naics,
    yearsInBusiness: toNumber(raw.yearsInBusiness ?? raw.businessAgeYears),
    revenue12m: toNumber(raw.revenueLast12Months ?? raw.annualRevenue),
    avgMonthlyRevenue: toNumber(raw.avgMonthlyRevenue ?? raw.monthlyRevenue),
    purpose: raw.purposeOfFunds ?? raw.purpose,
    arBalance: toNumber(raw.currentARBalance ?? raw.accountsReceivable),
    collateralValue: toNumber(raw.fixedAssetsValue ?? raw.collateralValue),
  };
}

function persistIntake(i: Intake) {
  sessionStorage.setItem('bf:intake', JSON.stringify(i));
  localStorage.setItem('bf:intake', JSON.stringify(i));
  (window as any).__step2 = { ...(window as any).__step2, intake:i };
}

// In the Step 1 submit handler:
import { useNavigate } from 'react-router-dom';

function onSubmitStep1(raw:any){
  const intake = normalizeIntake(raw);
  persistIntake(intake);
  navigate('/apply/step-2');        // SPA navigation — no full reload
}
```

**Ensure the Step 1 “Continue” button does not trigger a native form POST.**

* `<button type="submit">` inside React Hook Form is fine, **but** don’t set a `form action`.
* If you used a plain `<a href="/apply/step-2">`, replace it with router navigation as above.

### 2) Read intake in Step 2 and fail loudly (not “pending”)

```tsx
// client/src/components/Step2RecommendationEngine.tsx
const requireIntake = () => {
  const s = sessionStorage.getItem('bf:intake') || localStorage.getItem('bf:intake');
  return s ? JSON.parse(s) : null;
};

function Pending({msg}:{msg:string}) {
  return <div className="rounded-md border p-6 text-center text-sm text-muted-foreground">{msg}</div>;
}

export default function Step2RecommendationEngine(){
  const intake = requireIntake();
  (window as any).__step2 = { ...(window as any).__step2, intake };

  if (!intake) return <Pending msg="Missing Step 1 data. Please complete Step 1." />;

  // …then fetch products and run your matcher (as you already have)
}
```

### 3) Stop dev preview from nuking state

Those red **service-worker cache** errors in your screenshot show the SW still intercepts navigation. Disable it in dev:

```ts
// client/src/main.tsx (or a dev-only bootstrap file)
if (import.meta.env.DEV && 'serviceWorker' in navigator) {
  navigator.serviceWorker.getRegistrations().then(rs => rs.forEach(r => r.unregister()));
}
```

Then **use “Open in new tab”** (not the embedded Preview iframe) when testing Step 1 → Step 2. The iframe’s sandbox often forces reloads that wipe state.

### 4) Confirm products come from the right place (Staff)

Keep your products fetch forced to Staff so data is consistent:

```ts
// client/src/api/products.ts
const BASE = import.meta.env.VITE_STAFF_API_URL!;
const TOK  = import.meta.env.VITE_CLIENT_APP_SHARED_TOKEN!;

export async function fetchProducts() {
  const res = await fetch(`${BASE}/v1/products`, { headers: { Authorization: `Bearer ${TOK}` } });
  if (!res.ok) throw new Error(`products_fetch_failed_${res.status}`);
  const data = await res.json();
  (window as any).__step2 = { ...(window as any).__step2, source:'staff', productsCount:data.length };
  return data;
}
```

Secrets (Deployment → **Deployment** secrets):

```
NODE_ENV=production
VITE_STAFF_API_URL=https://staff.boreal.financial/api
VITE_CLIENT_APP_SHARED_TOKEN=<fp 294b3e442db5>
VITE_LOCAL_FALLBACK=false
```

> If you must demo in dev, still set `VITE_LOCAL_FALLBACK=false` so you don’t silently fall back to file cache.

### 5) Quick verification (on `/apply/step-2`)

Open the browser console and run:

```js
window.__step2               // should include { intake: {...} }
JSON.parse(sessionStorage.getItem('bf:intake') || localStorage.getItem('bf:intake'))
```

You should see the normalized intake object, and your UI should render product cards (or a clear “No eligible products” message if your filters cut everything).

---

## Why this fixes your exact screenshot

* The banner **literally** says *“We couldn’t read your details from Step 1.”* That’s not a product fetch problem; it’s a persistence / navigation problem.
* In preview, a service-worker + iframe sandbox combo causes a reload between steps; without explicit storage, your context resets → Step 2 sees `null` → shows *pending*.
* Persisting intake + SPA navigation makes Step 2 deterministic and immune to those reloads.
