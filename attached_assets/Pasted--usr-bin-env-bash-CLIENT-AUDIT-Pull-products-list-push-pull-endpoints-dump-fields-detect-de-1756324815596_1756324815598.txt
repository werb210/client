#!/usr/bin/env bash
# CLIENT AUDIT — Pull products, list push/pull endpoints, dump fields, detect defaults/hardcodes.
# Run from the client repo root (or wherever your client server runs). Requires: curl, jq. Optional: rg.
set -euo pipefail
need(){ command -v "$1" >/dev/null || { echo "Missing $1"; exit 1; }; }
need curl; need jq; command -v rg >/dev/null || true

CLIENT_BASE="${CLIENT_BASE:-http://localhost:5000}"
STAFF_BASE="${STAFF_BASE:-https://staff.boreal.financial}"
OUT="${OUT:-client_lender_products_audit.json}"
DIAG="${DIAG:-1}"     # try provenance ?diag=1 on supported endpoints
EXPECT_CA="${EXPECT_CA:-17}"
EXPECT_US="${EXPECT_US:-25}"

p(){ printf "\n===== %s =====\n" "$1"; }

# Helper to add ?diag=1 if requested
durl(){ local u="$1"; [[ "$DIAG" == "1" ]] && [[ "$u" == *\?* ]] && echo "$u&diag=1" || { [[ "$DIAG" == "1" ]] && echo "$u?diag=1" || echo "$u"; }; }

# 0) Tell the CLIENT app to PULL fresh products from Staff (best-effort)
p "CLIENT pull → Staff"
PULL_ENDPOINTS=(
  "$CLIENT_BASE/pull-products"
  "$CLIENT_BASE/api/_admin/push-products"
)
for ep in "${PULL_ENDPOINTS[@]}"; do
  echo "POST $ep"
  set +e
  curl -fsS -X POST "$ep" -H 'accept: application/json' -H 'content-type: application/json' -d '{}' | jq . || true
  set -e
done

# 1) Enumerate API endpoints used by CLIENT to push/pull (code scan best-effort)
p "CLIENT endpoints used (code scan best-effort)"
if command -v rg >/dev/null; then
  rg -n --hidden --iglob '!node_modules' --fixed-strings \
    '/api/v1/products' \
    '/api/lender-products' \
    '/api/catalog/export-products' \
    '/pull-products' \
    '/api/_admin/push-products' \
    'https://staff.boreal.financial/api/lender-products' \
    'https://staff.boreal.financial/api/v1/products' \
    || true
else
  grep -RIn --exclude-dir=node_modules \
    -e '/api/v1/products' -e '/api/lender-products' -e '/api/catalog/export-products' \
    -e '/pull-products' -e '/api/_admin/push-products' \
    -e 'https://staff.boreal.financial/api/lender-products' \
    -e 'https://staff.boreal.financial/api/v1/products' \
    . || true
fi

# 2) Fetch CLIENT-proxied products (V1 preferred; legacy optional)
C_V1="$(curl -fsS "$(durl "$CLIENT_BASE/api/v1/products")" || echo '{"items":[]}')"
C_V1_ITEMS="$(printf '%s' "$C_V1" | jq -c '.items // (if type=="array" then . else [] end)')"
C_LEGACY_RAW="$(curl -fsS "$(durl "$CLIENT_BASE/api/lender-products")" 2>/dev/null || echo '')"
C_LEGACY_LIST="$(printf '%s' "$C_LEGACY_RAW" | jq -c 'if type=="array" then . else .products end // []')"

# 3) Fetch STAFF truth (for cross-check)
S_V1="$(curl -fsS "$(durl "$STAFF_BASE/api/v1/products")" || echo '{"items":[]}')"
S_V1_ITEMS="$(printf '%s' "$S_V1" | jq -c '.items // (if type=="array" then . else [] end)')"

# 4) Countries (CLIENT vs STAFF)
p "Country distribution (CLIENT vs STAFF)"
C_CA="$(printf '%s' "$C_V1_ITEMS" | jq '[.[]|select((.country // .countryOffered // "NULL")|ascii_upcase=="CA")] | length')"
C_US="$(printf '%s' "$C_V1_ITEMS" | jq '[.[]|select((.country // .countryOffered // "NULL")|ascii_upcase=="US")] | length')"
S_CA="$(printf '%s' "$S_V1_ITEMS" | jq '[.[]|select((.country // .countryOffered // "NULL")|ascii_upcase=="CA")] | length')"
S_US="$(printf '%s' "$S_V1_ITEMS" | jq '[.[]|select((.country // .countryOffered // "NULL")|ascii_upcase=="US")] | length')"
echo "CLIENT v1: CA=$C_CA US=$C_US"
echo "STAFF  v1: CA=$S_CA US=$S_US"
[[ "$S_CA" -eq "$EXPECT_CA" && "$S_US" -eq "$EXPECT_US" ]] || echo "⚠️ Staff not at expected split; update EXPECT_CA/EXPECT_US if needed."
[[ "$C_CA" -eq "$S_CA" && "$C_US" -eq "$S_US" ]] || echo "⚠️ Client split differs from Staff (stale cache/wrong path)."

# 5) Field set & provenance (if available)
p "CLIENT field set + provenance (if ?diag=1 supported)"
# union of keys for v1 items
printf '%s' "$C_V1_ITEMS" | jq '
  reduce .[] as $p ({}; . + ($p|keys|map({(.):true})|add)) | keys
'
# sample + _prov
printf '%s' "$C_V1" | jq '{
  sample: (.items // (if type=="array" then . else [] end) | .[0]),
  _diag: ._diag // "no _diag (diag disabled)"
}'

# 6) Heuristic default/hardcode detection on CLIENT (works even without _prov)
p "CLIENT default/hardcode detection (heuristic)"
printf '%s' "$C_V1_ITEMS" | jq '[
  {
    field:"country",
    all_null:(map(.country // .countryOffered)|all(.==null)),
    all_us:(map(((.country // .countryOffered // "NULL")|ascii_upcase)=="US")|all(.==true)),
    mixed:( (map(.country // .countryOffered)|unique|length) > 1 )
  },
  { field:"min_amount", many_zeros:(map((.min_amount // .minimumLendingAmount // 0)==0)|select(length>0)|add > (length/2)) },
  { field:"max_amount", many_zeros:(map((.max_amount // .maximumLend_
