Client Application (frontend)
1) Ensure fetch includes credentials globally
File: client/src/lib/api.ts (or wherever you create your fetch/axios)
// Example with fetch wrapper:
export async function api<T>(path: string, options: RequestInit = {}) {
  const res = await fetch(path, {
    ...options,
    credentials: "include", // <<< IMPORTANT for cookies
    headers: {
      "Content-Type": "application/json",
      ...(options.headers || {}),
    },
  });
  if (!res.ok) throw new Error(await res.text());
  return (await res.json()) as T;
}
(If you use axios, set axios.defaults.withCredentials = true.)
2) Fix the OTP screen to use /verify-2fa and include credentials
File: client/src/pages/auth/Otp.tsx (replace the verification call)
import React, { useState } from "react";
import { api } from "../../lib/api"; // the wrapper above

export default function OtpPage({ email }: { email: string }) {
  const [code, setCode] = useState("");
  const [status, setStatus] = useState<"idle"|"verifying"|"error">("idle");
  const [error, setError] = useState("");

  async function handleVerify(e: React.FormEvent) {
    e.preventDefault();
    setStatus("verifying");
    setError("");

    try {
      const resp = await api<{ success: boolean; message?: string; user?: any }>(
        "/api/auth/verify-2fa",
        {
          method: "POST",
          body: JSON.stringify({ email, code }),
        }
      );

      if (resp.success) {
        // cookie is now set; route to portal/dashboard
        window.location.href = "/portal";
      } else {
        setStatus("error");
        setError(resp.message || "Invalid code");
      }
    } catch (err: any) {
      setStatus("error");
      setError(err?.message || "Verification failed");
    }
  }

  return (
    <form onSubmit={handleVerify} className="otp-form">
      <h1>Enter the 2FA code</h1>
      <input
        inputMode="numeric"
        autoFocus
        value={code}
        onChange={(e) => setCode(e.target.value)}
        placeholder="6-digit code"
        maxLength={8}
      />
      <button disabled={status==="verifying"} type="submit">
        {status==="verifying" ? "Verifying…" : "Verify"}
      </button>
      {status==="error" && <p className="error">{error}</p>}
    </form>
  );
}
3) Make the “send code” button hit /request-2fa
Wherever your “Send code” / “Resend” lives:
await api("/api/auth/request-2fa", {
  method: "POST",
  body: JSON.stringify({ email }),
});
What this fixes (and why your code said “invalid”)
The UI was posting to the wrong endpoint and/or not including credentials, so even when Twilio said approved, your browser never got the bf_auth cookie, and /api/auth/user kept saying “decoded: false”.
The server would sometimes send two responses (success then fallback), producing “headers already sent” and a client-side error. The sendOnce() + early returns eliminate that entirely.
We removed all legacy /verify-otp paths so there’s only one source of truth: Twilio Verify via /request-2fa + /verify-2fa.
Quick test script (end-to-end)
Logout / clear session in the browser (or delete bf_auth).
Login with: todd.w@boreal.financial / admin123.
On the OTP screen:
Click Send code (calls /request-2fa).
Enter the newest 6-digit SMS.
Submit (calls /verify-2fa with credentials: "include").
You should land on /portal and GET /api/auth/user should return your user.
if anything fails after applying these blocks, paste the server console lines for /request-2fa and /verify-2fa (just those two calls) and I’ll read the exact statuses (pending/approved) and the cookie set log to pinpoint it.