// PURPOSE
// Keep the submission payload 1:1 with Staff data. No defaulting country/category/amounts.
// Preflight validation against /api/applications/validate-intake before enabling Submit.
// Include product SNAPSHOT fields the UI actually used.

export type V1Product = {
  id: string;
  productName: string;
  lenderName: string;
  countryOffered: string | null;
  productCategory: string | null;
  minimumLendingAmount: number | null;
  maximumLendingAmount: number | null;
  isActive: boolean | null;
  min_time_in_business: number | null;
  min_monthly_revenue: number | null;
  excluded_industries: string[];
  required_documents: string[] | null;
};

export type Intake = {
  product_id: string;
  country: "US" | "CA";
  amount: number;
  timeInBusinessMonths?: number;
  monthlyRevenue?: number;
  industry?: string;
};

async function getJSON<T>(url: string, init?: RequestInit): Promise<T> {
  const r = await fetch(url, { credentials: "include", ...init });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

export async function fetchProductsV1(): Promise<V1Product[]> {
  const list = await getJSON<V1Product[]>("/api/v1/products");
  return list.map(p => ({
    ...p,
    countryOffered: p.countryOffered ? p.countryOffered.toUpperCase() : null,
    productCategory: p.productCategory?.trim() || null,
    minimumLendingAmount: p.minimumLendingAmount ?? null,
    maximumLendingAmount: p.maximumLendingAmount ?? null,
  }));
}

// Step 2 recommendation: filter ONLY by Staff constraints (no invented defaults)
export function recommend(intake: Intake, products: V1Product[]) {
  const tib = intake.timeInBusinessMonths ?? 0;
  const rev = intake.monthlyRevenue ?? 0;
  return products.filter(p => {
    if (p.isActive === false) return false;
    if (p.countryOffered && p.countryOffered !== intake.country) return false;
    if (p.minimumLendingAmount != null && intake.amount < p.minimumLendingAmount) return false;
    if (p.maximumLendingAmount != null && intake.amount > p.maximumLendingAmount) return false;
    if (p.min_time_in_business != null && tib < p.min_time_in_business) return false;
    if (p.min_monthly_revenue != null && rev < p.min_monthly_revenue) return false;
    if (intake.industry && (p.excluded_industries || []).includes(intake.industry)) return false;
    return true;
  });
}

// Step 5 docs: prefer Staff-provided docs, minimal fallback otherwise
export function resolveDocs(p: V1Product): string[] {
  if (Array.isArray(p.required_documents) && p.required_documents.length) return p.required_documents;
  return ["Last 6 months bank statements"];
}

// Preflight validation before enabling Submit
export async function validateIntake(intake: Intake) {
  return getJSON<{ok:boolean; errors?:string[]; product?:V1Product; required_documents?:string[]}>(
    "/api/applications/validate-intake",
    { method: "POST", headers: { "Content-Type":"application/json" }, body: JSON.stringify(intake) }
  );
}

// Final submit (server re-validates & stores product snapshot)
export async function submitApplication(intake: Intake) {
  const v = await validateIntake(intake);
  if (!v.ok) throw new Error((v.errors||["validation failed"]).join("; "));
  const r = await getJSON<{ok:boolean; id:string}>(
    "/api/applications",
    { method: "POST", headers: { "Content-Type":"application/json" }, body: JSON.stringify(intake) }
  );
  return r.id;
}

/* UI wiring (pseudo)
const onSubmit = async () => {
  setSubmitting(true);
  try {
    const id = await submitApplication({
      product_id: selectedProduct.id,
      country: form.country,
      amount: form.amount,
      timeInBusinessMonths: form.tib,
      monthlyRevenue: form.revenue,
      industry: form.industry,
    });
    toast.success(`Submitted #${id}`);
  } catch (e:any) {
    toast.error(e.message || "Submit failed");
  } finally { setSubmitting(false); }
};
*/
