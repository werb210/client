CLIENT APPLICATION (Frontend)
1) Login uses cookie and stores bearer fallback
Edit client/src/api/auth.ts:
import { apiPost, apiGet, setBearer } from './http';

export async function login(email: string, password: string) {
  const res = await apiPost('/api/auth/login', { email, password });
  // If a bearer is provided, set it as a fallback for environments where cookies won't stick.
  if (res?.bearer) setBearer(res.bearer);
  return res;
}

export async function fetchMe() {
  try {
    const r = await apiGet('/api/rbac/auth/me');
    return r?.user ?? null;
  } catch {
    return null;
  }
}
Edit client/src/api/http.ts to support bearer header:
let BEARER: string | null = null;

export function setBearer(tok: string | null) { BEARER = tok || null; }

// Resolve API base (same-origin default)
const API_BASE = (import.meta as any)?.env?.VITE_API_BASE || '';

async function handle(res: Response) {
  const text = await res.text();
  let body: any = null;
  try { body = text ? JSON.parse(text) : null; } catch {}
  if (!res.ok) {
    const msg = body?.reason || body?.message || `${res.status} ${res.statusText}`;
    throw new Error(msg);
  }
  return body;
}

function withAuth(init?: RequestInit): RequestInit {
  const headers = new Headers((init && init.headers) || {});
  if (BEARER && !headers.has('Authorization')) headers.set('Authorization', `Bearer ${BEARER}`);
  return { ...init, headers, credentials: 'include' }; // include cookies when available
}

export async function apiGet<T = any>(path: string): Promise<T> {
  const res = await fetch(`${API_BASE}${path}`, withAuth());
  return handle(res);
}

export async function apiPost<T = any>(path: string, body?: any): Promise<T> {
  const res = await fetch(`${API_BASE}${path}`, withAuth({
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: body ? JSON.stringify(body) : undefined,
  }));
  return handle(res);
}
2) PrivateRoute stays real (no bypass)
Keep the previously provided PrivateRoute that awaits /me and shows “Verifying…”. Do not reintroduce any “always authenticated” logic.
3) iPad-friendly tip (optional)
Add a small notice near the login button: “On iPad, if you’re in an embedded view, tap ‘Open in New Tab’ to sign in.” (No code required if you don’t want UI text.)
HARD RULES FOR REPLIT (print this first in your report)
Do not add or keep any auth bypass (headers, flags, or hardcoded users).
Only implement the patches above.
Report back with the exact commands run, diffs, and outputs below.
WHAT YOU MUST REPORT BACK
Env check (no secrets):
Print whether UI_ORIGIN, API_ORIGIN, COOKIE_DOMAIN, NODE_ENV are set.
Diffs:
git diff -- server/routes/auth.ts server/routes/rbacAuth.ts server/index.ts
git diff -- client/src/api/http.ts client/src/api/auth.ts client/src/components/PrivateRoute.tsx
Backend roundtrip (no browser needed):
curl -s -i -c /tmp/c.jar -H "Content-Type: application/json" \
  -d '{"email":"todd.w@boreal.financial","password":"password123"}' \
  https://staff.boreal.financial/api/auth/login | head -n 20

# With cookie only
curl -s -b /tmp/c.jar https://staff.boreal.financial/api/rbac/auth/me

# With bearer only (extract from previous JSON manually if needed)
curl -s -H "Authorization: Bearer <PASTE_TOKEN>" https://staff.boreal.financial/api/rbac/auth/me
Paste statuses + bodies (redact the token if you want, but prove it worked).
Frontend behavior (brief):
On desktop: normal login → reaches /portal.
On iPad: if cookies blocked, login still works via bearer (no bypass). Confirm the app loads after login.
Grep guardrails (must be clean):
grep -RIn "todd.w@boreal.financial" client/src || echo "OK: no hardcoded demo user"
grep -RInE "bypass|direct.?access" client/src || echo "OK: no bypass strings"
grep -RInE "isAuthenticated\s*=\s*true" client/src || echo "OK: no forced auth"
If anything fails, don’t add another bypass. Paste the failing output here, and I’ll give a tiny targeted correction.