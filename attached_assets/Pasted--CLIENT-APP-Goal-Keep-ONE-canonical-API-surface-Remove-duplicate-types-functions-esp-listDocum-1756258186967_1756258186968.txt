[CLIENT APP]

Goal: Keep ONE canonical API surface. Remove duplicate types/functions (esp. listDocuments, CanonicalProduct). Make Step 2 & Step 5 import from a single place.

What youâ€™ll paste:

// FILE: client/src/lib/api.ts  (replace entire file)
export type CanonicalProduct = {
  id: string;
  name: string;
  lender_id: string;
  lender_name: string;
  country: "CA" | "US";
  category: string;
  min_amount: number;
  max_amount: number;
  interest_rate_min: number | null;
  interest_rate_max: number | null;
  term_min: number | null;
  term_max: number | null;
  active: boolean;
  required_documents: Array<{ key: string; label: string; required: boolean; months?: number }>;
};

function toCanonicalFromLegacy(lp: any): CanonicalProduct {
  const raw = String(lp.countryOffered || lp.country || "").trim().toUpperCase();
  const country =
    raw === "CANADA" || raw === "CAN" ? "CA" :
    raw === "USA" || raw === "UNITED STATES" ? "US" :
    (raw || "US");
  return {
    id: String(lp.id ?? ""),
    name: String(lp.name ?? lp.productName ?? ""),
    lender_id: String(lp.lender_id ?? lp.lenderId ?? lp.lenderName ?? ""),
    lender_name: String(lp.lender_name ?? lp.lenderName ?? ""),
    country: country as "CA" | "US",
    category: String(lp.category ?? lp.productCategory ?? "Working Capital"),
    min_amount: Number(lp.min_amount ?? lp.minimumLendingAmount ?? 0),
    max_amount: Number(lp.max_amount ?? lp.maximumLendingAmount ?? Number.MAX_SAFE_INTEGER),
    interest_rate_min: lp.interest_rate_min ?? lp.interestRateMinimum ?? null,
    interest_rate_max: lp.interest_rate_max ?? lp.interestRateMaximum ?? null,
    term_min: lp.term_min ?? lp.termMinimum ?? null,
    term_max: lp.term_max ?? lp.termMaximum ?? null,
    active: (lp.active ?? lp.isActive) !== false,
    required_documents: Array.isArray(lp.required_documents ?? lp.documentsRequired)
      ? (lp.required_documents ?? lp.documentsRequired)
      : [{ key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 }],
  };
}

export async function fetchCatalogProducts(params?: {
  country?: "CA" | "US";
  amount?: number;
  includeInactive?: boolean;
}): Promise<CanonicalProduct[]> {
  const qs = new URLSearchParams();
  if (params?.country) qs.set("country", params.country);
  if (params?.amount != null) qs.set("amount", String(params.amount));
  qs.set("includeInactive", params?.includeInactive ? "1" : "0");

  try {
    const r = await fetch(`/api/catalog/export-products?${qs.toString()}`, { credentials: "include" });
    if (r.ok) {
      const j = await r.json();
      if (Array.isArray(j?.products)) return j.products as CanonicalProduct[];
    }
  } catch {}
  const r2 = await fetch(`/api/lender-products`, { credentials: "include" });
  const j2 = await r2.json();
  const items = Array.isArray(j2?.products) ? j2.products : [];
  return items.map(toCanonicalFromLegacy);
}

// Step 2
export type IntakeInput = {
  amount: number;
  country: "CA" | "US";
  timeInBusinessMonths?: number;
  monthlyRevenue?: number;
  creditScore?: number;
};
export async function recommendProducts(intake: IntakeInput) {
  const products = await fetchCatalogProducts({ country: intake.country, amount: intake.amount });
  const eligible = products.filter(p => p.active &&
    (!intake.country || p.country === intake.country) &&
    (p.min_amount <= intake.amount && intake.amount <= p.max_amount)
  );
  const ranked = eligible
    .map(p => ({ score: Math.abs((p.max_amount ?? Number.MAX_SAFE_INTEGER) - intake.amount), p }))
    .sort((a, b) => a.score - b.score || (b.p.max_amount - a.p.max_amount))
    .map(x => x.p);
  const byCategory = ranked.reduce((acc, p) => {
    (acc[p.category] ||= []).push(p);
    return acc;
  }, /** @type {Record<string, CanonicalProduct[]>} */({}));
  return { products: ranked, byCategory };
}

// Step 5
export type RequiredDocsInput = {
  category?: string;
  country?: "CA" | "US";
  amount?: number;
  lenderId?: string;
  timeInBusinessMonths?: number;
  monthlyRevenue?: number;
  creditScore?: number;
};
const DOCS_FALLBACK: Record<string, Array<{ key: string; label: string; required: boolean; months?: number }>> = {
  "Working Capital": [{ key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 }],
  "Business Line of Credit": [{ key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 }],
  "Term Loan": [{ key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 }],
  "Equipment Financing": [{ key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 }],
  "Invoice Factoring": [{ key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 }],
  "Purchase Order Financing": [{ key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 }],
};
export async function listDocuments(input: RequiredDocsInput) {
  try {
    const r = await fetch(`/api/required-docs`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      credentials: "include",
      body: JSON.stringify(input),
    });
    if (r.ok) {
      const j = await r.json();
      const docs = j?.documents ?? j?.requiredDocs ?? j?.data ?? [];
      if (Array.isArray(docs) && docs.length) return docs;
    }
  } catch {}
  const cat = input.category ?? "Working Capital";
  return DOCS_FALLBACK[cat] ?? DOCS_FALLBACK["Working Capital"];
}

// FILE: client/src/hooks/useLenderProducts.ts  (replace entire file)
import { useQuery } from "@tanstack/react-query";
import { fetchCatalogProducts, type CanonicalProduct } from "@/lib/api";

export function useLenderProducts(params?: { country?: "CA" | "US"; amount?: number }) {
  return useQuery<CanonicalProduct[]>({
    queryKey: ["catalogProducts", params?.country, params?.amount],
    queryFn: () => fetchCatalogProducts({ country: params?.country, amount: params?.amount }),
  });
}

// FILE: client/src/hooks/useRecommendations.ts  (replace entire file)
import { useQuery } from "@tanstack/react-query";
import { recommendProducts, type IntakeInput } from "@/lib/api";

export function useRecommendations(intake: IntakeInput | null) {
  return useQuery({
    queryKey: ["recommendations", intake],
    enabled: !!intake,
    queryFn: () => recommendProducts(intake as IntakeInput),
  });
}

// FILE: client/src/components/DynamicDocumentRequirements.tsx  (replace entire file)
import { useEffect, useState } from "react";
import { listDocuments, type RequiredDocsInput } from "@/lib/api";

type Item = { key: string; label: string; required: boolean; months?: number };

export default function DynamicDocumentRequirements(props: RequiredDocsInput) {
  const [docs, setDocs] = useState<Item[]>([]);
  useEffect(() => {
    listDocuments(props).then(arr => {
      const normalized = (arr ?? []).map((d: any, i: number) =>
        typeof d === "string" ? { key: `doc_${i}`, label: d, required: true } : d
      );
      setDocs(normalized);
    });
  }, [props.category, props.country, props.amount, props.lenderId]);

  return (
    <div>
      <h3 className="text-lg font-semibold">Required Documents</h3>
      <ul className="mt-2 space-y-2">
        {docs.map(d => (
          <li key={d.key} className="flex items-center gap-2">
            <input type="checkbox" defaultChecked={d.required} disabled />
            <span>{d.label}{d.months ? ` (${d.months} months)` : ""}</span>
          </li>
        ))}
      </ul>
    </div>
  );
}

// FILE: client/_dedupe_cleanup.txt  (paste & run these in your shell after saving files)
// sh
rm -f client/src/lib/catalog.ts client/src/types/enhancedLenderProduct.ts client/src/lib/finalizedLenderSync.ts 2>/dev/null
find client/src -type f -name 'DynamicDocumentRequirements*.tsx' ! -path '*/components/DynamicDocumentRequirements.tsx' -delete 2>/dev/null
find client/src -type f -name '*catalog*dump*.tsx' -name '*copy*' -delete 2>/dev/null
