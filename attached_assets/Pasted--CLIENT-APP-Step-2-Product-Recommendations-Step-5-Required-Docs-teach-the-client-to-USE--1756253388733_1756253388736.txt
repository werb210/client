[CLIENT APP]

# Step 2 (Product Recommendations) + Step 5 (Required Docs) — teach the client to USE the canonical catalog data.
# Paste these edits verbatim.

# ---------------------------------------------------------------------------
# FILE: client/src/lib/api.ts
# (Append or adjust exports—keeps your canonical dump + legacy fallback.)

export type IntakeInput = {
  amount: number;
  country: "CA" | "US";
  timeInBusinessMonths?: number;
  monthlyRevenue?: number;
  creditScore?: number;
  category?: string; // optional pre-selected category
};

export type CategoryRecommendation = {
  category: string;
  products: CanonicalProduct[];
};

const DOCS_FALLBACK: Record<string, RequiredDoc[]> = {
  "Working Capital": [{ key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 }],
  "Business Line of Credit": [{ key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 }],
  "Term Loan": [{ key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 }],
  "Equipment Financing": [{ key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 }],
  "Invoice Factoring": [{ key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 }],
  "Purchase Order Financing": [{ key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 }],
};

export async function recommendProducts(input: IntakeInput): Promise<CategoryRecommendation[]> {
  const { products } = await fetchCatalogDump(500); // trusts canonical category when available
  const amt = Number(input.amount || 0);
  const cc = String(input.country || "").toUpperCase();

  // 1) Filter by country + amount window
  const matches = products.filter(p =>
    p.country === cc &&
    (Number.isFinite(p.min_amount) ? p.min_amount <= amt : true) &&
    (Number.isFinite(p.max_amount) ? amt <= p.max_amount : true) &&
    p.active !== false
  );

  // 2) Simple relevance scoring (closest max_amount first; then higher max)
  const scored = matches
    .map(p => ({
      score: Math.abs((p.max_amount ?? Number.MAX_SAFE_INTEGER) - amt),
      p,
    }))
    .sort((a, b) => a.score - b.score || (b.p.max_amount ?? 0) - (a.p.max_amount ?? 0))
    .map(x => x.p);

  // 3) Group by canonical category
  const byCat = new Map<string, CanonicalProduct[]>();
  for (const p of scored) {
    const cat = p.category || "Working Capital";
    if (!byCat.has(cat)) byCat.set(cat, []);
    byCat.get(cat)!.push(p);
  }

  // 4) If caller specified a category, surface it first
  const result: CategoryRecommendation[] = [];
  const order = Array.from(byCat.keys());
  if (input.category && byCat.has(input.category)) {
    result.push({ category: input.category, products: byCat.get(input.category)! });
  }
  for (const c of order) {
    if (!input.category || c !== input.category) {
      result.push({ category: c, products: byCat.get(c)! });
    }
  }
  return result;
}

export type RequiredDocsInput = {
  category?: string;
  country?: "CA" | "US";
  amount?: number;
  lenderId?: string;
  timeInBusinessMonths?: number;
  monthlyRevenue?: number;
  creditScore?: number;
};

export async function listDocuments(input: RequiredDocsInput): Promise<RequiredDoc[]> {
  // Prefer Staff endpoint; fall back to baseline (6-month bank statements) per category.
  try {
    const r = await fetch("/api/required-docs", {
      method: "POST",
      headers: JSON_HEADERS,
      credentials: "include",
      body: JSON.stringify(input),
    });
    if (r.ok) {
      const j = await r.json();
      const docs = j?.documents ?? j?.requiredDocs ?? j?.data ?? [];
      if (Array.isArray(docs) && docs.length) {
        return docs.map((d: any, i: number) =>
          typeof d === "string" ? { key: `doc_${i}`, label: d, required: true } : d
        );
      }
    }
  } catch { /* noop → fallback */ }

  const cat = input.category || "Working Capital";
  return DOCS_FALLBACK[cat] ?? DOCS_FALLBACK["Working Capital"];
}

# ---------------------------------------------------------------------------
# FILE: client/src/components/Step2RecommendationEngine.tsx
# (Teach Step 2 to consume canonical catalog + show grouped categories.)

import React from "react";
import { recommendProducts, type CategoryRecommendation, type IntakeInput } from "@/lib/api";

type Props = {
  intake: IntakeInput; // { amount, country, timeInBusinessMonths?, monthlyRevenue?, creditScore? }
  onSelectProduct?: (p: any) => void;
};

export default function Step2RecommendationEngine({ intake, onSelectProduct }: Props) {
  const [groups, setGroups] = React.useState<CategoryRecommendation[]>([]);
  const [loading, setLoading] = React.useState(false);
  const [err, setErr] = React.useState<string | null>(null);

  React.useEffect(() => {
    let mounted = true;
    (async () => {
      setLoading(true); setErr(null);
      try {
        const recs = await recommendProducts(intake);
        if (mounted) setGroups(recs);
      } catch (e: any) {
        if (mounted) setErr(e?.message ?? "Failed to load recommendations");
      } finally {
        if (mounted) setLoading(false);
      }
    })();
    return () => { mounted = false; };
  }, [intake.amount, intake.country, intake.category, intake.timeInBusinessMonths, intake.monthlyRevenue, intake.creditScore]);

  if (loading) return <div>Finding matches…</div>;
  if (err) return <div style={{ color: "crimson" }}>{err}</div>;
  if (!groups.length) return <div>No matching products for your criteria.</div>;

  return (
    <div style={{ display: "grid", gap: 16 }}>
      {groups.map(g => (
        <div key={g.category} style={{ border: "1px solid #eee", borderRadius: 8, padding: 12 }}>
          <div style={{ fontWeight: 700, marginBottom: 8 }}>{g.category}</div>
          <ul style={{ margin: 0, paddingLeft: 16 }}>
            {g.products.map(p => (
              <li key={p.id} style={{ marginBottom: 6 }}>
                <button onClick={() => onSelectProduct?.(p)} style={{ all: "unset", cursor: "pointer" }}>
                  {p.name} — {p.lender_name} · {p.country} · ${p.min_amount.toLocaleString()}–${p.max_amount.toLocaleString()}
                </button>
              </li>
            ))}
          </ul>
        </div>
      ))}
    </div>
  );
}

# ---------------------------------------------------------------------------
# FILE: client/src/components/DynamicDocumentRequirements.tsx
# (Teach Step 5 to fetch docs from Staff and fall back to 6-month statements.)

import React from "react";
import { listDocuments, type RequiredDoc, type RequiredDocsInput } from "@/lib/api";

type Props = {
  context: RequiredDocsInput; // must include category; country/amount optional
};

export default function DynamicDocumentRequirements({ context }: Props) {
  const [docs, setDocs] = React.useState<RequiredDoc[]>([]);
  const [loading, setLoading] = React.useState(false);
  const [err, setErr] = React.useState<string | null>(null);

  React.useEffect(() => {
    let mounted = true;
    (async () => {
      setLoading(true); setErr(null);
      try {
        const d = await listDocuments(context);
        if (mounted) setDocs(d);
      } catch (e: any) {
        if (mounted) setErr(e?.message ?? "Failed to load document list");
      } finally {
        if (mounted) setLoading(false);
      }
    })();
    return () => { mounted = false; };
  }, [context.category, context.country, context.amount, context.lenderId, context.timeInBusinessMonths, context.monthlyRevenue, context.creditScore]);

  if (loading) return <div>Loading required documents…</div>;
  if (err) return <div style={{ color: "crimson" }}>{err}</div>;

  const items = docs.map((d, i) => (typeof d === "string" ? { key: `doc_${i}`, label: d, required: true } : d));

  return (
    <div style={{ display: "grid", gap: 8 }}>
      {items.map(d => (
        <label key={d.key} style={{ display: "flex", gap: 8, alignItems: "center" }}>
          <input type="checkbox" defaultChecked={false} aria-label={d.label} />
          <span>{d.label}{d.required ? " *" : ""}{(d as any).months ? ` (${(d as any).months} months)` : ""}</span>
        </label>
      ))}
    </div>
  );
}

# ---------------------------------------------------------------------------
# ROUTING/WIRING HINT (only if needed)
# Step 2 page should pass { amount, country, ... } to <Step2RecommendationEngine />
# Step 5 page should pass { category, country, amount, lenderId? } to <DynamicDocumentRequirements />
