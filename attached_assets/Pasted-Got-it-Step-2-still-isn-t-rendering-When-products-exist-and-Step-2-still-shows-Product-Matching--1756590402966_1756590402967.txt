Got it — Step 2 still isn’t rendering. When products exist and Step 2 still shows “Product Matching Pending,” it’s almost always one (or more) of these:

1. the matcher is still reading from the wrong source (file/cache vs Staff API),
2. Step-1 intake isn’t actually reaching Step-2 (context/persistence gap), or
3. a schema/typing mismatch (e.g., `$ 500,000` string vs number) makes every filter fail → zero matches.

Below is a tight, do-it-now fix+diagnostic pack for the **Client app only**. It (a) proves where Step-2 is pulling data from, (b) proves whether Step-1 made it across, and (c) hardens the matcher so it can’t silently short-circuit.

---

# CLIENT — Step-2 not rendering: diagnose + hard-fix

## A) 60-second proof in the browser console (on `/apply/step-2`)

Paste these to see exactly what Step-2 sees:

```js
// 1) What Step-2 thinks it’s doing
window.__step2   // expect: { source:'staff', productsCount: ~44, isComplete: true, ... }

// 2) Did Step-1 make it across?
JSON.parse(sessionStorage.getItem('bf:intake') || localStorage.getItem('bf:intake') || 'null')

// 3) What product count is actually in memory (the array the matcher is using)?
window.__step2?.products?.length

// 4) Quick shape sanity: show first product keys and intake keys
Object.keys((window.__step2?.products || [])[0] || {})
Object.keys(JSON.parse(sessionStorage.getItem('bf:intake') || localStorage.getItem('bf:intake') || '{}'))

// 5) Are we *really* hitting Staff (and with a token)?
window.__step2?.source   // should be 'staff'
window.__step2?.lastFetch?.url
window.__step2?.lastFetch?.authorized   // true when Authorization header was set
```

**Interpretation**

* If `productsCount` is \~44 and `isComplete:true` but UI still shows “pending,” your *filters* are eliminating everything (see section C).
* If `productsCount` is small (e.g., 1 or 0), you’re not on Staff or you still have a fallback path active (see section B).
* If the intake object is `null` or missing critical fields, Step-1 persistence is the gap (see section B-2).

---

## B) Code patches (copy/paste). These make Step-2 deterministic.

### B-1) Force Staff API (no local cache in prod)

Create/ensure `client/src/api/products.ts`:

```ts
// client/src/api/products.ts
const BASE = import.meta.env.VITE_STAFF_API_URL!;
const TOK  = import.meta.env.VITE_CLIENT_APP_SHARED_TOKEN!;

export async function fetchProducts() {
  const res = await fetch(`${BASE}/v1/products`, {
    headers: { Authorization: `Bearer ${TOK}` },
  });
  (window as any).__step2 = { ...(window as any).__step2, lastFetch: { url: `${BASE}/v1/products`, authorized: !!TOK } };
  if (!res.ok) throw new Error(`products_fetch_failed_${res.status}`);
  const data = await res.json();
  (window as any).__step2 = { ...(window as any).__step2, source: 'staff', products: data, productsCount: data.length };
  return data;
}
```

**ENV (Deployment → Secrets)**
`NODE_ENV=production`
`VITE_STAFF_API_URL=https://staff.boreal.financial/api`
`VITE_CLIENT_APP_SHARED_TOKEN=<token with fp 294b3e442db5>`
`VITE_LOCAL_FALLBACK=false`

Remove any other flags that allow local JSON/cache in production.

---

### B-2) Make Step-1 intake reliably available to Step-2

In your Step-1 submit handler or form context (e.g., `client/src/context/FormDataContext.tsx`), persist the normalized intake:

```ts
// client/src/context/FormDataContext.tsx (snippet)
export type Intake = {
  country: 'US' | 'CA';
  amountRequested: number;     // normalized number
  industry?: string;
  yearsInBusiness?: number;
  revenue12m?: number;
  avgMonthlyRevenue?: number;
  purpose?: string;
  arBalance?: number;
  collateralValue?: number;
  // ...other fields your matcher expects
};

const toNumber = (v:any) => typeof v === 'number' ? v : Number(String(v ?? '').replace(/[^0-9.]/g,''));
export function normalizeIntake(raw:any): Intake {
  return {
    country: raw.country ?? 'US',
    amountRequested: toNumber(raw.fundingAmount ?? raw.requestedAmount ?? raw.amountRequested),
    industry: raw.industry ?? raw.naics,
    yearsInBusiness: toNumber(raw.yearsInBusiness ?? raw.businessAgeYears),
    revenue12m: toNumber(raw.revenueLast12Months ?? raw.annualRevenue),
    avgMonthlyRevenue: toNumber(raw.avgMonthlyRevenue ?? raw.monthlyRevenue),
    purpose: raw.purposeOfFunds ?? raw.purpose,
    arBalance: toNumber(raw.currentARBalance ?? raw.accountsReceivable),
    collateralValue: toNumber(raw.fixedAssetsValue ?? raw.collateralValue),
  };
}

function persistIntake(i: Intake) {
  sessionStorage.setItem('bf:intake', JSON.stringify(i));
  localStorage.setItem('bf:intake', JSON.stringify(i)); // belt-and-suspenders
  (window as any).__step2 = { ...(window as any).__step2, intake: i };
}

// Call this when Step-1 completes:
export function onStep1Submit(raw:any){
  const intake = normalizeIntake(raw);
  persistIntake(intake);
  // …navigate to Step-2
}
```

---

### B-3) Harden the Step-2 matcher so it can’t silently show “pending”

In `client/src/components/Step2RecommendationEngine.tsx`:

```tsx
import { useEffect, useMemo, useState } from 'react';
import { fetchProducts } from '@/api/products';

const requireIntake = (): any => {
  const s = sessionStorage.getItem('bf:intake') || localStorage.getItem('bf:intake');
  return s ? JSON.parse(s) : null;
};

const failSafeNumber = (n:any) => (typeof n === 'number' && !Number.isNaN(n)) ? n : 0;

export default function Step2RecommendationEngine(){
  const [loading, setLoading] = useState(true);
  const [products, setProducts] = useState<any[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(()=>{
    (async ()=>{
      try{
        const data = await fetchProducts();
        setProducts(Array.isArray(data) ? data : []);
      }catch(e:any){
        setError(e?.message || 'fetch_failed');
      }finally{
        setLoading(false);
      }
    })();
  }, []);

  const intake = requireIntake();

  // Early diagnostics into window
  (window as any).__step2 = { ...(window as any).__step2, loading, error, intake, productsCount: products.length };

  // Guard: if intake missing, show explicit message (not generic "pending")
  if (!intake) return <Pending msg="Missing Step 1 data. Please complete Step 1." />;

  // Normalize once
  const amount = failSafeNumber(intake.amountRequested);
  const country = intake.country;

  // Minimal eligibility to avoid “all filtered out” when strings slip through
  const eligible = useMemo(()=>{
    const list = products.filter(p=>{
      // accept broad country matches; treat undefined as global
      const okCountry = !p.country || p.country === country;
      // robust numeric comparisons
      const min = failSafeNumber(p.minAmount);
      const max = failSafeNumber(p.maxAmount);
      const okAmount = (!min || amount >= min) && (!max || amount <= max || max === 0);
      return okCountry && okAmount;
    });
    (window as any).__step2 = { ...(window as any).__step2, eligibleCount: list.length, lastFilter: { amount, country } };
    return list;
  }, [products, amount, country]);

  if (loading) return <Pending msg="Loading live products…" />;
  if (error)   return <Pending msg={`Products error: ${error}`} />;

  if (!eligible.length) {
    return <Pending msg="No eligible products after filters. Adjust amount or check intake fields." />;
  }

  return <ProductList products={eligible} intake={intake} />; // your real renderer
}

function Pending({msg}:{msg:string}) {
  return (
    <div className="rounded-md border p-6 text-center text-sm text-muted-foreground">
      {msg}
    </div>
  );
}
```

This does three important things:

* **Never** silently falls back to “pending” — it tells you exactly what’s missing (data, fetch, or filters).
* Accepts products with **missing max** or **missing country** rather than throwing them out.
* Emits rich runtime diagnostics into `window.__step2` so you can confirm input/filters/output live.

---

## C) What typically kills all matches (fixes included above)

* **Currency strings** (`"$ 500,000"`) compared against numbers → all products filtered out.
  (Handled by `toNumber` / `failSafeNumber`.)
* **Country mis-alignment** (e.g., `CA` vs `Canada`) → everything rejected.
  (Guard tolerates missing product country; ensure intake uses `US|CA`.)
* **Fallback still active** → you end up with 0/1 product from wrong source.
  (Forced `source:'staff'` and recorded `lastFetch`.)

---

## D) Quick post-deploy verification

1. On `/apply/step-1`, submit the form normally.
2. On `/apply/step-2`, open console:

   * `window.__step2` → should show `{ source:'staff', productsCount: ~44, eligibleCount: >0, intake:{…} }`
3. If `eligibleCount` is 0, look at `window.__step2.lastFilter` and the first product’s min/max to see which check is eliminating items.

---

If you want, I can also give you a small smoke test for the client build that fails the deployment when `productsCount < 40` or when `intake` is missing on Step-2 — that prevents this specific regression from ever shipping again.
