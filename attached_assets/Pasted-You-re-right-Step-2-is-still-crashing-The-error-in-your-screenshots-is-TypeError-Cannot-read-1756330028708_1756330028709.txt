You’re right—Step 2 is still crashing. The error in your screenshots is:

> **TypeError: Cannot read properties of undefined (reading 'amount')**

That means the Step 2 page is trying to read `intake.amount` while `intake` itself is `undefined`. Fix it by (1) normalizing what Step 2 receives, (2) persisting a fallback from Step 1, and (3) guarding any rendering that assumes values exist.

Below are **drop-in patches** for the **client app**. Copy them in as-is.

---

### 1) Add a tiny intake normalizer + storage helpers

`client/src/utils/normalizeIntake.ts`

```ts
export type Intake = {
  amount: number;
  country: 'CA' | 'US';
  monthlyRevenue: number;
  timeInBusinessMonths: number;
  industry: string;
};

const toNum = (v: unknown) => {
  if (typeof v === 'number') return v;
  if (typeof v === 'string') {
    const n = Number(v.replace(/[^\d.-]/g, ''));
    return Number.isFinite(n) ? n : NaN;
  }
  return NaN;
};
const toCountry = (v: unknown): Intake['country'] | null => {
  const s = String(v ?? '').trim().toUpperCase();
  if (['CA', 'CANADA'].includes(s)) return 'CA';
  if (['US', 'USA', 'UNITED STATES'].includes(s)) return 'US';
  return null;
};

/** Accepts {intake}, {formData}, or a raw object; returns a safe Intake or null. */
export function normalizeIntake(raw: any): Intake | null {
  const src = raw?.intake ?? raw?.formData ?? raw ?? {};
  const country = toCountry(src.country);
  if (!country) return null;

  const amount = toNum(src.amount ?? src.fundingAmount ?? src.loanAmount);
  const monthlyRevenue = toNum(src.monthlyRevenue ?? src.monthly_revenue);
  const timeInBusinessMonths = toNum(
    src.timeInBusinessMonths ?? src.time_in_business_months
  );
  const industry = String(src.industry ?? '').trim();

  return {
    country,
    amount: Number.isFinite(amount) ? amount : 0,
    monthlyRevenue: Number.isFinite(monthlyRevenue) ? monthlyRevenue : 0,
    timeInBusinessMonths: Number.isFinite(timeInBusinessMonths)
      ? timeInBusinessMonths
      : 0,
    industry,
  };
}

const KEY = 'bf:intake';
export const saveIntake = (obj: unknown) => {
  try { sessionStorage.setItem(KEY, JSON.stringify(obj)); } catch {}
};
export const loadIntake = () => {
  try { const s = sessionStorage.getItem(KEY); return s ? JSON.parse(s) : null; }
  catch { return null; }
};
```

---

### 2) Save a canonical copy at the end of **Step 1**

Where you handle the **Continue**/submit on Step 1 (builds the object and navigates), add:

```ts
import { saveIntake } from '@/utils/normalizeIntake';

// after you build `intake` (canonical keys: amount, country, monthlyRevenue, timeInBusinessMonths, industry)
saveIntake(intake);
navigate('/apply/step-2', { state: { intake } }); // use 'intake' key
```

*(If your path is `/step-2`, keep it—just pass `{ state:{ intake } }`.)*

---

### 3) Make **Step 2** resilient (no reads from undefined)

`client/src/pages/Step2RecommendationEngine.tsx` (or your Step 2 page)

```tsx
import * as React from 'react';
import { useLocation } from 'react-router-dom';
import { normalizeIntake, loadIntake, Intake } from '@/utils/normalizeIntake';

function PendingCard() {
  return (
    <div className="max-w-xl mx-auto p-6 rounded-xl border">
      <h2 className="text-xl font-semibold mb-2">Product Matching Pending</h2>
      <p className="text-sm text-gray-600">
        We couldn’t read your details from Step 1. Please go back and complete the form.
      </p>
      <a className="btn mt-4" href="/apply/step-1">Back to Step 1</a>
    </div>
  );
}

export default function Step2RecommendationEngine() {
  const state = (useLocation() as any)?.state ?? null;

  // Accept { state: { intake } } or { state: { formData } } or sessionStorage fallback
  const intake: Intake | null =
    normalizeIntake(state) ?? normalizeIntake(loadIntake());

  if (!intake) return <PendingCard />;

  // Render safely (avoid direct destructuring from possibly undefined)
  const fmt = (n: number) => (Number.isFinite(n) ? n.toLocaleString() : '—');

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-2xl font-semibold mb-4">Finding your matches…</h1>
      <div className="text-sm text-gray-600 mb-4">
        Amount: {fmt(intake.amount)} • Country: {intake.country} •
        Revenue: {fmt(intake.monthlyRevenue)} • TIB: {fmt(intake.timeInBusinessMonths)} mo
      </div>
      {/* TODO: call your validate/match API using the safe `intake` */}
    </div>
  );
}
```

---

### 4) One more common offender from your logs

If you have `Step2ProductSelection.tsx` reading `state.formData.industry`, change to optional chaining:

```ts
const industry = state?.formData?.industry ?? '';
```

---

### Why this stops the crash

* The error *“reading 'amount'”* comes from reading `intake.amount` while `intake` is undefined (lost route state, different key, or empty Step 1).
* We now **normalize** inputs, **fallback** to session storage, and **guard-render** with a pending screen.
* We avoid calling methods on possibly-null values and avoid destructuring from undefined.

Try again: fill Step 1 → Continue → Step 2. If you still see errors, tell me the **exact file path** of your Step 2 component and I’ll tailor the imports/paths to your repo.
