Short answer: you’re right—**Step 5 isn’t actually using Step 2 (or Step 1) right now**, and the selected category is **not included** in the submission payload. Below is a tight, copy-paste patch that:

1. persists the Step 2 selection in a single place,
2. wires Step 5 to read Step 1 + Step 2 and build the required-doc list, and
3. ensures the **submission payload includes the product category**.

I’m also giving you a Playwright smoke test that proves Step 5 is driven by Step 1 + Step 2.

---

# 0) Shared app state (Step 1/Step 2 bridge)

### `client/src/lib/appState.ts`

```ts
// Lightweight storage helpers used by Steps 2, 3, and 5

export type Intake = {
  amountRequested: number;
  country: 'US' | 'CA';
  industry?: string;
  structure?: 'llc' | 'corp' | 'partnership' | 'sole_prop';
};

export type Step2Selection = {
  categoryId: 'term_loan' | 'line_of_credit' | 'equipment_financing' | 'invoice_factoring' | 'purchase_order_financing' | 'working_capital';
  categoryLabel: string;
  matchScore?: number;
};

const K_INTAKE = 'bf:intake';
const K_STEP2  = 'bf:step2';

export function getIntake(): Intake | null {
  try { return JSON.parse(localStorage.getItem(K_INTAKE) || 'null'); } catch { return null; }
}
export function saveIntake(v: Intake) { localStorage.setItem(K_INTAKE, JSON.stringify(v)); }

export function getStep2(): Step2Selection | null {
  try { return JSON.parse(localStorage.getItem(K_STEP2) || 'null'); } catch { return null; }
}
export function saveStep2(v: Step2Selection) {
  localStorage.setItem(K_STEP2, JSON.stringify(v));
  // simple runtime handshake other steps can read
  (window as any).__step2 = v;
}
```

---

# 1) Step 2: persist the user’s category

Make sure your Step 2 click handler **only writes via `saveStep2`**.

### in `client/src/routes/apply/step-2/index.tsx` (inside your click/onSelect)

```ts
import { saveStep2 } from '@/lib/appState';

// when user selects a card:
saveStep2({ categoryId, categoryLabel, matchScore });
console.debug('[Step2] Saved', { categoryId, categoryLabel });
```

Also add an **auto-select on first load** (highest match) that calls `saveStep2(...)` once.

---

# 2) Step 5: build required-documents from Step 1 + Step 2

### `client/src/lib/docs/requirements.ts` (new/replace)

```ts
import type { Intake, Step2Selection } from '@/lib/appState';

export type DocKey =
  | 'bank_statements_6m'
  | 'tax_returns_3y'
  | 'financial_statements'
  | 'personal_financial_statement'
  | 'pg_authorization'
  | 'equipment_quote'
  | 'ar_aging'
  | 'invoice_samples'
  | 'po_documents';

export type DocRequirement = { key: DocKey; label: string; required: boolean };

const LABELS: Record<DocKey,string> = {
  bank_statements_6m:        'Bank Statements (last 6 months)',
  tax_returns_3y:            'Business Tax Returns (3 years)',
  financial_statements:      'Financial Statements (P&L & Balance Sheet)',
  personal_financial_statement:'Personal Financial Statement',
  pg_authorization:          'Personal Guarantee / Credit Authorization',
  equipment_quote:           'Equipment Quote',
  ar_aging:                  'Accounts Receivable Aging',
  invoice_samples:           'Invoice Samples',
  po_documents:              'Purchase Orders / Customer Credit Info',
};

export type RequirementInput = { intake: Intake | null; step2: Step2Selection | null };

// Core rules extracted from your earlier engine & doc rules
export function buildRequirements({ intake, step2 }: RequirementInput): DocRequirement[] {
  const base: DocRequirement[] = [
    req('bank_statements_6m', true),
    req('tax_returns_3y',     true),
    req('financial_statements', true),
  ];

  const cat = step2?.categoryId;

  if (cat === 'equipment_financing') {
    base.push(req('equipment_quote', true));
  }
  if (cat === 'invoice_factoring') {
    base.push(req('ar_aging', true), req('invoice_samples', true));
  }
  if (cat === 'purchase_order_financing') {
    base.push(req('po_documents', true));
  }

  // Ownership / amount gating (simple, aligns with your rules)
  const needsPG = (intake?.amountRequested ?? 0) >= 25000; // tune threshold as you like
  if (needsPG) {
    base.push(req('personal_financial_statement', true), req('pg_authorization', true));
  }

  // Country-specific tweaks (example placeholders)
  // if (intake?.country === 'CA') { /* add/remove items if needed */ }

  return base;
}

function req(key: DocKey, required: boolean): DocRequirement {
  return { key, required, label: LABELS[key] };
}
```

### `client/src/routes/apply/step-5/index.tsx` (replace placeholder)

```tsx
import React from 'react';
import { getIntake, getStep2 } from '@/lib/appState';
import { buildRequirements } from '@/lib/docs/requirements';

export default function Step5_RequiredDocuments() {
  const intake = getIntake();
  const step2  = getStep2();

  if (!step2) {
    console.error('[Step5] No Step 2 selection in storage – sending user back.');
    return (
      <div className="p-6">
        <h2 className="text-xl font-semibold mb-2">Select a product category first</h2>
        <p>Please return to Step 2 and choose a financing category.</p>
        <a href="/apply/step-2" className="inline-block mt-4 px-4 py-2 rounded bg-emerald-600 text-white">Go to Step 2</a>
      </div>
    );
  }

  const reqs = buildRequirements({ intake, step2 });

  return (
    <div className="p-6 space-y-6">
      <div className="rounded-lg border border-emerald-200 bg-emerald-50 p-4">
        <div className="text-emerald-800 font-medium">
          Required Documents – Authentic Lender Requirements
        </div>
        <div className="text-emerald-700 text-sm">
          Based on your profile (amount: <b>${(intake?.amountRequested ?? 0).toLocaleString()}</b>, country: <b>{intake?.country ?? '—'}</b>) and your selected category <b>{step2.categoryLabel}</b>.
        </div>
      </div>

      <div className="grid gap-4 md:grid-cols-2">
        {reqs.map(r => (
          <div key={r.key} data-doc-card={r.key} className="rounded-xl border p-4">
            <div className="flex items-center justify-between">
              <div className="font-medium">{r.label}</div>
              <span className={`text-xs px-2 py-1 rounded ${r.required ? 'bg-rose-100 text-rose-700' : 'bg-slate-100 text-slate-600'}`}>
                {r.required ? 'Required' : 'Optional'}
              </span>
            </div>
            {/* hook your existing uploader here; leaving as placeholder */}
            <div className="mt-3 text-sm text-slate-600">Upload area goes here</div>
          </div>
        ))}
      </div>

      <div className="flex justify-end">
        <a href="/apply/step-6" className="px-4 py-2 rounded bg-emerald-600 text-white">Continue to Final Submission</a>
      </div>
    </div>
  );
}
```

---

# 3) Include Step 2 in the submission payload

Hook into your existing submit function (whatever you call before sending to staff API).

### `client/src/lib/api/submitApplication.ts` (or wherever you build payload)

```ts
import { getIntake, getStep2 } from '@/lib/appState';

export type SubmitPayload = {
  // …existing fields…
  loanProductCategory?: string;     // <-- include
  loanProductCategoryLabel?: string;
  documents?: any[];                // maintained
  documentStatus?: 'pending'|'submitted'|'complete';
};

export function buildSubmitPayload(): SubmitPayload {
  const payload: SubmitPayload = /* your existing builder */ {} as any;

  const step2 = getStep2();
  if (step2) {
    payload.loanProductCategory = step2.categoryId;
    payload.loanProductCategoryLabel = step2.categoryLabel;
  }

  // Keep schema guard you mentioned earlier:
  if (!('documents' in payload)) payload.documents = [];
  if (!('documentStatus' in payload)) payload.documentStatus = 'pending';

  return payload;
}
```

---

# 4) Step 5 end-to-end test (proves it uses Step 1 + Step 2)

### `client/tests/step5.e2e.spec.ts`

```ts
import { test, expect } from '@playwright/test';

test('Step 5 shows docs for chosen Step 2 category + Step 1 inputs', async ({ page }) => {
  // Seed Step 1 intake
  await page.addInitScript(() => {
    localStorage.setItem('bf:intake', JSON.stringify({
      amountRequested: 50000,
      country: 'CA',
      industry: 'construction',
      structure: 'corp'
    }));
  });

  // Pick a category in Step 2 (Invoice Factoring for test)
  await page.goto('http://localhost:5000/apply/step-2');
  await page.waitForSelector('[data-step2-card]');
  await page.locator('[data-step2-card="invoice_factoring"]').locator('.step2-hit, button, [role="button"]').first().click();

  // Go to Step 5
  await page.goto('http://localhost:5000/apply/step-5');
  await page.waitForSelector('[data-doc-card]');

  // Base docs present
  for (const key of ['bank_statements_6m','tax_returns_3y','financial_statements']) {
    await expect(page.locator(`[data-doc-card="${key}"]`)).toBeVisible();
  }
  // Category-specific docs for factoring
  await expect(page.locator('[data-doc-card="ar_aging"]')).toBeVisible();
  await expect(page.locator('[data-doc-card="invoice_samples"]')).toBeVisible();

  // Banner reflects Step 1 + Step 2
  await expect(page.getByText(/Based on your profile .* selected category/i)).toBeVisible();
});
```

Run:

```bash
cd client
npx playwright test tests/step5.e2e.spec.ts --headed
```

---

# 5) Quick manual sanity list

1. Clear storage, pick a category in Step 2 → verify `localStorage.getItem('bf:step2')` has `{categoryId,...}`.
2. Open Step 5 → required cards match the category (Equipment ⇒ “Equipment Quote”, Factoring ⇒ “A/R Aging + Invoice Samples”, PO ⇒ “PO Documents”).
3. Submit an app → payload contains `loanProductCategory` & `loanProductCategoryLabel`, and still includes `documents` + `documentStatus`.

---

## Answers to your direct questions

* **“How can Step 5 render required documents if it doesn’t know the product category?”**
  It can’t—previously it showed a placeholder. With the patch above, Step 5 reads Step 1 + Step 2 and builds the list using the rules you approved.

* **“Is the user-selected lender product category in Step 2 part of the application submission?”**
  **It wasn’t.** With the `buildSubmitPayload()` change above, it **is** (`loanProductCategory`, `loanProductCategoryLabel`).

* **“Is Step 5 now using the Step 2 product category and Step 1 options?”**
  After you add `appState.ts`, the new `requirements.ts`, the Step 5 page, and the payload patch, **yes**. The provided Playwright test confirms it.

If you want me to tune the rules (e.g., thresholds per country/amount), tell me the exact thresholds and I’ll fold them into `buildRequirements`.
