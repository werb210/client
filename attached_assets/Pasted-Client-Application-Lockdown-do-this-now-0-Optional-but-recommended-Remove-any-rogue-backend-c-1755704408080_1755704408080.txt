Client Application — Lockdown (do this now)
0) (Optional but recommended) Remove any rogue backend code from the Client repo
# Create a safety branch
git checkout -b harden/client-lockdown

# If a server folder exists in the CLIENT repo, remove it (client is frontend-only)
test -d server && git rm -r server || true

# If any rogue files were added previously:
git rm -f server/routes/applications.ts 2>/dev/null || true
git rm -f shared/lenderSchema.ts 2>/dev/null || true  # keep only the legit client schemas you recognize

git commit -m "Remove accidental backend files from Client repo (frontend-only)"

1) CODEOWNERS: block edits to shared schema & config without your approval
# Create/overwrite CODEOWNERS
cat > CODEOWNERS << 'EOF'
# Require approval on sensitive areas
shared/*        @werb210
src/lib/api.ts  @werb210
src/config.ts   @werb210
EOF

git add CODEOWNERS
git commit -m "Add CODEOWNERS protection for critical client paths"


In GitHub, protect main: require PRs + at least 1 code owner review.

2) Agent Policy: default READ-ONLY unless you explicitly grant write
mkdir -p .policy
cat > .policy/agent.md << 'EOF'
DEFAULT: READ-ONLY.
WRITE allowed ONLY when the user message contains: `WRITE: I authorize file edits`.
ABSOLUTE PROHIBITIONS in CLIENT repo:
- Do NOT add or modify server routes or DB code.
- Do NOT replace Staff API calls with local implementations.
- Do NOT change shared schemas without code-owner approval.
EOF

git add .policy/agent.md
git commit -m "Add explicit agent policy (read-only by default)"

3) Runtime API guard: hard-fail if the API base isn’t your Staff domain
mkdir -p src/lib
cat > src/lib/api.ts << 'EOF'
export const API_BASE_URL = (import.meta.env.VITE_STAFF_API_BASE ?? "").trim();

// Strict runtime guard: only allow the official Staff API host over HTTPS
const allowedHost = "staff.boreal.financial";
try {
  const u = new URL(API_BASE_URL);
  if (u.protocol !== "https:" || u.hostname !== allowedHost) {
    throw new Error(`Invalid API host: ${u.hostname}. Expected ${allowedHost} over HTTPS.`);
  }
} catch (e) {
  throw new Error(
    `VITE_STAFF_API_BASE is invalid or missing. Set it to 'https://staff.boreal.financial/api'. Original error: ${String(e)}`
  );
}
Object.freeze((globalThis as any).API_BASE_URL);

export async function apiFetch(input: string, init?: RequestInit) {
  const url = input.startsWith("/") ? `${API_BASE_URL}${input}` : input;
  return fetch(url, {
    ...init,
    headers: {
      "Content-Type": "application/json",
      ...(init?.headers || {}),
    },
    credentials: "include",
  });
}
EOF

# Example .env (local) – do NOT commit secrets; just commit .env.example
cat > .env.example << 'EOF'
VITE_STAFF_API_BASE=https://staff.boreal.financial/api
EOF

git add src/lib/api.ts .env.example
git commit -m "Enforce runtime Staff API host guard in client"

4) ESLint rule to forbid any “local” URL or bare /api usage bypassing the guard
# If you use .eslintrc.cjs:
cat > .eslintrc.cjs << 'EOF'
/* eslint-env node */
module.exports = {
  root: true,
  extends: ["eslint:recommended", "plugin:@typescript-eslint/recommended"],
  parser: "@typescript-eslint/parser",
  plugins: ["@typescript-eslint"],
  rules: {
    // Disallow direct fetch to anything but our api.ts wrapper
    "no-restricted-imports": ["error", {
      "paths": [{
        "name": "node-fetch",
        "message": "Use src/lib/api.ts apiFetch instead."
      }],
      "patterns": []
    }],
    "no-restricted-syntax": [
      "error",
      {
        "selector": "CallExpression[callee.name='fetch']",
        "message": "Use apiFetch from src/lib/api.ts so Staff host checks are enforced."
      }
    ]
  },
  ignorePatterns: ["dist/", "node_modules/"]
};
EOF

git add .eslintrc.cjs
git commit -m "Lint rule: force apiFetch wrapper (no direct fetch)"


If code tries to call fetch("/api/...") or fetch("http://localhost:..."), ESLint will fail the PR.

5) Husky pre-commit hook: block edits to protected paths unless you add an explicit override token
# Add dev deps and husky
npm pkg set scripts.prepare="husky install"
npm i -D husky lint-staged
npx husky install

# Pre-commit checker script
mkdir -p scripts
cat > scripts/enforce-client-readonly.mjs << 'EOF'
import { execSync } from "node:child_process";

const protectedPaths = [
  "server/",
  "shared/schema.ts",
  "src/lib/api.ts",
  "src/config.ts"
];

// Allow override only if commit message includes this token:
const OVERRIDE_TOKEN = "WRITE: I authorize file edits";

function getStagedFiles() {
  const out = execSync('git diff --cached --name-only', { encoding: 'utf8' });
  return out.split('\n').filter(Boolean);
}

function getLastCommitMsg() {
  try {
    return execSync('git log -1 --pretty=%B', { encoding: 'utf8' }).trim();
  } catch {
    return "";
  }
}

const files = getStagedFiles();
const msg = getLastCommitMsg();

const hit = files.some(f => protectedPaths.some(p => f.startsWith(p)));
if (hit && !msg.includes(OVERRIDE_TOKEN)) {
  console.error(`\n⛔ Protected paths changed: ${files.filter(f => protectedPaths.some(p => f.startsWith(p))).join(', ')}`);
  console.error(`Add the exact token to your commit message to proceed:\n\n   ${OVERRIDE_TOKEN}\n`);
  process.exit(1);
}
EOF
chmod +x scripts/enforce-client-readonly.mjs

# Hook
npx husky add .husky/pre-commit 'node scripts/enforce-client-readonly.mjs && npx lint-staged'

# lint-staged config
cat > .lintstagedrc.json << 'EOF'
{
  "*.{ts,tsx,js,jsx}": "eslint --max-warnings=0"
}
EOF

git add scripts/enforce-client-readonly.mjs .husky/pre-commit .lintstagedrc.json
git commit -m "Add pre-commit guard + lint-staged (protect client from rogue edits)"

6) GitHub Action: block PRs that touch banned paths unless you add a specific label
mkdir -p .github/workflows
cat > .github/workflows/pr-guard.yml << 'EOF'
name: Client PR Guard
on:
  pull_request:
    types: [opened, synchronize, reopened, labeled, unlabeled]
jobs:
  guard:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Check changed files
        id: diff
        run: |
          git fetch origin ${{ github.base_ref }} --depth=1
          git diff --name-only origin/${{ github.base_ref }}... > changed.txt
          cat changed.txt

      - name: Fail if protected paths modified without label
        run: |
          PROTECTED_REGEX='^(server/|shared/schema.ts|src/lib/api.ts|src/config.ts)'
          if grep -E "$PROTECTED_REGEX" changed.txt; then
            echo "Protected files changed."
            # Require a label to proceed
            if ! echo "${{ toJson(github.event.pull_request.labels) }}" | grep -q '"client-override-allowed"'; then
              echo "Missing label client-override-allowed. Failing."
              exit 1
            fi
          fi
EOF

git add .github/workflows/pr-guard.yml
git commit -m "Add GitHub Action to guard protected client paths"

7) Final: push branch and open a PR to main
git push -u origin harden/client-lockdown
echo "✅ Push complete. Open PR and enable 'Require PR + review' on main."