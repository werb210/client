Got it. I’ve translated your **Step 2** and **Step 5** rules into **drop-in client code** (TypeScript) that you can paste as-is. It includes:

* A strict **recommendation engine** (Step 2) with your filters, category mapping, and scoring.
* A **document requirement aggregator** (Step 5) that unions docs across eligible products and enforces your business-structure, ownership, identity and category fallbacks.
* Tiny adapters to normalize Staff `/v1/products` to the fields your rules use.
* Minimal helpers to **validate completeness** before advancing to Step 6.

> Paste the files exactly as shown. If file paths differ in your repo, keep the exports identical.

---

# 1) Product normalization (shared for Steps 2 & 5)

**`src/lib/products/normalize.ts`**

```ts
export type ProductRaw = any;

export type Category =
  | 'working_capital' | 'equipment_financing' | 'invoice_factoring'
  | 'line_of_credit'  | 'term_loan'           | 'purchase_order_financing'
  | 'asset_based_lending' | 'sba_loan';

export type Product = {
  id: string;
  lenderId?: string;
  name?: string;
  country: 'US' | 'CA' | string;
  minAmount: number;
  maxAmount: number;
  category: Category;
  active: boolean;
};

export function normalizeProduct(p: ProductRaw): Product {
  // Map snake_case from Staff → camelCase your rules expect
  const country = p.country ?? p.country_offered ?? p.geo ?? 'US';
  const minAmount = p.minAmount ?? p.amount_min ?? p.min_amount ?? 0;
  const maxAmount = p.maxAmount ?? p.amount_max ?? p.max_amount ?? 0;
  const category: Category = (p.category ?? p.type ?? 'working_capital') as Category;
  return {
    id: String(p.id),
    lenderId: p.lender_id ?? p.lenderId,
    name: p.name,
    country,
    minAmount: Number(minAmount),
    maxAmount: Number(maxAmount),
    category,
    active: Boolean(p.active ?? true),
  };
}

export function normalizeProducts(list: ProductRaw[]): Product[] {
  return (Array.isArray(list) ? list : []).map(normalizeProduct).filter(p => p.active);
}
```

---

# 2) Step 2 – Recommendation engine (strict filters + scoring)

**`src/lib/reco/engine.ts`**

```ts
import { Product, Category } from '../products/normalize';

export type UserFilters = {
  country: 'US'|'CA'|string;
  fundingAmount: number;
  productPreference: 'capital'|'equipment'|'both';
  categoryEnum?: Category;            // optional strict enum when known
  estRevenue?: number;                // annual revenue if applicable
  hasAR?: boolean;                    // accounts receivable present
  purpose?: 'inventory'|'equipment'|'general'|string;
};

const PRODUCT_CATEGORY_MAP: Record<'capital'|'equipment'|'both', Category[]> = {
  capital: ['term_loan','working_capital','line_of_credit'],
  equipment: ['equipment_financing'],
  both: ['term_loan','working_capital','line_of_credit','equipment_financing'],
};

function hardEligible(p: Product, f: UserFilters): boolean {
  // Geography
  if (p.country !== f.country) return false;

  // Amount range
  if (!(f.fundingAmount >= p.minAmount && f.fundingAmount <= p.maxAmount)) return false;

  // Product type / category mapping
  const allowed = PRODUCT_CATEGORY_MAP[f.productPreference] ?? [];
  if (f.categoryEnum) {
    if (p.category !== f.categoryEnum) return false;           // strict category enum when provided
  } else {
    if (!allowed.includes(p.category)) return false;
  }

  return true;
}

function categoryScore(p: Product, f: UserFilters): number {
  // 0–30 based on relevance inside the allowed set
  const pref = PRODUCT_CATEGORY_MAP[f.productPreference] ?? [];
  if (f.categoryEnum) return p.category === f.categoryEnum ? 30 : 0;
  if (!pref.includes(p.category)) return 0;
  if (p.category === 'term_loan' || p.category === 'working_capital') return 28;
  if (p.category === 'line_of_credit') return 26;
  if (p.category === 'equipment_financing') return 24;
  return 20;
}

function amountOptimizationScore(p: Product, f: UserFilters): number {
  // 5–20 based on multiples of minAmount
  const ratio = f.fundingAmount / Math.max(1, p.minAmount);
  if (ratio >= 1 && ratio <= 2) return 20;       // optimal
  if (ratio > 2 && ratio <= 5) return 15;        // good
  return 10;                                     // acceptable (>5x)
}

function revenueScore(_p: Product, f: UserFilters): number {
  // 0–10: +10 if no revenue requirement (we don’t model it) or estRevenue meets requirement
  // Since product revenue requirement is not modeled, grant +10 when estRevenue provided or unknown requirement.
  return (typeof f.estRevenue === 'number' ? 10 : 10);
}

function specialInclusionScore(p: Product, f: UserFilters): number {
  // 0–15: special combos
  if (p.category === 'invoice_factoring' && f.hasAR) return 15;
  if (p.category === 'purchase_order_financing' && f.purpose === 'inventory') return 15;
  return 0;
}

export type ScoredProduct = Product & { score: number; level: 'Excellent'|'Good'|'Fair' };

function toLevel(score: number): 'Excellent'|'Good'|'Fair' {
  if (score >= 70) return 'Excellent';
  if (score >= 50) return 'Good';
  return 'Fair';
}

export function recommend(products: Product[], filters: UserFilters, topK = 5): ScoredProduct[] {
  const eligible = products.filter(p => hardEligible(p, filters));
  const scored = eligible.map(p => {
    const score =
      categoryScore(p, filters) +
      amountOptimizationScore(p, filters) +
      revenueScore(p, filters) +
      specialInclusionScore(p, filters);
    return { ...p, score, level: toLevel(score) };
  });
  return scored.sort((a, b) => b.score - a.score).slice(0, topK);
}
```

---

# 3) Step 5 – Union-based required documents

**`src/lib/docs/requirements.ts`**

```ts
import { Product, Category } from '../products/normalize';

export type Owner = { name: string; ownershipPct: number; hasSSN?: boolean };
export type BusinessStructure = 'llc'|'corporation'|'partnership'|'sole_prop';

export type Step5Input = {
  country: 'US'|'CA'|string;
  fundingAmount: number;
  productPreference: 'capital'|'equipment'|'both';
  structure: BusinessStructure;
  owners: Owner[];
  hasSSN?: boolean;             // for sole prop or general identity rule
  hasAR?: boolean;              // AR present
  purpose?: 'inventory'|'equipment'|'general'|string;
};

export type DocKey =
  | 'bank_statements_6m' | 'tax_returns_3y' | 'financials_pl_bs' | 'business_license' | 'articles_of_incorporation'
  | 'operating_agreement' | 'articles_of_organization' | 'member_resolution'
  | 'corporate_bylaws' | 'board_resolution' | 'stock_certificates'
  | 'partnership_agreement' | 'partnership_registration'
  | 'dba_filing' | 'personal_financial_statement'
  | 'personal_guarantee' | 'credit_report_auth'
  | 'driver_license' | 'ssn_card_copy' | 'government_id' | 'proof_of_identity'
  | 'cash_flow_statement'
  | 'equipment_quote'
  | 'ar_aging' | 'invoice_samples'
  | 'purchase_orders' | 'customer_credit_info'
  | 'asset_valuation'
  | 'void_cheque'; // optional common add-on

export type RequiredDoc = { key: DocKey; name: string; required: boolean; category?: string };

const CORE_ALWAYS: RequiredDoc[] = [
  { key:'bank_statements_6m', name:'Bank Statements (6 months)', required:true },
  { key:'tax_returns_3y',     name:'Business Tax Returns (3 years)', required:true },
  { key:'financials_pl_bs',   name:'Financial Statements (P&L and Balance Sheet)', required:true },
  { key:'business_license',   name:'Business License', required:true },
  { key:'articles_of_incorporation', name:'Articles of Incorporation', required:true },
];

// Category fallbacks
const CATEGORY_DOCS: Record<Category, RequiredDoc[]> = {
  working_capital: [
    { key:'bank_statements_6m', name:'Bank Statements (6 months)', required:true },
    { key:'financials_pl_bs',   name:'Financial Statements', required:true },
    { key:'tax_returns_3y',     name:'Business Tax Returns (3 years)', required:true },
  ],
  term_loan: [
    { key:'bank_statements_6m', name:'Bank Statements (6 months)', required:true },
    { key:'tax_returns_3y',     name:'Business Tax Returns (3 years)', required:true },
    { key:'financials_pl_bs',   name:'Financial Statements', required:true },
    { key:'cash_flow_statement',name:'Cash Flow Statement', required:true },
  ],
  line_of_credit: [
    { key:'bank_statements_6m', name:'Bank Statements (6 months)', required:true },
    { key:'financials_pl_bs',   name:'Financial Statements', required:true },
    { key:'tax_returns_3y',     name:'Business Tax Returns (3 years)', required:true },
  ],
  equipment_financing: [
    { key:'equipment_quote',    name:'Equipment Quote', required:true },
    { key:'bank_statements_6m', name:'Bank Statements (6 months)', required:true },
    { key:'tax_returns_3y',     name:'Business Tax Returns (3 years)', required:true },
  ],
  invoice_factoring: [
    { key:'ar_aging',           name:'Accounts Receivable Aging', required:true },
    { key:'bank_statements_6m', name:'Bank Statements (6 months)', required:true },
    { key:'invoice_samples',    name:'Invoice Samples', required:true },
  ],
  purchase_order_financing: [
    { key:'purchase_orders',    name:'Purchase Orders', required:true },
    { key:'bank_statements_6m', name:'Bank Statements (6 months)', required:true },
    { key:'customer_credit_info', name:'Customer Credit Information', required:true },
  ],
  asset_based_lending: [
    { key:'asset_valuation',    name:'Asset Valuation', required:true },
    { key:'bank_statements_6m', name:'Bank Statements (6 months)', required:true },
    { key:'financials_pl_bs',   name:'Financial Statements', required:true },
  ],
  sba_loan: [
    // Can layer SBA specifics later; core docs already cover baseline
    { key:'bank_statements_6m', name:'Bank Statements (6 months)', required:true },
    { key:'tax_returns_3y',     name:'Business Tax Returns (3 years)', required:true },
    { key:'financials_pl_bs',   name:'Financial Statements', required:true },
  ],
};

// Business structure docs
function structureDocs(structure: BusinessStructure): RequiredDoc[] {
  switch (structure) {
    case 'llc':
      return [
        { key:'operating_agreement', name:'Operating Agreement', required:true },
        { key:'articles_of_organization', name:'Articles of Organization', required:true },
        { key:'member_resolution', name:'Member Resolution', required:true },
      ];
    case 'corporation':
      return [
        { key:'corporate_bylaws', name:'Corporate Bylaws', required:true },
        { key:'articles_of_incorporation', name:'Articles of Incorporation', required:true },
        { key:'board_resolution', name:'Board Resolution', required:true },
        { key:'stock_certificates', name:'Stock Certificates', required:false },
      ];
    case 'partnership':
      return [
        { key:'partnership_agreement', name:'Partnership Agreement', required:true },
        { key:'partnership_registration', name:'Partnership Registration', required:true },
      ];
    case 'sole_prop':
      return [
        { key:'dba_filing', name:'DBA Filing', required:false },
        { key:'personal_financial_statement', name:'Personal Financial Statement', required:true },
      ];
    default:
      return [];
  }
}

// Ownership & identity docs
function ownershipDocs(owners: {ownershipPct:number}[]): RequiredDoc[] {
  const has50 = owners.some(o => (o.ownershipPct ?? 0) >= 50);
  return has50
    ? [
        { key:'personal_guarantee', name:'Personal Guarantee', required:true },
        { key:'personal_financial_statement', name:'Personal Financial Statement', required:true },
        { key:'credit_report_auth', name:'Personal Credit Report Authorization', required:true },
      ]
    : [];
}

function identityDocs(owners: Owner[], hasSSN?: boolean): RequiredDoc[] {
  // If the business/owners have SSN, require DL + SSN card; otherwise govt ID + proof
  const anySSN = hasSSN || owners.some(o => o.hasSSN);
  return anySSN
    ? [
        { key:'driver_license',  name:'Driver License', required:true },
        { key:'ssn_card_copy',   name:'Social Security Card Copy', required:true },
      ]
    : [
        { key:'government_id',   name:'Government ID', required:true },
        { key:'proof_of_identity', name:'Proof of Identity', required:true },
      ];
}

function dedupe(docs: RequiredDoc[]): RequiredDoc[] {
  const seen = new Map<string, RequiredDoc>();
  for (const d of docs) {
    const prev = seen.get(d.key);
    // If any source says "required", keep required=true
    seen.set(d.key, prev ? { ...prev, required: prev.required || d.required } : d);
  }
  return [...seen.values()];
}

export function eligibleProductsForDocs(products: Product[], input: { country:string; fundingAmount:number; productPreference:'capital'|'equipment'|'both' }): Product[] {
  const allowedMap = {
    capital: ['term_loan','working_capital','line_of_credit'],
    equipment: ['equipment_financing'],
    both: ['term_loan','working_capital','line_of_credit','equipment_financing'],
  } as const;
  const allowed = allowedMap[input.productPreference] as readonly string[];

  return products.filter(p =>
    p.country === input.country &&
    input.fundingAmount >= p.minAmount &&
    input.fundingAmount <= p.maxAmount &&
    allowed.includes(p.category)
  );
}

export function computeRequiredDocs(input: Step5Input, eligible: Product[]): RequiredDoc[] {
  const base: RequiredDoc[] = [...CORE_ALWAYS];

  // Union of category fallbacks across eligible products
  for (const p of eligible) {
    const add = CATEGORY_DOCS[p.category] ?? [];
    base.push(...add);
  }

  // Business structure, ownership, identity
  base.push(...structureDocs(input.structure));
  base.push(...ownershipDocs(input.owners));
  base.push(...identityDocs(input.owners, input.hasSSN));

  // Special inclusions from Step 2 rules (mirror business intent)
  if (eligible.some(p => p.category === 'invoice_factoring') && input.hasAR) {
    base.push({ key:'ar_aging', name:'Accounts Receivable Aging', required:true });
  }
  if (eligible.some(p => p.category === 'purchase_order_financing') && input.purpose === 'inventory') {
    base.push({ key:'purchase_orders', name:'Purchase Orders', required:true });
    base.push({ key:'customer_credit_info', name:'Customer Credit Information', required:false });
  }

  return dedupe(base);
}
```

**Completeness check before Step 6**

**`src/lib/docs/validate.ts`**

```ts
import type { RequiredDoc } from './requirements';

export type FileState = 'completed'|'uploading'|'error'|'queued'|'missing'|'verified'|'uploaded'|'rejected';

export function allRequiredDocsComplete(requiredDocs: RequiredDoc[], statesByKey: Record<string, FileState>): {
  ok: boolean; missing: string[]; invalid: string[];
} {
  const missing: string[] = [];
  const invalid: string[] = [];
  for (const d of requiredDocs) {
    if (!d.required) continue;
    const s = (statesByKey[d.key] ?? 'missing') as FileState;
    if (s === 'missing' || s === 'queued' || s === 'uploading' || s === 'error' || s === 'rejected') {
      // Rejected is not acceptable per your rule: must be “completed” (uploaded/verified)
      missing.push(d.key);
    }
    // Accept “completed”, “uploaded”, or “verified”
  }
  return { ok: missing.length === 0 && invalid.length === 0, missing, invalid };
}
```

---

# 4) How to wire in your flow

* **Where you already load products:** call your network layer for `/v1/products`, then `normalizeProducts()`. Store them in your existing client DB (SQLite/Drizzle) or in memory.
* **Step 2:** build `filters` from user answers, call:

  ```ts
  import { recommend } from '@/lib/reco/engine';
  const ranked = recommend(products, filters, 5); // array with score + level
  ```
* **Step 5:** compute eligible set and required docs:

  ```ts
  import { eligibleProductsForDocs, computeRequiredDocs } from '@/lib/docs/requirements';
  const elig = eligibleProductsForDocs(products, { country, fundingAmount, productPreference });
  if (elig.length === 0) { /* fail: Required Products rule */ }
  const reqDocs = computeRequiredDocs(step5Input, elig);
  ```
* **Gate Step 6:**

  ```ts
  import { allRequiredDocsComplete } from '@/lib/docs/validate';
  const { ok, missing } = allRequiredDocsComplete(reqDocs, statesByKey);
  if (!ok) /* block and show missing */;
  ```

---

# 5) Quick smoke (optional)

```ts
// tests/reco-and-docs.unit.spec.ts (vitest)
import { describe, it, expect } from 'vitest';
import { normalizeProducts } from '@/lib/products/normalize';
import { recommend } from '@/lib/reco/engine';
import { eligibleProductsForDocs, computeRequiredDocs } from '@/lib/docs/requirements';
import { allRequiredDocsComplete } from '@/lib/docs/validate';

it('recommend + docs union follows rules', () => {
  const raw = [
    {id:'p1', country:'US', amount_min:10000, amount_max:250000, category:'term_loan', active:1},
    {id:'p2', country:'US', amount_min:5000,  amount_max:75000,  category:'equipment_financing', active:1},
  ];
  const products = normalizeProducts(raw);
  const filters = { country:'US', fundingAmount:50000, productPreference:'both', estRevenue:100000, hasAR:false, purpose:'general' };
  const ranked = recommend(products, filters);
  expect(ranked.length).toBeGreaterThan(0);

  const elig = eligibleProductsForDocs(products, { country:'US', fundingAmount:50000, productPreference:'both' });
  const reqDocs = computeRequiredDocs({
    country:'US', fundingAmount:50000, productPreference:'both',
    structure:'llc', owners:[{name:'A', ownershipPct:60, hasSSN:true}],
    hasSSN:true, hasAR:false, purpose:'general'
  }, elig);
  const { ok, missing } = allRequiredDocsComplete(reqDocs, { bank_statements_6m:'uploaded', tax_returns_3y:'uploaded', financials_pl_bs:'uploaded',
    business_license:'uploaded', articles_of_incorporation:'uploaded', operating_agreement:'uploaded', articles_of_organization:'uploaded',
    member_resolution:'uploaded', personal_guarantee:'uploaded', personal_financial_statement:'uploaded', credit_report_auth:'uploaded',
    driver_license:'uploaded', ssn_card_copy:'uploaded' });
  expect(ok).toBe(true);
  expect(missing.length).toBe(0);
});
```

---

## Notes / defaults I locked in

* **Strict filters**: geography, amount, category mapping exactly as you specified.
* **Scoring**: category (0–30), amount optimization (5–20), revenue (0–10 default +10), special (0–15).
* **Docs**: union of eligible product fallbacks + core + structure + ownership + identity (+ special category add-ons).
* **Completeness**: only **completed/uploaded/verified** passes; `rejected` does **not** pass.

If any of your real field names differ (e.g., product category lives at a different key), adjust just the mapping in `normalizeProduct()` — everything else will follow the rules as written.
