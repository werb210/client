// PURPOSE
// Fix the show-stopper by STOP using legacy field names and endpoint.
// Use the new /api/catalog/categories (preferred), with fallback to recommendations.

export async function getMatchingCategories(amount: number, country: 'US'|'CA', opts?: { tenantId?: string }) {
  // 1) Try canonical categories endpoint
  try {
    const qs = new URLSearchParams({ amount: String(amount), country, ...(opts?.tenantId ? { tenantId: opts.tenantId } : {}) });
    const r = await fetch(`/api/catalog/categories?${qs.toString()}`, { credentials: 'include' });
    if (r.status === 412) {
      const j = await r.json().catch(()=>({}));
      throw Object.assign(new Error('ASK'), { type: 'ASK', asks: j.asks || [] });
    }
    if (r.ok) {
      const j = await r.json();
      return Array.isArray(j.categories) ? j.categories : [];
    }
  } catch { /* fall through to fallback */ }

  // 2) Fallback: use recommendations and derive categories (ensures forward-compat)
  const payload = {
    desired_amount: amount,
    time_in_business_months: 12,
    monthly_revenue: 20000,
    credit_score: 650,
    country,
    tenant_id: opts?.tenantId,
  };
  const r = await fetch('/api/recommendations', {
    method: 'POST', credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });
  if (r.status === 412) {
    const j = await r.json().catch(()=>({}));
    throw Object.assign(new Error('ASK'), { type: 'ASK', asks: j.asks || [] });
  }
  if (!r.ok) throw new Error(`/api/recommendations failed: ${r.status}`);

  const j = await r.json();
  const cats = new Set<string>();
  for (const p of (j.recommended ?? [])) {
    if (p.country?.toUpperCase() === country && typeof p.category === 'string') cats.add(p.category);
  }
  return Array.from(cats).sort();
}

// IMPORTANT: Stop calling the old endpoint like this:
//   /api/lender-products  + fields minimumLendingAmount/maximumLendingAmount/productCategory
// Use getMatchingCategories(...) instead.
