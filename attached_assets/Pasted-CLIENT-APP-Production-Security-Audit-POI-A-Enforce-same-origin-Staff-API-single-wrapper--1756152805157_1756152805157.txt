CLIENT APP — Production & Security Audit (POI)
A) Enforce same-origin Staff API (single wrapper)
// client/src/lib/api.ts
const BASE = ""; // same-origin

export async function uploadDocument(appId: string, file: File, documentType: string) {
  const fd = new FormData();
  fd.append("file", file);
  fd.append("document_type", documentType);
  const r = await fetch(`${BASE}/api/applications/${appId}/documents/upload`, {
    method: "POST", body: fd, credentials: "include",
  });
  if (!r.ok) throw new Error(`upload failed: ${r.status}`); return r.json();
}
export async function listDocuments(appId: string) {
  const path = import.meta.env.PROD
    ? `/api/applications/${appId}/documents`
    : `/api/public/applications/${appId}/documents`;
  const r = await fetch(path, { credentials: "include" });
  if (!r.ok) throw new Error(`list failed: ${r.status}`); return r.json();
}
export async function setDocumentStatus(docId: string, status: "accepted"|"rejected"|"pending") {
  const r = await fetch(`/api/documents/${docId}`, {
    method: "PATCH", headers: { "Content-Type": "application/json" },
    credentials: "include", body: JSON.stringify({ status }),
  });
  if (!r.ok) throw new Error(`status failed: ${r.status}`); return r.json();
}

B) Runtime fetch guard (dev only; already present — keep enabled)
// client/src/lib/fetch-guard.ts
const DEV = import.meta.env.DEV;
const ALLOW = [/^\/(api|staff|_int)\b/i, /^\/$/, /^\/[?#]/];
const original = window.fetch;
window.fetch = async (input: RequestInfo | URL, init?: RequestInit) => {
  if (DEV) {
    const url = typeof input === "string" ? input : (input as any).url;
    const isExternal = /^https?:\/\//i.test(url) && !/^https?:\/\/(localhost|127\.0\.0\.1)(:\d{2,5})?\//i.test(url);
    if (isExternal) throw new Error(`External fetch blocked in dev: ${url}`);
    if (typeof input === "string" && !ALLOW.some(rx => rx.test(input)))
      throw new Error(`Non-API path blocked in dev: ${input}`);
  }
  return original(input as any, init);
};
// client/src/main.tsx
import "./lib/fetch-guard";

C) Nuke direct S3/external URLs (guardrail grep)
# From repo root
echo "== S3 refs (fail if any real usage) =="
rg -n "s3|amazonaws|minio|presign|pre-?sign|SignedURL|putObject|getSignedUrl" client/src \
  | grep -v "s3Upload.ts" | grep -v "block-s3.d.ts" && echo "❌ FIX REQUIRED" || echo "✅ OK"

echo; echo "== External URLs (must be none in prod code) =="
rg -n --pcre2 "https?://(?!localhost|127\.0\.0\.1)" client/src \
  | rg -v "tests?|example\.com" && echo "❌ FIX REQUIRED" || echo "✅ OK"

D) Replace any stragglers with same-origin (quick sed helpers)
# Replace VITE_STAFF_API_URL fallbacks with relative paths
rg -n "VITE_STAFF_API_URL|https://staff\." client/src
# Then fix occurrences (review before apply):
# sed -i 's#\${import.meta.env.VITE_STAFF_API_URL[^}]*}#/api#g' <files>
# or manually replace with `/api/...` paths

E) Build-time hardening
// client/vite.config.ts
import { defineConfig } from 'vite';
export default defineConfig({
  build: { sourcemap: false }, // no prod source maps
  server: { strictPort: true },
});

// Add CSP/meta in your HTML template (served by staff app or CDN):
// <meta http-equiv="Content-Security-Policy"
//  content="default-src 'self'; img-src 'self' data: blob:; script-src 'self'; style-src 'self' 'unsafe-inline'; connect-src 'self'; frame-ancestors 'none'; base-uri 'self'; form-action 'self'">

F) Silence console noise in prod
// client/src/lib/quiet-console.ts
if (import.meta.env.PROD) {
  const noop = () => {};
  console.debug = noop; console.log = noop; console.info = noop;
}
import "./quiet-console"; // add in main.tsx AFTER fetch-guard

G) Manual UI checks (dev & prod)
1) Open staff UI → pick the Black Label app (server id known).
2) Upload small file → appears in the drawer list.
3) Change status to “accepted” → reflected in list.
4) View → dev: /api/dev-files/... ; prod: presigned https://...
5) Negative test (dev only, expect THROW):
   await fetch("https://staff.boreal.financial/api/health")