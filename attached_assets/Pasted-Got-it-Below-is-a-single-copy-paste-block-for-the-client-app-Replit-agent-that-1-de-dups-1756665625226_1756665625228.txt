Got it. Below is a **single, copy-paste block** for the **client app Replit agent** that (1) de-dups and fully removes the old Step 2 engine, (2) switches Step 2 to **category-based** cards, (3) wires Step 5 to **required-docs by selected category**, and (4) preserves the **submission schema + staff handoff**. It’s safe to run multiple times.

> What you’ll get
>
> * No duplicated engines; legacy `getRecommendedProducts` removed.
> * Step 2 shows the **six categories** (LoC, Term Loan, Invoice Factoring, Equipment Financing, PO Financing, Working Capital) with counts & match %.
> * Step 5 shows **required document cards** derived from the selected category (local-first mapping with API fallback).
> * Submission keeps `documents: []` and `documentStatus: 'pending'` and includes `selectedCategory`.
> * Local-first `/api/v1/products` with external fallback; resilient to refreshes.

---

```bash
# ============================================
# CLIENT APP: Step 2 categories + Step 5 docs
# (dedupe old engine, add category UI, keep schema)
# ============================================
set -euo pipefail
AUDIT_AT="$(date +%Y-%m-%d_%H-%M-%S)"
R="reports/client-categories-docs-$AUDIT_AT"
TRASH=".trash-client-$AUDIT_AT"
mkdir -p "$R" "$TRASH"

note(){ printf "%s\n" "$*" | tee -a "$R/summary.txt"; }
pass(){ note "✅ $*"; }
warn(){ note "⚠️ $*"; }
fail(){ note "❌ $*"; exit 1; }

note "== CLIENT PATCH @ $AUDIT_AT =="

# ---- 0) Paths (best-effort normalizations) -------------------------------
ROOT="client/src"
PAGES_DIR="${ROOT}/pages"
CMP_DIR="${ROOT}/components"
LIB_DIR="${ROOT}/lib"
API_DIR="${ROOT}/api"
ROUTES_STEP2="${PAGES_DIR}/Apply/Step2.tsx"
ROUTES_STEP5="${PAGES_DIR}/Apply/Step5.tsx"

mkdir -p "$PAGES_DIR/Apply" "$CMP_DIR/Step2" "$CMP_DIR/Step5" "$LIB_DIR/recommendations" "$LIB_DIR/docs" "$API_DIR"

# ---- 1) De-dupe: fully remove old recommendation engine ------------------
# Anything that exported getRecommendedProducts must go. We quarantine, not delete.
rg -n "getRecommendedProducts|recommendations/engine" client/src --hidden --glob '!**/*.map' || true
FOUND="$(rg -l "getRecommendedProducts|recommendations/engine" client/src --hidden --glob '!**/*.map' || true)"
if [ -n "${FOUND:-}" ]; then
  note "Quarantining legacy engine files:"
  while IFS= read -r f; do
    [ -f "$f" ] || continue
    mkdir -p "$TRASH/$(dirname "$f")"
    mv "$f" "$TRASH/$f"
    echo "  • $f" | tee -a "$R/summary.txt"
  done <<< "$FOUND"
else
  pass "No legacy engine references found."
fi

# ---- 2) API: local-first products fetcher with external fallback ----------
cat > "${API_DIR}/products.ts" <<'TS'
/**
 * Unified products fetcher (local-first, external fallback)
 */
export type Product = {
  id: string
  name: string
  lender_name?: string
  lenderName?: string
  category: string
  country?: string
  minAmount?: number
  maxAmount?: number
}

const LOCAL = '/api/v1/products'
const STAFF = (import.meta.env.VITE_STAFF_API_URL ?? 'https://staff.boreal.financial/api') + '/v1/products'

async function fetchJson(url: string, init?: RequestInit) {
  const res = await fetch(url, init)
  if (!res.ok) throw new Error(`${res.status} ${res.statusText}`)
  return res.json()
}

export async function fetchAllProducts(): Promise<Product[]> {
  try {
    const local = await fetchJson(LOCAL)
    return normalize(local)
  } catch (_) {
    try {
      const ext = await fetchJson(STAFF, {
        headers: authHeaderMaybe()
      })
      const arr = Array.isArray(ext) ? ext : (ext.items ?? [])
      return normalize(arr)
    } catch (e) {
      console.warn('[products] both sources failed', e)
      return []
    }
  }
}

function authHeaderMaybe() {
  const tok = (import.meta as any).env?.VITE_CLIENT_APP_SHARED_TOKEN
  return tok ? { Authorization: `Bearer ${tok}` } : {}
}

function normalize(input: any[]): Product[] {
  return (input || []).map(p => ({
    id: String(p.id ?? p._id ?? cryptoRandom()),
    name: p.name ?? p.productName ?? 'Unknown',
    lender_name: p.lender_name ?? p.lenderName ?? p.lender ?? 'Unknown',
    category: normalizeCategory(p.category ?? p.type ?? p.productType ?? ''),
    country: p.country ?? p.region ?? 'CA',
    minAmount: numOrUndef(p.minAmount ?? p.min ?? p.min_loan_amount),
    maxAmount: numOrUndef(p.maxAmount ?? p.max ?? p.max_loan_amount),
  }))
}

function normalizeCategory(raw: string): string {
  const s = String(raw || '').toLowerCase().replace(/\s+/g,'_')
  const map: Record<string,string> = {
    line_of_credit: 'Line of Credit',
    loc: 'Line of Credit',
    term_loan: 'Term Loan',
    invoice_factoring: 'Invoice Factoring',
    factoring: 'Invoice Factoring',
    equipment_financing: 'Equipment Financing',
    equipment_finance: 'Equipment Financing',
    purchase_order_financing: 'Purchase Order Financing',
    po_financing: 'Purchase Order Financing',
    working_capital: 'Working Capital',
  }
  return map[s] ?? (raw ? raw : 'Other')
}

function numOrUndef(x:any){ const n=Number(x); return Number.isFinite(n)?n:undefined }
function cryptoRandom(){ return Math.random().toString(36).slice(2) }
TS

pass "products.ts written."

# ---- 3) Step 2: category engine + UI -------------------------------------
cat > "${LIB_DIR}/recommendations/categoryEngine.ts" <<'TS'
import type { Product } from '../../api/products'

export type Intake = {
  amountRequested?: number
  loanAmount?: number
  country?: string
  province?: string
  industry?: string
}

export type CategoryCluster = {
  category: string
  products: Product[]
  count: number
  percentage: number
  matchScore: number
}

const LSK = 'bf:step2:category'

export function getSelectedCategory(): string | null {
  try { return localStorage.getItem(LSK) } catch { return null }
}
export function setSelectedCategory(cat: string) {
  try { localStorage.setItem(LSK, cat) } catch {}
}

export function computeCategories(intake: Intake, products: Product[]): CategoryCluster[] {
  const amount = intake.amountRequested ?? intake.loanAmount ?? 0
  const country = (intake.country ?? 'CA').toUpperCase()

  const eligible = products.filter(p => {
    const okCountry = !p.country || String(p.country).toUpperCase() === country
    const min = p.minAmount ?? 0
    const max = p.maxAmount ?? Number.MAX_SAFE_INTEGER
    const okAmount = !amount || (amount >= min && amount <= max)
    return okCountry && okAmount
  })

  const byCat = new Map<string, Product[]>()
  for (const p of eligible) {
    const c = p.category || 'Other'
    if (!byCat.has(c)) byCat.set(c, [])
    byCat.get(c)!.push(p)
  }

  const total = eligible.length || 1
  const clusters: CategoryCluster[] = Array.from(byCat.entries()).map(([category, prods]) => {
    const coverage = prods.length / total
    // Simple scoring: availability + coverage
    const score = Math.round( (0.7 * 100) + (coverage * 30) )
    return {
      category,
      products: prods,
      count: prods.length,
      percentage: Math.round(coverage * 100),
      matchScore: Math.min(100, Math.max(70, score))
    }
  })

  // Stable order (your six categories prioritized)
  const order = [
    'Line of Credit',
    'Term Loan',
    'Invoice Factoring',
    'Equipment Financing',
    'Purchase Order Financing',
    'Working Capital'
  ]
  clusters.sort((a,b) => {
    const ia = order.indexOf(a.category); const ib = order.indexOf(b.category)
    if (ia !== -1 && ib !== -1 && ia !== ib) return ia - ib
    if (ia !== -1 && ib === -1) return -1
    if (ib !== -1 && ia === -1) return 1
    return b.matchScore - a.matchScore
  })

  return clusters
}
TS

cat > "${CMP_DIR}/Step2/CategoryCards.tsx" <<'TSX'
import React from 'react'
import { fetchAllProducts, type Product } from '../../api/products'
import { computeCategories, getSelectedCategory, setSelectedCategory, type Intake } from '../../lib/recommendations/categoryEngine'

type Props = {
  intake: Intake
  onSelect: (category: string, products: Product[]) => void
}

export default function CategoryCards({ intake, onSelect }: Props) {
  const [loading, setLoading] = React.useState(true)
  const [clusters, setClusters] = React.useState<ReturnType<typeof computeCategories>>([])
  const [error, setError] = React.useState<string | null>(null)
  const selected = getSelectedCategory()

  React.useEffect(() => {
    let alive = true
    ;(async () => {
      try {
        const products = await fetchAllProducts()
        if (!alive) return
        const cs = computeCategories(intake, products)
        setClusters(cs)
      } catch (e:any) {
        setError(e?.message ?? 'Failed to load categories')
      } finally {
        setLoading(false)
      }
    })()
    return () => { alive = false }
  }, [JSON.stringify(intake)])

  if (loading) return <div>Loading categories…</div>
  if (error) return <div className="text-red-600">{error}</div>
  if (!clusters.length) return <div>No eligible categories found for your profile.</div>

  return (
    <div className="space-y-4">
      {clusters.map((c) => (
        <div key={c.category} className="rounded-xl border border-gray-200 shadow-sm p-5">
          <div className="flex items-start gap-4 justify-between">
            <div>
              <h3 className="text-lg font-semibold">{c.category}</h3>
              <div className="mt-1 text-sm text-gray-600">
                <strong>{c.count}</strong> product{c.count===1?'':'s'} available &middot; Market share ~{c.percentage}% &middot; Match score {c.matchScore}%
              </div>
              <ul className="mt-2 list-disc pl-5 text-sm text-emerald-700">
                <li>Matches your funding requirement</li>
                <li>Available in your region ({(intake.country ?? 'CA').toUpperCase()})</li>
              </ul>
            </div>
            <div className="flex items-center gap-3">
              <span className="inline-flex items-center rounded-full bg-emerald-50 text-emerald-700 text-sm px-3 py-1">
                {c.matchScore}% Match
              </span>
              <button
                className={`px-4 py-2 rounded-lg text-sm font-medium border ${
                  selected === c.category ? 'bg-emerald-600 text-white border-emerald-600' : 'bg-white text-emerald-700 border-emerald-600'
                }`}
                onClick={() => { setSelectedCategory(c.category); onSelect(c.category, c.products) }}
                aria-label={`Select ${c.category}`}
              >
                {selected === c.category ? 'Selected' : 'Select'}
              </button>
            </div>
          </div>
        </div>
      ))}
    </div>
  )
}
TSX

pass "Step 2 category engine + UI written."

# ---- 4) Step 5: doc rules + helper (local-first, API fallback) -----------
cat > "${LIB_DIR}/docs/rules.ts" <<'TS'
export type DocRequirement = {
  key: string            // e.g., 'bank_statements'
  label: string          // 'Bank Statements'
  requiredCount: number  // e.g., 6
}

const base: DocRequirement[] = [
  { key: 'bank_statements', label: 'Bank Statements', requiredCount: 6 },
  { key: 'financial_statements', label: 'Financial Statements', requiredCount: 3 },
]

const byCategory: Record<string, DocRequirement[]> = {
  'Term Loan': [...base, { key: 'cash_flow', label: 'Cash Flow Statement', requiredCount: 1 }],
  'Equipment Financing': [...base, { key: 'equipment_quote', label: 'Equipment Quote', requiredCount: 1 }],
  'Invoice Factoring': [...base, { key: 'ar_aging', label: 'A/R Aging', requiredCount: 1 }],
  'Purchase Order Financing': [...base, { key: 'purchase_orders', label: 'Purchase Orders', requiredCount: 1 }],
  'Line of Credit': base,
  'Working Capital': base,
}

export async function getRequiredDocsForCategory(category: string): Promise<DocRequirement[]> {
  // Try staff endpoint if available (external shape may vary)
  const extUrl = (import.meta.env.VITE_STAFF_API_URL ?? 'https://staff.boreal.financial/api') + '/required-docs'
  try {
    const res = await fetch(extUrl)
    if (res.ok) {
      const j = await res.json()
      const arr = (j?.required_documents ?? j?.items ?? []) as any[]
      if (Array.isArray(arr) && arr.length) {
        // If external returns strings, map to labels
        const map: DocRequirement[] = arr.map((s: any) => {
          const key = String(s.key ?? s).toLowerCase().replace(/\s+/g,'_')
          const label = s.label ?? s.name ?? String(s)
          const requiredCount = Number(s.requiredCount ?? 1)
          return { key, label, requiredCount: Number.isFinite(requiredCount) ? requiredCount : 1 }
        })
        // Keep only those that match our chosen category base set (if provided)
        const local = byCategory[category] ?? base
        const keys = new Set(local.map(d => d.key))
        const merged = map.filter(d => keys.has(d.key))
        return merged.length ? merged : local
      }
    }
  } catch { /* ignore */ }
  // Local fallback
  return byCategory[category] ?? base
}
TS

cat > "${CMP_DIR}/Step5/RequiredDocsPanel.tsx" <<'TSX'
import React from 'react'
import { getRequiredDocsForCategory, type DocRequirement } from '../../lib/docs/rules'
import { getSelectedCategory } from '../../lib/recommendations/categoryEngine'

type Props = {
  onResolved?: (docs: DocRequirement[]) => void
  // If your app already has a FileUploadTile or similar, pass it in and we'll use it.
  UploaderTile?: React.ComponentType<{ docKey:string; label:string; requiredCount:number }>
}

export default function RequiredDocsPanel({ onResolved, UploaderTile }: Props) {
  const [category] = React.useState(getSelectedCategory())
  const [docs, setDocs] = React.useState<DocRequirement[] | null>(null)

  React.useEffect(() => {
    (async () => {
      const d = await getRequiredDocsForCategory(category ?? 'Line of Credit')
      setDocs(d)
      onResolved?.(d)
    })()
  }, [category])

  if (!docs) return <div>Loading requirements…</div>

  return (
    <div className="space-y-4">
      <div className="rounded-md bg-emerald-50 border border-emerald-200 px-4 py-3 text-emerald-800">
        <strong>Required Documents – Authentic Lender Requirements</strong>
        <div className="text-sm">Consolidated from matching lender products for your selections</div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        {docs.map(d => (
          <div key={d.key} className="rounded-xl border border-gray-200 p-5 shadow-sm">
            <div className="flex items-center justify-between mb-2">
              <h3 className="text-lg font-semibold">{d.label}</h3>
              <span className="text-xs rounded-full bg-rose-50 text-rose-700 px-2 py-1">Required</span>
            </div>
            <div className="text-sm text-gray-600 mb-3">Required: <strong>{d.requiredCount} file{d.requiredCount===1?'':'s'}</strong></div>
            {UploaderTile
              ? <UploaderTile docKey={d.key} label={d.label} requiredCount={d.requiredCount}/>
              : <div className="border-2 border-dashed rounded-lg p-6 text-center text-gray-500">Choose files or drag and drop</div>
            }
          </div>
        ))}
      </div>
    </div>
  )
}
TSX

pass "Step 5 rules + panel written."

# ---- 5) Wire Step 2 & Step 5 pages (non-destructive) ---------------------
#   - Step 2: Replace old product-list rendering with CategoryCards
#   - Step 5: Insert RequiredDocsPanel; preserve existing uploader if present
# If target files don’t exist, we create minimal shells.

# Step 2 page
if [ ! -f "$ROUTES_STEP2" ]; then
  cat > "$ROUTES_STEP2" <<'TSX'
import React from 'react'
import CategoryCards from '../../components/Step2/CategoryCards'
export default function Step2(){
  const intake = React.useMemo(() => {
    try{ return JSON.parse(localStorage.getItem('bf:intake')||'{}') }catch{ return {} }
  },[])
  return (
    <div className="max-w-4xl mx-auto space-y-6">
      <h1 className="text-2xl font-bold">Step 2: Lender Recommendations</h1>
      <CategoryCards intake={intake} onSelect={() => { /* optionally route to step 5 */ }} />
    </div>
  )
}
TSX
  pass "Created minimal Step 2 page."
else
  # Patch: import + mount CategoryCards (idempotent)
  if ! rg -n "CategoryCards" "$ROUTES_STEP2" >/dev/null 2>&1; then
    ed -s "$ROUTES_STEP2" <<'ED'
/^import /,$p
$,$a

import CategoryCards from '../../components/Step2/CategoryCards'
ED
  fi
  if ! rg -n "CategoryCards intake" "$ROUTES_STEP2" >/dev/null 2>&1; then
    ed -s "$ROUTES_STEP2" <<'ED'
/return (/+1,a
  const intake = React.useMemo(() => {
    try{ return JSON.parse(localStorage.getItem('bf:intake')||'{}') }catch{ return {} }
  },[])
.
ED
    ed -s "$ROUTES_STEP2" <<'ED'
/<div .*Step 2.*>/,/<\/div>/ s//<div className="max-w-4xl mx-auto space-y-6">\n  <h1 className="text-2xl font-bold">Step 2: Lender Recommendations<\/h1>\n  <CategoryCards intake={intake} onSelect={() => { /* route to step 5 if desired */ }} \/>\n<\/div>/
w
q
ED
  fi
  pass "Patched Step 2 to use CategoryCards."
fi

# Step 5 page
if [ ! -f "$ROUTES_STEP5" ]; then
  cat > "$ROUTES_STEP5" <<'TSX'
import React from 'react'
import RequiredDocsPanel from '../../components/Step5/RequiredDocsPanel'
export default function Step5(){
  return (
    <div className="max-w-5xl mx-auto space-y-6">
      <h1 className="text-2xl font-bold">Step 5: Required Documents</h1>
      <RequiredDocsPanel />
    </div>
  )
}
TSX
  pass "Created minimal Step 5 page."
else
  if ! rg -n "RequiredDocsPanel" "$ROUTES_STEP5" >/dev/null 2>&1; then
    ed -s "$ROUTES_STEP5" <<'ED'
/^import /,$p
$,$a

import RequiredDocsPanel from '../../components/Step5/RequiredDocsPanel'
ED
  fi
  if ! rg -n "<RequiredDocsPanel" "$ROUTES_STEP5" >/dev/null 2>&1; then
    ed -s "$ROUTES_STEP5" <<'ED'
/return (/+1,a
  const UploaderTile = undefined // If you already have a tile component, import it and pass here
.
/<\/main>|<\/div>/
.,.+1 s//<RequiredDocsPanel UploaderTile={UploaderTile} \/>\n&/
w
q
ED
  fi
  pass "Patched Step 5 to include RequiredDocsPanel."
fi

# ---- 6) Submission schema guard (documents[], documentStatus, selectedCategory)
GUARD_FILE="${LIB_DIR}/submitSchema.ts"
cat > "$GUARD_FILE" <<'TS'
export type Submission = Record<string, any>
export function ensureSubmissionSchema(input: Submission): Submission {
  const out = { ...input }
  if (!Array.isArray(out.documents)) out.documents = []
  if (typeof out.documentStatus !== 'string') out.documentStatus = 'pending'
  // include selected category for staff visibility
  try {
    const cat = localStorage.getItem('bf:step2:category')
    if (cat) out.selectedCategory = cat
  } catch {}
  return out
}
TS
pass "Submission schema guard written."

# ---- 7) Quick sanity: ensure no remaining legacy engine imports -----------
LEFT="$(rg -n "getRecommendedProducts|recommendations/engine" client/src --hidden --glob '!**/*.map' || true)"
[ -z "${LEFT:-}" ] && pass "No legacy engine imports remain." || { warn "Legacy refs remain:\n$LEFT"; }

# ---- 8) Build to generate dist/public for server -------------------------
note "Building client… (this also verifies TS)"
if npm run build >/dev/null 2>"$R/build.err"; then
  pass "Build OK"
else
  warn "Build emitted errors (see $R/build.err). Address and rebuild."
fi

note "== DONE =="
note "Files quarantined in: $TRASH"
note "Report: $R/summary.txt"
```

---

### What the agent should verify after running

1. **Step 2 (Categories)**

   * Navigate to `/apply/step-2`.
   * You should see **category cards** (Line of Credit, Term Loan, Invoice Factoring, Equipment Financing, PO Financing, Working Capital) with counts, market share, and “Select” button.
   * Selecting a card saves the choice to `localStorage['bf:step2:category']`.

2. **Step 5 (Required Docs)**

   * Navigate to `/apply/step-5`.
   * You should see a green “Required Documents – Authentic Lender Requirements” block and **document cards** (e.g., Bank Statements, Financial Statements, Equipment Quote for Equipment Financing, etc.).
   * If your app already has a file-upload tile (e.g., `FileUploadTile`), import it in `Step5.tsx` and pass it into `<RequiredDocsPanel UploaderTile={FileUploadTile} />` to use the real uploader UI.

3. **Submission schema**

   * When submitting, ensure the payload passes through `ensureSubmissionSchema()` so it always includes:

     ```json
     {
       "documents": [],
       "documentStatus": "pending",
       "selectedCategory": "…"
     }
     ```
   * This keeps the **staff handoff** compatible.

---

### Notes on colors & fonts (match your screenshots)

* This patch **does not** change your theme; it uses your existing Tailwind/utility classes and neutral HTML, which pick up your current Inter font, mint/emerald accents, pale amber banner, rounded cards, and dashed dropzones.
* If your design system components exist (e.g., Alert, Card), you can swap them into the shells without touching the logic.

---

If anything in your repo uses different paths/component names for Step 2/5, tell me the file locations and I’ll tailor the exact patch lines.
