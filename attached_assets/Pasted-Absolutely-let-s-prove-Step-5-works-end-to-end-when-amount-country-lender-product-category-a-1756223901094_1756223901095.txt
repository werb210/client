Absolutely—let’s prove Step 5 works end-to-end when **amount + country + lender product category** are known, and that the **required document list** both **displays** and is **handled** (upload/validation/state/submit) correctly.

Below is a drop-in, **self-contained E2E test plan** with tiny dev routes + Playwright tests that don’t depend on real storage/S3. It covers Canada/US, multiple categories, and amount thresholds.

---

# 0) Preconditions (dev)

* App running at `http://localhost:5000`
* Login: `todd.w@boreal.financial / 1Sucker1!`
* 2FA test: `VERIFY_TEST_MODE=true`, `VERIFY_TEST_CODE=000000`
* Interceptors attached so requests hit `/api/*` with a Bearer token

---

# 1) Dev seed: create a deterministic application + products

**server/dev-seed-docs.ts** (mount only in dev; call from `boot.ts`):

```ts
// PSEUDOCODE/TS you can paste into a dev-only file & import in boot.ts
export function mountDevSeedDocs(app, db, requireJwt) {
  app.post("/api/dev/seed-docs", requireJwt, async (_req, res) => {
    // App we’ll test Step 5 against (amount + country + category set):
    await db.query(`
      INSERT INTO applications (id, business_name, requested_amount, country, product_category,
                                monthly_revenue, time_in_business_months, status)
      VALUES ('app_docs_001', 'Prairie Outfitters Ltd.', 250000, 'CA', 'term',
              150000, 36, 'review')
      ON CONFLICT (id) DO UPDATE SET
        requested_amount = EXCLUDED.requested_amount,
        country = EXCLUDED.country,
        product_category = EXCLUDED.product_category,
        monthly_revenue = EXCLUDED.monthly_revenue,
        time_in_business_months = EXCLUDED.time_in_business_months,
        status = EXCLUDED.status;
    `);

    await db.query(`
      INSERT INTO lenders (id, name) VALUES ('l1','Prairie Bank')
      ON CONFLICT (id) DO NOTHING;
    `);

    await db.query(`
      INSERT INTO lender_products (id, lender_id, name, product_type, max_amount, min_revenue,
                                   min_time_in_business_months, min_credit_score, rate)
      VALUES
      ('p_term_ca','l1','CA Term Loan','term',600000, 50000, 12, 650, '9.2%')
      ON CONFLICT (id) DO NOTHING;
    `);

    res.json({ ok: true, appId: "app_docs_001", productIds: ["p_term_ca"] });
  });
}
```

In `server/boot.ts` (dev only):

```ts
import { mountDevSeedDocs } from "./dev-seed-docs";
mountDevSeedDocs(app, db, requireJwt);
```

Seed it:

```bash
TOKEN=$(curl -s -X POST http://localhost:5000/api/auth/login \
  -H 'Content-Type: application/json' \
  -d '{"email":"todd.w@boreal.financial","password":"1Sucker1!"}' | jq -r '.token')

curl -s -X POST http://localhost:5000/api/dev/seed-docs -H "Authorization: Bearer $TOKEN" | jq .
```

---

# 2) Rules endpoint (server) — canonical, **field-normalized** doc requirements

Create a single dev preview endpoint that the client Step 5 already calls (or temporarily point Step 5 to it) to ensure consistent shapes.

**server/dev-docs-preview\.ts**:

```ts
// Returns exactly what Step 5 expects: {requirements:[{id,label,required,accept,category}]}
export function mountDevDocsPreview(app, db, requireJwt) {
  app.get("/api/dev/docs-requirements", requireJwt, async (req, res) => {
    // Input normalization: we accept appId or direct query params (amount/country/category)
    const appId = (req.query.appId as string) || "app_docs_001";
    let amount = Number(req.query.amount || 0);
    let country = (req.query.country as string) || "";
    let category = (req.query.category as string) || "";

    if (appId) {
      const { rows } = await db.query(`
        SELECT
          COALESCE(requested_amount, amount, "requestedAmount", 0) AS amount,
          COALESCE(country, province, state, 'CA')                 AS country,
          COALESCE(product_category, product_type, 'term')         AS category
        FROM applications WHERE id = $1 LIMIT 1`, [appId]);
      if (rows[0]) {
        amount   = Number(rows[0].amount || amount);
        country  = (rows[0].country || country || "CA").toUpperCase();
        category = (rows[0].category || category || "term").toLowerCase();
      }
    }

    // Rule table
    const CA_COMMON = [
      { id:"gov-id",   label:"Government Photo ID",    required:true,  accept:["image/*","application/pdf"], category:"kyc" },
      { id:"inc-docs", label:"Articles of Incorporation", required:true, accept:["application/pdf"], category:"kyb" },
      { id:"void-chq", label:"Voided Cheque",          required:true,  accept:["image/*","application/pdf"], category:"bank" },
    ];
    const US_COMMON = [
      { id:"gov-id",     label:"Government Photo ID",  required:true,  accept:["image/*","application/pdf"], category:"kyc" },
      { id:"ein-letter", label:"IRS EIN Letter",       required:true,  accept:["application/pdf"], category:"kyb" },
      { id:"void-chq",   label:"Voided Check",         required:true,  accept:["image/*","application/pdf"], category:"bank" },
    ];

    const BANK_STMTS_3M = { id:"bank-3m", label:"Last 3 Months Bank Statements", required:true, accept:["application/pdf"], category:"financials" };
    const BANK_STMTS_6M = { id:"bank-6m", label:"Last 6 Months Bank Statements", required:true, accept:["application/pdf"], category:"financials" };
    const FS_Y1         = { id:"fs-y1",   label:"Year-End Financials (Last Year)", required:true, accept:["application/pdf"], category:"financials" };
    const FS_Y2         = { id:"fs-y2",   label:"Year-End Financials (Prev Year)", required:true, accept:["application/pdf"], category:"financials" };
    const EQUIP_QUOTE   = { id:"equip-quote", label:"Equipment Quote / Invoice", required:true, accept:["application/pdf","image/*"], category:"equipment" };
    const EQUIP_LIST    = { id:"equip-list",  label:"Equipment List / Specs",    required:false, accept:["application/pdf","image/*"], category:"equipment" };

    const isCA = country === "CA";
    const base = isCA ? CA_COMMON : US_COMMON;

    let rules = [...base];
    if (category === "term") {
      rules.push(amount >= 100000 ? BANK_STMTS_6M : BANK_STMTS_3M);
      if (amount >= 100000) rules.push(FS_Y1, FS_Y2);
    } else if (category === "equipment") {
      rules.push(EQUIP_QUOTE, EQUIP_LIST, amount >= 100000 ? BANK_STMTS_6M : BANK_STMTS_3M);
    } else { // working capital / wc / other
      rules.push(BANK_STMTS_3M);
    }

    // Always return stable shape
    return res.json({ requirements: rules });
  });
}
```

Mount in `boot.ts` (dev only):

```ts
import { mountDevDocsPreview } from "./dev-docs-preview";
mountDevDocsPreview(app, db, requireJwt);
```

Sanity:

```bash
curl -s -H "Authorization: Bearer $TOKEN" \
  "http://localhost:5000/api/dev/docs-requirements?appId=app_docs_001" | jq .
```

Expect CA + term + 250k → **Gov ID**, **Articles of Incorporation**, **Voided Cheque**, **6M Bank Statements**, **2 years Financials**.

---

# 3) Client selectors (one-time tiny tweak for robust tests)

Ensure Step 5 renders each doc row with predictable hooks:

```tsx
// In your Step 5 DocumentList row component:
<li data-testid={`doc-item-${doc.id}`}>
  <span data-testid={`doc-label-${doc.id}`}>{doc.label}</span>
  {doc.required && <span data-testid={`doc-required-${doc.id}`}>Required</span>}
  <input
    type="file"
    data-testid={`doc-input-${doc.id}`}
    accept={doc.accept?.join(",") ?? "*/*"}
  />
  {/* When uploaded: */}
  {/* <span data-testid={`doc-status-${doc.id}`}>Received</span> */}
</li>
```

And ensure the **Next/Continue** button has `data-testid="next-step"` and is **disabled** until all `required:true` docs are uploaded.

---

# 4) Playwright E2E — **login → Step 5 → asserts → uploads → Next enabled**

`e2e/step5.docs.spec.ts`:

```ts
import { test, expect } from "@playwright/test";
import path from "path";

test("Step 5 shows correct docs and handles uploads", async ({ page }) => {
  // Seed
  const tokenResp = await fetch("http://localhost:5000/api/auth/login", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ email: "todd.w@boreal.financial", password: "1Sucker1!" }),
  });
  const { token } = await tokenResp.json();
  await fetch("http://localhost:5000/api/dev/seed-docs", {
    method: "POST",
    headers: { Authorization: `Bearer ${token}` },
  });

  // Login + 2FA test
  await page.goto("http://localhost:5000/login");
  await page.getByLabel(/email/i).fill("todd.w@boreal.financial");
  await page.getByLabel(/password/i).fill("1Sucker1!");
  await page.getByRole("button", { name: /sign in/i }).click();
  await expect(page).toHaveURL(/\/login\/verify/);
  await page.getByLabel(/verification code/i).fill("000000");
  await page.getByRole("button", { name: /verify/i }).click();
  await expect(page).toHaveURL(/\/staff/);

  // Navigate to Step 5 for app_docs_001 (adjust to your actual route/UI)
  await page.getByRole("link", { name: /pipeline/i }).click();
  await page.getByTestId("pipeline-card-app_docs_001").click();
  await page.getByRole("tab", { name: /step 5/i }).click();
  await expect(page.getByRole("heading", { name: /documents/i })).toBeVisible();

  // Expected for CA + term + 250k:
  const expectedRequired = [
    "gov-id",
    "inc-docs",
    "void-chq",
    "bank-6m",
    "fs-y1",
    "fs-y2",
  ];
  for (const id of expectedRequired) {
    await expect(page.getByTestId(`doc-item-${id}`)).toBeVisible();
    await expect(page.getByTestId(`doc-required-${id}`)).toBeVisible();
  }

  // Next should be disabled initially
  const nextBtn = page.getByTestId("next-step");
  await expect(nextBtn).toBeDisabled();

  // Upload fake PDFs/images for every required doc
  const fixture = (name: string) => path.resolve(__dirname, "fixtures", name);
  await page.getByTestId("doc-input-gov-id").setInputFiles(fixture("id.pdf"));
  await page.getByTestId("doc-input-inc-docs").setInputFiles(fixture("articles.pdf"));
  await page.getByTestId("doc-input-void-chq").setInputFiles(fixture("voidcheque.png"));
  await page.getByTestId("doc-input-bank-6m").setInputFiles(fixture("bank_6m.pdf"));
  await page.getByTestId("doc-input-fs-y1").setInputFiles(fixture("fs_2024.pdf"));
  await page.getByTestId("doc-input-fs-y2").setInputFiles(fixture("fs_2023.pdf"));

  // Each should flip to Received
  for (const id of expectedRequired) {
    await expect(page.getByTestId(`doc-status-${id}`)).toHaveText(/received/i);
  }

  // Now Next should be enabled
  await expect(nextBtn).toBeEnabled();
  // Optionally click it to confirm you can proceed
  // await nextBtn.click();
});
```

Add small fixtures under `e2e/fixtures/`:

* `id.pdf`, `articles.pdf`, `voidcheque.png`, `bank_6m.pdf`, `fs_2024.pdf`, `fs_2023.pdf` (tiny dummy files)

Run:

```bash
npx playwright test e2e/step5.docs.spec.ts --headed
```

---

# 5) Negative & edge tests (fast)

* Wrong filetype: upload `.exe` to `gov-id` → expect inline validation error and no “Received”.
* Oversize: simulate 20 MB file → expect size error.
* Missing one required doc → **Next** stays disabled.
* Different scenario: **US + equipment + \$80k**
  Seed app with `country=US`, `category=equipment`, `requested_amount=80000` → expect **Gov ID + EIN + Voided Check + Equipment Quote + (optional Equipment List) + Bank 3M**; no Financials Y1/Y2.

---

# 6) Common failure causes checklist

* **Shape mismatch:** Step 5 expects `{requirements:[{id,label,required,accept}]}`. If you use another endpoint, normalize to this shape.
* **Selectors missing:** Add `data-testid` as shown so tests are robust.
* **Uploads in dev:** Ensure your upload handler returns `{id,url}` and updates the item state; if you mock uploads, immediately set status to “Received”.
* **Country/category casing:** Normalize (`country.toUpperCase()`, `category.toLowerCase()`).
* **Amount thresholds:** Confirm 100k/… boundaries in rules.

---

## Acceptance Criteria (sign-off)

* For **CA + term + 250k**, Step 5 renders exactly these required docs: **Gov ID, Articles of Incorporation, Voided Cheque, Bank Statements (6M), Financials Y1, Financials Y2**.
* After uploading valid files for each required doc, the UI marks each **Received** and **Next** becomes **enabled**.
* Negative cases (type/size/missing) keep **Next disabled** and show inline errors.

If you want, I can tailor the rules matrix to your lender partners (e.g., add **NOA/T1** for sole props, **GST/HST returns**, **void cheque naming constraint**, etc.), but the above will give you a dependable, automated E2E that proves Step 5 is correct and regression-safe.
