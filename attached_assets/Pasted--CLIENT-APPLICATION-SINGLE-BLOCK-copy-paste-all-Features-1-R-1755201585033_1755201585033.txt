# ============================
# CLIENT APPLICATION — SINGLE BLOCK (copy/paste all)
# Features: 1) Real KYC start/status (Persona) • 3) (no client OCR UI) • 4) (no client engine UI)
#           5) Compliance ready (inbound STOP/HELP handled server-side)
# Replit Rules Header (agent): Exact Execution • Two apps separated • Full copy/paste blocks • No delays/questions
# ============================
set -euo pipefail

# --- 0) Dependencies
npm i @aws-sdk/client-s3

# --- 1) ENV (duplicate shared relevant bits for clarity)
if ! grep -q "KYC_PROVIDER=" .env 2>/dev/null; then
  cat >> .env << 'EOF'
# ===== KYC (Persona) =====
KYC_PROVIDER=persona
PERSONA_API_KEY=__set_persona_key__
PERSONA_TEMPLATE_ID=tmpl_XXXXXXXX
KYC_WEBHOOK_SECRET=__set_random_string__

# ===== Compliance (quiet hours + keywords) =====
QUIET_HOURS_START=21:00
QUIET_HOURS_END=08:00
QUIET_HOURS_TZ=America/Edmonton
STOP_KEYWORDS=STOP,UNSUBSCRIBE,CANCEL,END,QUIT
HELP_KEYWORDS=HELP,INFO
EOF
fi

# --- 2) DB migration (ensure shared tables exist if client backend is separate)
mkdir -p server/db/migrations
cat > server/db/migrations/2025_08_14_client_shared.sql << 'EOF'
CREATE TABLE IF NOT EXISTS kyc_sessions (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  contact_id uuid NOT NULL,
  provider varchar(32) NOT NULL,
  provider_ref text,
  provider_session_url text,
  status varchar(24) NOT NULL DEFAULT 'pending',
  reason text,
  provider_metadata jsonb,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_at timestamptz NOT NULL DEFAULT now()
);
CREATE INDEX IF NOT EXISTS idx_kyc_contact ON kyc_sessions(contact_id);
EOF

npm run db:migrate

# --- 3) KYC routes (client-facing wrapper) — start + status + webhook
mkdir -p server/services/kyc server/routes/client/privacy
cat > server/services/kyc/providers.ts << 'EOF'
export type KycSession = { url?: string; providerRef?: string; status: string; reason?: string };

export interface KycProvider {
  start(contact: { id: string; email?: string; phone?: string }): Promise<KycSession>;
  status(providerRef: string): Promise<KycSession>;
  webhookVerify(raw: string, signature: string): boolean;
}

class PersonaProvider implements KycProvider {
  base = "https://withpersona.com/api/v1";
  key = process.env.PERSONA_API_KEY || "";
  template = process.env.PERSONA_TEMPLATE_ID || "";
  headers() { return { "Content-Type":"application/json", "Authorization": `Bearer ${this.key}` }; }
  async start(contact:{id:string}) {
    const res = await fetch(`${this.base}/inquiries`, {
      method:"POST", headers: this.headers(),
      body: JSON.stringify({ data:{ type:"inquiry", attributes:{ "template-id": this.template, "reference-id": contact.id }}})
    });
    if (!res.ok) throw new Error("Persona start failed");
    const j = await res.json();
    const url = j?.data?.attributes?.["inquiry-template"]?.["link-href"] || j?.data?.attributes?.["redirect-uri"];
    const ref = j?.data?.id;
    return { url, providerRef: ref, status: "pending" };
  }
  async status(ref:string){
    const res = await fetch(`${this.base}/inquiries/${ref}`, { headers: this.headers() });
    const j = await res.json(); const s = j?.data?.attributes?.status || "pending";
    return { providerRef: ref, status: s };
  }
  webhookVerify(raw:string, signature:string){
    const secret = process.env.KYC_WEBHOOK_SECRET || ""; if (!secret || !signature) return false;
    const crypto = require("crypto");
    const h = crypto.createHmac("sha256", secret).update(raw, "utf8").digest("hex");
    try { return crypto.timingSafeEqual(Buffer.from(h), Buffer.from(signature)); } catch { return false; }
  }
}
export function getProvider(){ return new PersonaProvider(); }
EOF

cat > server/routes/client/privacy/kyc.ts << 'EOF'
import { Router } from "express";
import { db } from "../../../db/client";
import { sql } from "drizzle-orm";
import { getProvider } from "../../../services/kyc/providers";

const router = Router();

/* Assume req.contact?.id is set by client auth; fallback to query for testing */
router.post("/start", async (req:any, res)=>{
  const contactId = req.contact?.id || String(req.body?.contactId || req.query.contactId || "");
  if (!contactId) return res.status(401).json({ error: "Unauthorized" });
  const p = getProvider();
  const session = await p.start({ id: contactId });
  await db.execute(sql`
    INSERT INTO kyc_sessions(contact_id, provider, provider_ref, provider_session_url, status)
    VALUES (${contactId}, ${process.env.KYC_PROVIDER || 'persona'}, ${session.providerRef}, ${session.url}, 'pending')
    ON CONFLICT DO NOTHING
  `);
  res.json(session);
});

router.get("/status/:ref", async (req:any, res)=>{
  const p = getProvider();
  res.json(await p.status(String(req.params.ref)));
});

/* Webhook (Persona) */
router.post("/webhook", expressRawBody, async (req:any, res)=>{
  const sig = req.headers["x-persona-signature"] as string || "";
  const p = getProvider();
  if (!p.webhookVerify(req.rawBody, sig)) return res.status(400).json({ error: "bad signature" });
  const body = JSON.parse(req.rawBody || "{}");
  const ref = body?.data?.id || body?.data?.attributes?.["inquiry-id"];
  const status = body?.data?.attributes?.status || "pending";
  await db.execute(sql`UPDATE kyc_sessions SET status=${status}, updated_at=now() WHERE provider_ref=${ref}`);
  res.json({ ok: true });
});

function expressRawBody(req:any, res:any, next:any){
  let data = ""; req.setEncoding("utf8");
  req.on("data", (chunk:string)=> data += chunk);
  req.on("end", ()=> { req.rawBody = data; next(); });
}

export default router;
EOF

# Mount (idempotent)
if ! grep -q "app.use(\"/api/client/privacy/kyc\"" server/index.ts; then
  cat >> server/index.ts << 'EOF'
import clientKycRouter from "./routes/client/privacy/kyc";
app.use("/api/client/privacy/kyc", clientKycRouter);
EOF
fi

# --- 4) Client UI: KYC start/status page
mkdir -p client/src/client
cat > client/src/client/KycStart.tsx << 'EOF'
import React, { useState } from "react";

export default function KycStart(){
  const [contactId, setContactId] = useState(new URLSearchParams(location.search).get("contactId") || "");
  const [session, setSession] = useState<any>(null);

  async function start(){
    const r = await fetch("/api/client/privacy/kyc/start", {
      method:"POST", headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ contactId })
    });
    const j = await r.json(); setSession(j);
    if (j.url) location.href = j.url;
  }

  return (
    <div className="p-6 max-w-md mx-auto space-y-3">
      <h1 className="text-xl font-semibold">Verify your identity</h1>
      {!contactId && <input className="border px-2 py-1 w-full" placeholder="Contact ID" value={contactId} onChange={e=>setContactId(e.target.value)} />}
      <button className="px-3 py-2 bg-black text-white rounded" onClick={start}>Start verification</button>
      {session?.providerRef && <div className="text-xs text-gray-600">Ref: {session.providerRef}</div>}
    </div>
  );
}
EOF

# Wire route (append marker)
if ! grep -q "/client/kyc/start" client/src/App.tsx 2>/dev/null; then
  cat >> client/src/App.tsx << 'EOF'
import KycStart from "./client/KycStart";
<Route path="/client/kyc/start" element={<KycStart />} />
EOF
fi

echo "=== CLIENT: KYC (Persona) start/status wired. Compliance handled server-side. ==="
