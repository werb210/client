// CLIENT APP support for:
// - Step 2: product recommendations from Staff DB
// - Step 5: required documents based on products & inputs
// - Duplicate check + (optional) rebuild trigger at the end
// - Stop-on-uncertainty: prompts if Staff endpoints/inputs are missing
//
// Drop this file in your client repo, e.g. src/lib/intake-client.ts

// ---------- Types ----------
export type IntakeAnswers = {
  desired_amount: number | null;
  time_in_business_months: number | null;
  monthly_revenue: number | null;
  credit_score: number | null;
  has_invoices?: boolean;
  has_equipment_quote?: boolean;
  has_purchase_order?: boolean;
  country?: 'US' | 'CA';
  tenant_id?: string;
};

export type RecommendedProduct = {
  id: string;
  name: string;
  country: 'US' | 'CA';
  category: string;
  tenant_id: string;
  lender_id: string;
  lender_name?: string;
  min_amount: number | null;
  max_amount: number | null;
  active: boolean | null;
  variant_sig?: string | null; // presence implies a distinct variant
  score: number;
  reasons: string[];
};

export type RequiredDocsResult = {
  inputs: Partial<IntakeAnswers>;
  checklist: { category: string; documents: string[] }[];
  selected_product_ids: string[];
};

export type DedupeRunResult =
  | { uncertain: true; asks: string[] }
  | { entity: 'lender_products'; dry_run: boolean; duplicates_found: number; rows?: any[]; removed?: number }
  | { entity: 'applications'; report_only: true; duplicate_groups: number; groups: any[] };

type RecResponse = { input: IntakeAnswers; recommended: RecommendedProduct[]; total_considered: number };

// ---------- Helpers ----------
async function postJSON<T>(url: string, body: any): Promise<T> {
  const res = await fetch(url, {
    method: 'POST',
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body ?? {}),
  });
  if (res.status === 412) {
    const j = await res.json().catch(() => ({}));
    const asks = Array.isArray(j?.asks) ? j.asks : ['Missing required inputs'];
    throw Object.assign(new Error('Precondition Required'), { type: 'ASK', asks });
  }
  if (!res.ok) throw new Error(`${url} failed: ${res.status} ${await res.text().catch(()=>'')}`);
  return res.json() as Promise<T>;
}

export const formatCurrencyRange = (min: number | null, max: number | null) => {
  const fmt = (n: number | null) => (n == null ? '—' : `$${n.toLocaleString()}`);
  if (min == null && max == null) return 'Not provided';
  return `${fmt(min)} – ${fmt(max)}`;
};

// ---------- Step 2: Recommendations ----------
export async function getRecommendations(answers: IntakeAnswers, opts?: {
  tenantId?: string; country?: 'US'|'CA';
}) {
  const payload: IntakeAnswers = {
    ...answers,
    ...(opts?.tenantId ? { tenant_id: opts.tenantId } : null),
    ...(opts?.country ? { country: opts.country } : null),
  };
  return postJSON<RecResponse>('/api/recommendations', payload);
}

// ---------- Step 5: Required Docs ----------
export async function getRequiredDocs(opts: {
  selected_product_ids?: string[];
  categories?: string[];
  inputs?: Partial<IntakeAnswers>;
}) {
  return postJSON<RequiredDocsResult>('/api/required-docs', opts);
}

// ---------- Client-side duplicate handling (display-level only) ----------
// Do NOT remove legitimate variants (different variant_sig).
export function dedupeRecommended(list: RecommendedProduct[]): RecommendedProduct[] {
  const seen = new Set<string>();
  const out: RecommendedProduct[] = [];
  for (const p of list) {
    const key = p.id ? `id:${p.id}` : `k:${p.lender_id}|${(p.name||'').toLowerCase()}|${p.country}|${p.variant_sig ?? ''}`;
    if (seen.has(key)) continue;
    seen.add(key);
    out.push(p);
  }
  return out;
}

// Optional UX: show only the top variant per lender-name-country group
export function collapseVisualVariants(list: RecommendedProduct[]): RecommendedProduct[] {
  const groups = new Map<string, RecommendedProduct[]>();
  for (const p of list) {
    const gk = `${p.lender_id}|${(p.name||'').toLowerCase()}|${p.country}`;
    if (!groups.has(gk)) groups.set(gk, []);
    groups.get(gk)!.push(p);
  }
  const out: RecommendedProduct[] = [];
  for (const arr of groups.values()) {
    const best = arr.slice().sort((a,b)=> (b.score-a.score) || ((b.max_amount??0)-(a.max_amount??0)) )[0];
    out.push(best);
  }
  return out;
}

// ---------- End-of-flow duplicate check + (optional) rebuild ----------
export async function runDedupe(entity: 'lender_products'|'applications', dryRun = true) {
  return postJSON<DedupeRunResult>('/api/dedupe/run', { entity, dry_run: dryRun });
}

// Attempt to trigger a rebuild via Staff. If Staff lacks the endpoint, we surface an ASK.
export async function rebuildCatalogIfSupported(): Promise<{ ok: boolean; ask?: string }> {
  try {
    // Convention: Staff may expose an optional rebuild endpoint.
    await postJSON<{ ok: true }>('/api/import/rebuild', { mode: 'variants' });
    return { ok: true };
  } catch (e:any) {
    if (e?.type === 'ASK') return { ok: false, ask: 'Please enable POST /api/import/rebuild on Staff or re-run importer manually.' };
    // If 404/500, surface a generic ask
    return { ok: false, ask: 'Rebuild endpoint not available. Run importer on Staff or enable /api/import/rebuild.' };
  }
}

// ---------- Integration checks (confirm Client can still use Staff DB for Step 2 & 5) ----------
export async function confirmClientIntegration(opts?: {
  tenantId?: string; country?: 'US'|'CA'; expectProducts?: number; // e.g., 42
}) {
  // Supply minimal valid inputs to avoid 412 ASK
  const probe: IntakeAnswers = {
    desired_amount: 10000,
    time_in_business_months: 12,
    monthly_revenue: 20000,
    credit_score: 650,
    country: opts?.country,
    tenant_id: opts?.tenantId,
  };
  const rec = await getRecommendations(probe, { tenantId: opts?.tenantId, country: opts?.country });
  const total = rec.total_considered;

  const expect = opts?.expectProducts;
  const okCount = typeof expect === 'number' ? total === expect : total > 0;

  return {
    totalProductsSeen: total,
    sample: rec.recommended.slice(0, 5),
    ok: okCount,
    message: okCount
      ? `Client sees ${total} products (OK).`
      : `Client sees ${total} products; expected ${expect ?? 'a positive number'}.`,
  };
}

// ---------- Orchestrated end-to-end flow helpers (wizard-friendly) ----------
export function missingFieldsForStep2(a: Partial<IntakeAnswers>): string[] {
  const asks: string[] = [];
  if (a.desired_amount == null) asks.push('desired_amount');
  if (a.time_in_business_months == null) asks.push('time_in_business_months');
  if (a.monthly_revenue == null) asks.push('monthly_revenue');
  if (a.credit_score == null) asks.push('credit_score');
  return asks;
}

export async function step2RecommendFlow(a: IntakeAnswers, { collapseVariants = false } = {}) {
  const asks = missingFieldsForStep2(a);
  if (asks.length) throw Object.assign(new Error('ASK'), { type: 'ASK', asks });
  const { recommended } = await getRecommendations(a);
  const deduped = dedupeRecommended(recommended);
  return collapseVariants ? collapseVisualVariants(deduped) : deduped;
}

export async function step5DocsFlow(selectedProductIds: string[], inputs: Partial<IntakeAnswers>) {
  if ((!selectedProductIds || selectedProductIds.length === 0) && (!inputs || Object.keys(inputs).length === 0)) {
    throw Object.assign(new Error('ASK'), { type: 'ASK', asks: ['Provide selected_product_ids[] or categories[]/inputs'] });
  }
  return getRequiredDocs({ selected_product_ids: selectedProductIds, inputs });
}

// Run at the end of the journey:
// - Applications: report-only (we accept duplicates).
// - Products: remove exact dupes; if catalog count not at target (e.g., 42), ask to rebuild.
export async function finalizeCleanupAndRebuild(confirm: (msg: string) => Promise<boolean>, targetCount = 42) {
  // Applications — REPORT ONLY
  await runDedupe('applications', true);

  // Products — dry run first
  const prodReport = await runDedupe('lender_products', true);
  if ('duplicates_found' in prodReport && prodReport.duplicates_found > 0) {
    const proceed = await confirm(`Found ${prodReport.duplicates_found} exact duplicate product rows. Remove now?`);
    if (proceed) await runDedupe('lender_products', false);
  }

  // Verify catalog size via a probe recommendation (unfiltered)
  const probe: IntakeAnswers = {
    desired_amount: 10000,
    time_in_business_months: 12,
    monthly_revenue: 20000,
    credit_score: 650,
  };
  const rec = await getRecommendations(probe);
  if (rec.total_considered !== targetCount) {
    const proceed = await confirm(
      `Catalog shows ${rec.total_considered} products; expected ${targetCount}. Attempt rebuild now?`
    );
    if (proceed) {
      const r = await rebuildCatalogIfSupported();
      if (!r.ok) {
        // Surface a blocking ASK to the operator so Staff can expose the endpoint or run importer.
        throw Object.assign(new Error('ASK'), {
          type: 'ASK',
          asks: [r.ask || 'Enable /api/import/rebuild on Staff or re-run importer.'],
        });
      }
    }
  }
  return { ok: true };
}

// ---------- Open questions (so the Client can prompt the operator) ----------
export const CLIENT_OPEN_QUESTIONS = [
  'Should recommendations always filter by tenant_id?',
  'Should we filter by country (US/CA) or include cross-border options?',
  'Any categories to exclude from recommendations?',
  'Any lender-specific document requirements beyond the category defaults?',
  'If Staff lacks /api/import/rebuild, who triggers the importer when catalog < 42?',
];

// ---------- Example (pseudo React) ----------
/*
import { useState } from 'react';
import {
  IntakeAnswers, step2RecommendFlow, step5DocsFlow, confirmClientIntegration,
  finalizeCleanupAndRebuild, CLIENT_OPEN_QUESTIONS
} from '@/lib/intake-client';

async function runWizardFlow(answers: IntakeAnswers, selectedProductIds: string[]) {
  // Confirm Staff connectivity & product visibility
  const check = await confirmClientIntegration({ expectProducts: 42 });
  if (!check.ok) {
    // Show check.message and possibly render CLIENT_OPEN_QUESTIONS
  }

  // Step 2
  const recs = await step2RecommendFlow(answers, { collapseVariants: false });

  // Step 5
  const docs = await step5DocsFlow(selectedProductIds, answers);

  // Finish: dedupe + optional rebuild
  const confirm = async (msg: string) => window.confirm(msg);
  await finalizeCleanupAndRebuild(confirm, 42);

  return { recs, docs };
}
*/
