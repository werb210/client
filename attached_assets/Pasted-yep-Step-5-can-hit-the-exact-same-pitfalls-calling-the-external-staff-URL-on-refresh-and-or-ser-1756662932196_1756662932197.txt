yep—Step 5 can hit the **exact same pitfalls** (calling the external staff URL on refresh and/or serving stale SW-cached responses). Here’s a **single** copy-paste block for the **client app** that:

* audits Step 5 for external calls,
* makes required-docs fetching **local-first** with safe fallbacks (staff API → static rules),
* (optionally) hardens uploads to be local-first but keeps them **disabled** unless you turn them on,
* avoids duplicates by replacing imports and removing legacy Step 5 fetchers,
* builds and prints quick verification hints.

> It won’t touch the staff app and won’t re-enable uploads unless you set `VITE_DOC_UPLOAD_ENABLED=true`.

---

```bash
# ============================
# CLIENT APP — STEP 5 "SAME ISSUE" AUDIT & FIX (LOCAL-FIRST, NO DUPES)
# ============================
set -euo pipefail

AUDIT_AT="$(date +%F_%H-%M-%S)"
R="reports/client-step5-auditfix-$AUDIT_AT"
mkdir -p "$R"

echo "== 0) Snapshot current Step 5 fetch/usage =="
rg -nI --hidden -S '/required-docs|required(-|)docs|/uploads|uploadDocument|fetchRequiredDocs' client \
  | tee "$R/00_step5_refs.txt" >/dev/null || true

echo "== 1) Quick probe: local & staff endpoints (for visibility) =="
BASE_LOCAL="http://localhost:5000/api"
BASE_STAFF="${VITE_STAFF_API_URL:-}"
HDR_AUTH=""
[ -n "${VITE_CLIENT_APP_SHARED_TOKEN:-}" ] && HDR_AUTH="-H Authorization: Bearer ${VITE_CLIENT_APP_SHARED_TOKEN}"

{ 
  printf "LOCAL /required-docs -> "
  curl -s -o /dev/null -w "%{http_code}" "$BASE_LOCAL/required-docs"
  echo
  if [ -n "$BASE_STAFF" ]; then
    printf "STAFF /v1/products -> "
    curl -s -o /dev/null -w "%{http_code}" $HDR_AUTH "$BASE_STAFF/v1/products"
    echo
    printf "STAFF /required-docs -> "
    curl -s -o /dev/null -w "%{http_code}" $HDR_AUTH "$BASE_STAFF/required-docs"
    echo
  fi
} | tee "$R/10_probe.txt"

echo "== 2) Create a unified, LOCAL-FIRST Step 5 API (no duplicates) =="
mkdir -p client/src/api
cat > client/src/api/docs.ts <<'TS'
/**
 * Step 5 API (local-first) — required docs + (optional) uploads.
 * Order: local /api/required-docs -> staff /required-docs -> static fallback.
 * Uploads are disabled by default; enable via VITE_DOC_UPLOAD_ENABLED=true.
 */
export type RequiredDocsResponse = { required_documents?: string[] } | string[];

// env
const STAFF_BASE = (import.meta as any).env?.VITE_STAFF_API_URL?.replace(/\/$/, '') || '';
const STAFF_TOKEN = (import.meta as any).env?.VITE_CLIENT_APP_SHARED_TOKEN || '';
const DOC_UPLOAD_ENABLED = ((import.meta as any).env?.VITE_DOC_UPLOAD_ENABLED || 'false') === 'true';

function toList(x:any): string[] {
  if (!x) return [];
  if (Array.isArray(x)) return x as string[];
  if (Array.isArray(x.required_documents)) return x.required_documents as string[];
  return [];
}

const STATIC_FALLBACK: Record<string,string[]> = {
  // minimal safe baseline aligned to current rules
  base: ["Bank Statements (6m)", "Business Tax Returns (3y)", "Financial Statements (P&L, BS)"],
  term_loan: ["Cash Flow Statement"],
  equipment_financing: ["Equipment Quote"],
  line_of_credit: [],
  working_capital: [],
  invoice_factoring: ["A/R Aging Report", "Invoice Samples"],
};

export async function getRequiredDocs(input?: { country?: string; amount?: number; category?: string }): Promise<string[]> {
  // 1) local first
  try {
    const res = await fetch(`/api/required-docs`, { credentials: 'same-origin' });
    if (res.ok) {
      const json = await res.json();
      const list = toList(json);
      if (list.length) {
        (window as any).__step5 = { source:"local", count:list.length, sample:list.slice(0,3) };
        return list;
      }
    }
  } catch {}

  // 2) staff fallback
  if (STAFF_BASE) {
    try {
      const res = await fetch(`${STAFF_BASE}/required-docs`, {
        headers: { ...(STAFF_TOKEN ? { Authorization: `Bearer ${STAFF_TOKEN}` } : {}), 'Accept':'application/json' }
      });
      if (res.ok) {
        const json = await res.json();
        const list = toList(json);
        if (list.length) {
          (window as any).__step5 = { source:"staff", count:list.length, sample:list.slice(0,3) };
          return list;
        }
      }
    } catch {}
  }

  // 3) static fallback (never empty)
  const base = STATIC_FALLBACK.base;
  const extra = input?.category ? (STATIC_FALLBACK[input.category] || []) : [];
  const list = Array.from(new Set([...base, ...extra]));
  (window as any).__step5 = { source:"static", count:list.length, sample:list.slice(0,3) };
  return list;
}

// Optional upload — remains disabled unless env flag is true.
export async function uploadDocument(file: File): Promise<{ id?: string; url?: string }> {
  if (!DOC_UPLOAD_ENABLED) throw new Error("Document upload disabled (VITE_DOC_UPLOAD_ENABLED=false)");
  const fd = new FormData();
  fd.append('file', file);
  const res = await fetch(`/api/uploads`, { method:'POST', body: fd, credentials: 'same-origin' });
  if (!res.ok) throw new Error(`Upload failed: ${res.status}`);
  return res.json();
}
TS

echo "== 3) Rewire Step 5 to use the unified API and remove legacy fetchers =="
# Replace legacy imports/usages (fetchRequiredDocs/getRequiredDocs from other places)
rg -l "fetchRequiredDocs|getRequiredDocs.*docs|from .*docs/requirements" client/src \
  | xargs -r sed -i '' -E 's|from\\s+[\"\\\'].*docs.*[\"\\\']|from "../api/docs"|g'

# If any direct fetch to full staff URL exists, switch to local-first API
rg -l "https?://[^\"']+/required-docs" client/src \
  | xargs -r sed -i '' -E 's|https?://[^\"\\'"]+/required-docs|/api/required-docs|g'

# Remove clearly legacy helpers to avoid duplicates (only if safe filenames exist)
rm -f client/src/lib/docs/fetchRequiredDocs.ts 2>/dev/null || true
rm -f client/src/lib/docs/legacy* 2>/dev/null || true
rm -f client/src/lib/docs/*backup* 2>/dev/null || true

echo "== 4) Dev SW hardening (avoid stale cache on refresh) =="
MAIN="client/src/main.tsx"
if [ -f "$MAIN" ] && ! grep -q "serviceWorker.getRegistrations" "$MAIN"; then
  cat >> "$MAIN" <<'TS'

// dev-only SW guard (Step 5): ensure no cached /required-docs or /uploads responses
if (import.meta.env.DEV && 'serviceWorker' in navigator) {
  navigator.serviceWorker.getRegistrations().then(rs => rs.forEach(r => r.unregister())).catch(()=>{});
}
TS
fi

echo "== 5) Build & smoke-check =="
npm run build >/dev/null 2>&1 || (echo "Build failed – check modified Step 5 imports" && exit 1)

echo "Local required-docs count:" \
 && curl -s "$BASE_LOCAL/required-docs" | jq 'if type=="array" then length else (.required_documents|length // 0) end' 2>/dev/null || true

echo "== 6) What to verify in browser =="
cat <<'NOTE'
1) Navigate to the Step 5 screen and hard-refresh.
2) In DevTools Console run:  window.__step5
   Expected: { source: "local" | "staff" | "static", count: <n>, sample: [...] }
3) Network tab: confirm NO call to https://staff.boreal.financial/api/required-docs
   unless the local /api/required-docs is actually down.
4) Upload remains disabled by default; enable by setting:
   VITE_DOC_UPLOAD_ENABLED=true  (then rebuild) 
NOTE

echo "Done. Reports in: $R"
```

---

### What this tells us / fixes

* If Step 5 was breaking for the **same reason as Step 2** (refresh → calls staff URL or SW-stale response), this makes required-docs **local-first**, provides a **staff fallback**, and finally a **static rules fallback** so users never see “0 docs” due to an endpoint blip.
* It removes any **duplicate/legacy Step 5 fetchers** so there’s only one source of truth (`client/src/api/docs.ts`).
* It keeps your **submission schema intact** (we didn’t touch submit guards), and uploads stay **off** unless you explicitly enable them.

If you want me to also surface a tiny on-screen Step 5 debug (instead of checking `window.__step5`), I can add it—but this block alone is enough to confirm whether Step 5 had the same issue and to fix it.
