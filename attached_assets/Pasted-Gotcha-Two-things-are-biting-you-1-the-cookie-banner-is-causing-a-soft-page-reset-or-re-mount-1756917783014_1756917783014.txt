Gotcha. Two things are biting you:

1. the cookie banner is causing a soft “page reset” (or re-mount) so your in-memory state disappears, the banner reappears, and your Step-1 values never make it to Step-2;
2. Step-2’s filter is reading ephemeral state (or reading it too early), so “Equipment Financing” and “Invoice Factoring” aren’t excluded even though Step-1 says they should be.

Here’s a tight fix set you can paste in. It **doesn’t** change your existing flows—just makes cookies, autosave, and Step-2 filtering solid.

---

# A) Cookie banner: persist + never reload

Create (or patch) a dedicated component so the banner **only** toggles localStorage/cookie and **does not** reload the page.

`client/src/components/CookieBanner.tsx`

```tsx
import { useEffect, useState } from "react";

const LS_KEY = "bf:cookieConsent"; // localStorage (persists across steps)

export default function CookieBanner() {
  const [open, setOpen] = useState(false);

  useEffect(() => {
    const v = localStorage.getItem(LS_KEY);
    setOpen(v !== "accepted" && v !== "declined");
  }, []);

  if (!open) return null;

  function accept() {
    try {
      localStorage.setItem(LS_KEY, "accepted");
      // also set a cookie for SSR/CDN if you need it — but DO NOT reload:
      document.cookie = "cookie_consent=accepted; path=/; max-age=31536000; SameSite=Lax";
    } catch {}
    setOpen(false);
  }
  function decline() {
    try {
      localStorage.setItem(LS_KEY, "declined");
      document.cookie = "cookie_consent=declined; path=/; max-age=31536000; SameSite=Lax";
    } catch {}
    setOpen(false);
  }

  return (
    <div className="fixed inset-x-0 bottom-0 z-50 bg-white border-t shadow p-4">
      <div className="max-w-5xl mx-auto flex items-center justify-between gap-3">
        <span className="text-sm">
          We use cookies to enhance your experience. Manage your preferences anytime.
        </span>
        <div className="flex gap-2">
          <button onClick={decline} className="px-3 py-2 rounded border">Decline Optional</button>
          <button onClick={accept} className="px-3 py-2 rounded bg-black text-white">Accept All Cookies</button>
        </div>
      </div>
    </div>
  );
}
```

Mount it once (root layout), **below** your router so it doesn’t cause remounts:

```tsx
// client/src/App.tsx (or your top layout)
import CookieBanner from "@/components/CookieBanner";
export default function App() {
  return (
    <>
      {/* ...your routes */}
      <CookieBanner />
    </>
  );
}
```

**Important:** search your codebase for any consent library calling `window.location.reload()` or setting `sandbox` on iframes that can re-mount the app; remove the reload.

---

# B) Autosave that survives banners & navigation

Add a tiny, robust autosave hook that writes to localStorage whenever Step-1 fields change and **flushes** on route change/tab hide.

`client/src/lib/useAutosave.ts`

```ts
import { useEffect, useRef } from "react";

export function useAutosave<T>(key: string, data: T, delay = 300) {
  const t = useRef<number | undefined>(undefined);
  const last = useRef<string>("");

  function writeNow(obj: T) {
    const s = JSON.stringify(obj);
    if (s === last.current) return;
    last.current = s;
    localStorage.setItem(key, s);
  }

  useEffect(() => {
    // debounce
    window.clearTimeout(t.current);
    // @ts-ignore
    t.current = window.setTimeout(() => writeNow(data), delay);
    return () => window.clearTimeout(t.current);
  }, [key, data, delay]);

  useEffect(() => {
    const flush = () => writeNow(data);
    window.addEventListener("visibilitychange", flush);
    window.addEventListener("pagehide", flush);
    return () => {
      window.removeEventListener("visibilitychange", flush);
      window.removeEventListener("pagehide", flush);
    };
  }, [data, key]);
}
```

Use it in Step-1:

```tsx
// client/src/routes/Step1_FinancialProfile_Complete.tsx
import { useAutosave } from "@/lib/useAutosave";

export default function Step1() {
  const [form, setForm] = useState<Step1Form>(/* existing init */);

  // 1) hydrate from previous autosave, once
  useEffect(() => {
    try {
      const raw = localStorage.getItem("bf:intake");
      if (raw) setForm(prev => ({ ...prev, ...JSON.parse(raw) }));
    } catch {}
  }, []);

  // 2) persist on every change
  useAutosave("bf:intake", form);

  // ...your inputs setForm({...}) as before
}
```

On the “Continue” button, **flush** and navigate:

```tsx
const onContinue = () => {
  try { localStorage.setItem("bf:intake", JSON.stringify(form)); } catch {}
  navigate("/apply/step-2");
};
```

Now the banner can appear/disappear and your values still rehydrate.

---

# C) Step-2 filtering that always uses the saved Step-1 values

Wire Step-2 to **read from localStorage** (not just in-memory) so it works even after a banner interaction.

`client/src/routes/apply/step-2/index.tsx`

```tsx
type Intake = {
  lookingFor?: string;
  accountsReceivableBalance?: string;
  fixedAssetsValue?: string;
  equipmentValue?: string;
  // add others if your rules need them
};

const EXCLUDE_FOR_LOOKING_FOR: Record<string, string[]> = {
  // adjust to your rules; you said when field 1 is “Capital” these should be hidden:
  Capital: ["Equipment Financing", "Invoice Factoring"],
  // e.g. Working Capital: ["Equipment Financing", "Invoice Factoring"],
};

function meetsFactoring(intake: Intake) {
  // Only offer factoring if AR balance > 0
  const v = (intake.accountsReceivableBalance || "").toString();
  return /[1-9]/.test(v); // naive: any non-zero option
}
function meetsEquipment(intake: Intake) {
  // Only offer equipment if there are assets/equipment values
  const a = (intake.fixedAssetsValue || "").toString();
  const e = (intake.equipmentValue || "").toString();
  return /[1-9]/.test(a + e);
}

export default function Step2() {
  const [intake, setIntake] = useState<Intake>({});
  const [products, setProducts] = useState<ProductSummary[]>([]); // your current list

  // hydrate from autosave
  useEffect(() => {
    try { setIntake(JSON.parse(localStorage.getItem("bf:intake") || "{}")); } catch {}
  }, []);

  const filtered = useMemo(() => {
    let list = products.slice();

    // 1) hide by “lookingFor”
    const excludes = EXCLUDE_FOR_LOOKING_FOR[intake.lookingFor || ""] || [];
    list = list.filter(p => !excludes.includes(p.categoryName));

    // 2) capability checks (only if item survived)
    list = list.filter(p => {
      if (p.categoryName === "Invoice Factoring") return meetsFactoring(intake);
      if (p.categoryName === "Equipment Financing") return meetsEquipment(intake);
      return true;
    });

    return list;
  }, [products, intake]);

  // render `filtered` instead of `products`
}
```

**Result:**

* If Step-1 says “Capital”, Step-2 won’t show Equipment Financing / Invoice Factoring.
* If the banner briefly re-mounts components, Step-2 still loads the saved intake and filters correctly.

---

# D) Bonus: make “Back” keep the banner hidden and values intact

* Banner hidden because we stored `bf:cookieConsent=accepted/declined` in localStorage and a cookie; it won’t reappear unless you clear storage.
* Step-1 rehydrates from `bf:intake` immediately and continues autosaving.

---

## Quick test script

1. Go to Step-1, fill “What are you looking for?” = **Capital** (and any other fields).
2. Click the cookie banner buttons — page should **not** reload.
3. Click “Continue” → Step-2 shows categories **without** Equipment Financing & Invoice Factoring.
4. Click “Back” → banner stays hidden; Step-1 inputs are still filled (autosaved).
5. Refresh the browser → Step-1 still filled from autosave; Step-2 still filtered.

If any of these fail, paste the console log you see after clicking the banner (especially anything like `window.location.reload` or sandbox errors), and I’ll adjust the snippet to your exact setup.
