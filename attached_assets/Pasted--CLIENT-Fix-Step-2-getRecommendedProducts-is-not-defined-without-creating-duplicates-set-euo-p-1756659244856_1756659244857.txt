# CLIENT — Fix Step 2 "getRecommendedProducts is not defined" without creating duplicates
set -euo pipefail
AUDIT_AT="$(date +%F_%H-%M-%S)"
R="reports/client-step2-fix-$AUDIT_AT"; TRASH=".trash-client-$AUDIT_AT"
mkdir -p "$R" "$TRASH"

note(){ echo "$1" | tee -a "$R/summary.txt"; }

echo "== 1) Locate current recommendation engine (prefer existing .ts) =="
ENGINE_CANDIDATES="$(rg -l --hidden -S '(getRecommendedProducts|Step2RecommendationEngine)' client/src | tr '\n' ' ')"
ENGINE_TS="$(echo "$ENGINE_CANDIDATES" | tr ' ' '\n' | grep -E '\.ts$' | head -n1 || true)"
ENGINE_PATH="${ENGINE_TS:-client/src/lib/recommendations/engine.ts}"
mkdir -p "$(dirname "$ENGINE_PATH")"
note "Engine will be: $ENGINE_PATH"

echo "== 2) Ensure we have ONE engine file, quarantine parallel .js/.mjs next to it =="
BASE_NO_EXT="${ENGINE_PATH%.*}"
for ext in js mjs; do
  f="${BASE_NO_EXT}.${ext}"
  if [ -f "$f" ]; then
    mkdir -p "$TRASH/$(dirname "$f")"
    mv "$f" "$TRASH/$f"
    note "Quarantined parallel engine $f -> $TRASH/$f"
  fi
done

echo "== 3) Create/patch engine to export both named & default and be input-order tolerant =="
node - <<'NODE'
const fs=require('fs'), path=process.env.ENGINE_PATH || 'client/src/lib/recommendations/engine.ts';
const hdr = `/* canonical recommendation engine (no duplicates); exports named+default */
import type { CanonicalProduct } from "../types"; // tolerate missing; TS will elide in JS builds

type AnyForm = Record<string, any>;
type Rec = CanonicalProduct & { score?: number };

function normalizeForm(raw: AnyForm) {
  const f = raw || {};
  const amount = Number(
    f.amountRequested ?? f.loanAmount ?? f.requestedAmount ?? f.amount ?? 0
  ) || 0;
  const country = String(
    f.country ?? f.countryCode ?? f.location?.country ?? ''
  ).toUpperCase().slice(0,2) || 'CA';
  const province = f.province ?? f.state ?? f.region ?? null;
  const industry = f.industry ?? f.naics ?? f.naicsCode ?? null;
  return { amount, country, province, industry, raw: f };
}

function pickProducts(form: ReturnType<typeof normalizeForm>, products: CanonicalProduct[] = []): Rec[] {
  const list = Array.isArray(products) ? products : [];
  const withinAmount = (p:any)=> {
    const min = Number(p.minAmount ?? 0) || 0;
    const max = Number(p.maxAmount ?? 9e12) || 9e12;
    return form.amount >= min && form.amount <= max;
  };
  const matchesCountry = (p:any)=>{
    const pc = String(p.country ?? p.countryCode ?? '').toUpperCase().slice(0,2);
    return !pc || pc === form.country;
  };
  const score = (p:any)=>{
    let s = 0;
    if (withinAmount(p)) s+=2;
    if (matchesCountry(p)) s+=2;
    if (form.industry && (p.industries?.includes?.(form.industry))) s+=1;
    return s;
  };
  return list
    .filter(p => withinAmount(p) && matchesCountry(p))
    .map(p => ({...p, score: score(p)}))
    .sort((a,b)=>(b.score||0)-(a.score||0));
}

/** Accept (form, products) or (products, form) defensively */
export function getRecommendedProducts(a:any,b:any): Rec[] {
  let form: any, products: any;
  if (Array.isArray(a)) { products = a; form = b; } else { form = a; products = b; }
  const nf = normalizeForm(form);
  const out = pickProducts(nf, products);
  try {
    if (typeof window !== 'undefined' && (window as any)) {
      (window as any).__step2 = { form: nf, inCount: Array.isArray(products)?products.length:0, outCount: out.length, sample: out.slice(0,3) };
    }
  } catch {}
  return out;
}
export default getRecommendedProducts;
`;

if (!fs.existsSync(path)) {
  fs.writeFileSync(path, hdr);
} else {
  let s=fs.readFileSync(path,'utf8');
  // Ensure a named export exists
  if (!/export\s+(async\s+)?function\s+getRecommendedProducts\b/.test(s) &&
      !/export\s+const\s+getRecommendedProducts\b/.test(s)) {
    s += `\n${hdr}\n`;
  } else {
    // Ensure default export also exists
    if (!/export\s+default\s+getRecommendedProducts\b/.test(s)) {
      s += `\nexport default getRecommendedProducts;\n`;
    }
  }
  // Make function tolerant to arg order if it's a simple pass-through
  if (/function\s+getRecommendedProducts\s*\(\s*form\s*,\s*products\s*\)/.test(s) &&
      !/Array\.isArray\(a\)/.test(s)) {
    // leave as-is; assume existing implementation
  }
  fs.writeFileSync(path,s);
}
NODE
ENGINE_PATH="$ENGINE_PATH" ENGINE_PATH="$ENGINE_PATH" ENGINE_PATH="$ENGINE_PATH"

echo "== 4) Fix Step 2 components that CALL the function but DON'T import it =="
# Any file that calls getRecommendedProducts( but lacks an import gets patched.
RG_MATCHES="$(rg -l --hidden -n 'getRecommendedProducts\\(' client/src --glob '!**/*.test.*' || true)"
if [ -n "$RG_MATCHES" ]; then
  echo "$RG_MATCHES" | while read -r f; do
    if ! rg -n 'import\\s+\\{?\\s*getRecommendedProducts\\s*\\}?\\s+from' "$f" >/dev/null; then
      # Insert import after first import line; fall back to top of file.
      if rg -n '^import\\s' "$f" >/dev/null; then
        awk -v ipath="$(node -e 'console.log(process.env.ENGINE_PATH || "client/src/lib/recommendations/engine")')" '
          NR==1{print;next}
          FNR==1{print}
          {print}
        ' "$f" > "$f.tmp"
        mv "$f.tmp" "$f"
        # Prepend the import cleanly at the top
        sed -i '1s;^;import { getRecommendedProducts } from "../lib/recommendations/engine";\n;' "$f"
        # If relative path is wrong, try a safer alias-free insert later (projects often use @/)
        if ! rg -n 'getRecommendedProducts' "$f" >/dev/null; then
          sed -i '1s;^;import { getRecommendedProducts } from "@/lib/recommendations/engine";\n;' "$f"
        fi
        note "Added missing import in: $f"
      else
        sed -i '1i import { getRecommendedProducts } from "@/lib/recommendations/engine";' "$f"
        note "Prepended import in: $f"
      fi
    fi
  done
else
  note "No call sites found — double-check Step 2 file path."
fi

echo "== 5) Ensure Step 2 uses (form, products) in either order safely =="
# Nothing to enforce here: engine already tolerates both (products, form) and (form, products).

echo "== 6) Quick check: only ONE engine file present (no duplicates) =="
ENGINE_COUNT="$(rg -l --hidden -S 'getRecommendedProducts' client/src | wc -l | tr -d ' ')"
echo "Engine occurrences in repo: $ENGINE_COUNT" | tee -a "$R/summary.txt"

echo "== 7) Build the client =="
if npm run -s build >/dev/null 2>&1; then
  note "Build: PASS"
else
  note "Build: FAIL — showing first errors"
  npm run build 2>&1 | tee "$R/build_error.txt" | head -60
  exit 1
fi

echo "== 8) Verification tips =="
echo "- In the browser console: window.__step2  (should show {form, inCount, outCount})" | tee -a "$R/verify.txt"
echo "- The Step 2 banner should disappear; recommendations should list." | tee -a "$R/verify.txt"

echo
echo "=== FINAL SUMMARY ==="
cat "$R/summary.txt" 2>/dev/null || true
echo "Reports: $R | Quarantined (safe): $TRASH"
