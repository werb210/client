Got it. Since I can’t click your app for you, here’s a **one-paste “full submission” runner** you can drop into the browser console of the client app. It:

* seeds Step 1 intake data,
* ensures Step 2 has a category selected,
* auto-fills Step 3 fields generically,
* takes you through Step 4,
* **pauses at Step 5 for you to upload documents**, and
* hooks `fetch` to **capture the Step 6 submission response** and print **success/failure**.

---

### 1) Paste this in the browser console (on any client app page)

```js
(async () => {
  const log = (...a)=>console.log('%c[FULL-SUBMIT]', 'color:#047857;font-weight:600', ...a);

  // --- A) Seed Step 1 (edit if you like) ---
  const intake = {
    amountRequested: 50000,
    country: 'CA',          // 'US' | 'CA'
    industry: 'construction',
    structure: 'corp'       // 'llc'|'corp'|'partnership'|'sole_prop'
  };
  localStorage.setItem('bf:intake', JSON.stringify(intake));
  log('Seeded Step 1 intake:', intake);

  // --- B) Hook submission to report success/failure ---
  const origFetch = window.fetch;
  window.__submitResult = null;
  window.fetch = async (...args) => {
    const [url, init] = args;
    const isSubmit = typeof url === 'string' && /\/api\/v1\/applications\b/.test(url) && (init?.method || 'GET').toUpperCase() === 'POST';
    if (isSubmit) {
      try {
        log('Submitting application… payload (preview):', JSON.parse(init?.body || '{}'));
      } catch {}
    }
    const res = await origFetch(...args);
    if (isSubmit) {
      let data = null;
      try { data = await res.clone().json(); } catch {}
      window.__submitResult = { ok: res.ok, status: res.status, data };
      const verdict = res.ok ? '✅ SUCCESS' : '❌ FAILURE';
      log(`${verdict} (status ${res.status})`, data);
    }
    return res;
  };

  // small helpers
  const go = (p)=>new Promise(r=>{ history.pushState({},'',p); window.dispatchEvent(new Event('popstate')); setTimeout(r, 500); });
  const clickContinue = () => {
    const btn = [...document.querySelectorAll('button, a')].find(b=>/continue/i.test(b.textContent||''));
    if (btn) btn.click();
  };

  // --- C) Step 2: ensure a category is selected (auto-pick top if needed) ---
  await go('/apply/step-2');
  const step2Key = 'bf:step2';
  if (!localStorage.getItem(step2Key)) {
    const cards = [...document.querySelectorAll('[data-step2-card]')];
    if (cards.length) {
      // assume top card = best match; click its button/hit area
      const top = cards[0].querySelector('button, .step2-hit, [role=button]') || cards[0];
      top.click();
      // if your app doesn’t write storage on click, force it:
      const categoryId = cards[0].getAttribute('data-step2-card') || 'invoice_factoring';
      const categoryLabel = (cards[0].querySelector('h3, [data-cat-label]')?.textContent || categoryId).trim();
      localStorage.setItem(step2Key, JSON.stringify({ categoryId, categoryLabel, matchScore: 95 }));
      log('Step 2 category set:', JSON.parse(localStorage.getItem(step2Key)));
    } else {
      log('⚠️ No Step 2 cards found – staying on page so you can click manually.');
      return;
    }
  } else {
    log('Step 2 category already set:', JSON.parse(localStorage.getItem(step2Key)));
  }
  clickContinue(); // go to Step 3

  // --- D) Step 3: generic auto-fill for inputs/selects/textarea ---
  await new Promise(r=>setTimeout(r, 600));
  (function fill() {
    document.querySelectorAll('input:not([type=file]):not([type=checkbox]):not([disabled])').forEach((el,i)=>{
      if (el.type==='email') el.value='owner@example.com';
      else if (el.type==='tel') el.value='555-555-1234';
      else if (el.type==='number') el.value = el.min ? el.min : (el.value || 1);
      else el.value = el.value || `Sample ${el.name || i}`;
      el.dispatchEvent(new Event('input',{bubbles:true}));
      el.dispatchEvent(new Event('change',{bubbles:true}));
    });
    document.querySelectorAll('select:not([disabled])').forEach((el)=>{
      const opt = [...el.options].find(o=>o.value) || el.options[0];
      if (opt) el.value = opt.value;
      el.dispatchEvent(new Event('change',{bubbles:true}));
    });
    document.querySelectorAll('textarea:not([disabled])').forEach((el,i)=>{
      el.value = el.value || 'Autofilled by test macro';
      el.dispatchEvent(new Event('input',{bubbles:true}));
      el.dispatchEvent(new Event('change',{bubbles:true}));
    });
  })();
  clickContinue(); // to Step 4 (review)

  // --- E) Step 4 → Step 5 ---
  await new Promise(r=>setTimeout(r, 600));
  clickContinue(); // to Step 5
  log('⏸ Paused at Step 5: please upload the required documents, then click “Continue to Final Submission”. This console will print SUCCESS/FAILURE when the POST /api/v1/applications returns.');

  // Note: after you upload & submit, watch for:
  //   [FULL-SUBMIT] ✅ SUCCESS (status 201) { id: "...", ... }
  // or [FULL-SUBMIT] ❌ FAILURE (status XXX) {...error...}
})();
```

**What you’ll see:**

* A green `[FULL-SUBMIT]` log stream in the console.
* It will **pause on Step 5** for you to upload.
* When you hit **Continue** (Step 6), the script will **capture the POST to `/api/v1/applications`** and log:

  * `✅ SUCCESS (status 200/201)` + the response (look for `id`, `status: "submitted"`, etc.), or
  * `❌ FAILURE` + error details.

---

### 2) (Optional) Fully automated Playwright smoke test

If you prefer a repeatable test (leaves Step 5 for your manual uploads), drop this into `client/tests/full-submit.spec.ts` and run `npx playwright test --headed`.

```ts
import { test, expect } from '@playwright/test';

test('Full submission flow until Step 5; capture final submission response', async ({ page }) => {
  // Seed Step 1 before any navigation
  await page.addInitScript(() => {
    localStorage.setItem('bf:intake', JSON.stringify({
      amountRequested: 50000, country: 'CA', industry: 'construction', structure: 'corp'
    }));
  });

  // Hook submission
  await page.addInitScript(() => {
    const origFetch = window.fetch;
    (window as any).__submitResult = null;
    window.fetch = async (...args) => {
      const [url, init] = args;
      const isSubmit = typeof url === 'string' && /\/api\/v1\/applications\b/.test(url) && (init?.method||'GET').toUpperCase()==='POST';
      const res = await origFetch(...args);
      if (isSubmit) {
        const data = await res.clone().json().catch(()=>null);
        (window as any).__submitResult = { ok: res.ok, status: res.status, data };
        console.log('[PLAYWRIGHT] SUBMISSION:', (window as any).__submitResult);
      }
      return res;
    };
  });

  // Step 2
  await page.goto('http://localhost:5000/apply/step-2');
  await page.waitForSelector('[data-step2-card]');
  // choose first (top match)
  await page.locator('[data-step2-card]').first().locator('button, .step2-hit, [role=button]').first().click();
  await page.getByRole('button', { name: /continue/i }).click();

  // Step 3
  // generic fill
  for (const sel of ['input:not([type=file]):not([type=checkbox])','textarea','select']) {
    const items = page.locator(sel);
    const count = await items.count();
    for (let i=0;i<count;i++) {
      const el = items.nth(i);
      if (sel.startsWith('input')) await el.fill('Sample');
      if (sel==='textarea') await el.fill('Autofilled by test');
      if (sel==='select') await el.selectOption({ index: 1 }).catch(()=>{});
    }
  }
  await page.getByRole('button', { name: /continue/i }).click(); // Step 4
  await page.getByRole('button', { name: /continue/i }).click(); // Step 5

  // Pause here for manual uploads, then continue and assert response:
  console.log('🟡 At Step 5. Upload documents manually, then click Continue to submit.');
  // The test will pass when a submission response is seen within 3 minutes:
  await expect.poll(async () => {
    return await page.evaluate(() => (window as any).__submitResult);
  }, { timeout: 180000, message: 'Waiting for submission response…' }).toMatchObject({ status: expect.any(Number) });
});
```

---

## What to send me

After you run the console macro (or the Playwright test):

* Paste the final console line that starts with `[FULL-SUBMIT]` (or `[PLAYWRIGHT] SUBMISSION:`)
  Example of a successful response:

  ```json
  {
    "ok": true,
    "status": 201,
    "data": { "id": "app_12345", "status": "submitted", "loanProductCategory": "invoice_factoring", ... }
  }
  ```
* If it fails, the error body will be printed — I’ll translate that into the minimal code/config fix.

This gives you a **single-run, observable** full submission that proves Step 1 + Step 2 → Step 5 → submission → staff API handoff, and tells us immediately whether it succeeded or why it didn’t.
