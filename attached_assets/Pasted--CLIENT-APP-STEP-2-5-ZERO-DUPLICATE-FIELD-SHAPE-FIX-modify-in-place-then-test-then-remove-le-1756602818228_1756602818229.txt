# CLIENT APP — STEP 2 & 5 ZERO-DUPLICATE FIELD/SHAPE FIX (modify in-place, then test, then remove legacy)
# What this does:
#   1) Patch existing Step-1→canonical adapter IN-PLACE (amount + country aliases).
#   2) Ensure Step 2 reads products via one fetcher and filters by Step-1 amount/country.
#   3) Ensure Step 5 consumes /required-docs regardless of shape (array | {required_documents}|{items}) and guards legacy fields.
#   4) Run deep tests. If PASS → quarantine legacy duplicates; if FAIL → no deletions.
# Env respected:
#   VITE_STAFF_API_URL (default https://staff.boreal.financial/api)
#   VITE_CLIENT_APP_SHARED_TOKEN

set -euo pipefail

TS="$(date +%F_%H-%M-%S)"
R="reports/client-step2-5-zero-dupe-$TS"; TRASH=".trash-client-$TS"
mkdir -p "$R" "$TRASH"
command -v rg >/dev/null || alias rg='grep -R'

# Locate existing candidates to avoid creating new files
FETCHER=""
for f in client/src/api/products.ts client/src/lib/api.ts client/src/api/index.ts; do [ -f "$f" ] && FETCHER="$f" && break; done
[ -z "$FETCHER" ] && FETCHER="client/src/api/products.ts"  # will create if truly missing

NORMALIZE=""
for f in client/src/api/normalize.ts client/src/lib/normalize.ts; do [ -f "$f" ] && NORMALIZE="$f" && break; done
[ -z "$NORMALIZE" ] && NORMALIZE="client/src/api/normalize.ts"

ADAPTER="client/src/domain/step1-adapter.ts"
mkdir -p "$(dirname "$ADAPTER")" "$(dirname "$FETCHER")" "$(dirname "$NORMALIZE")"

# 1) Patch/create normalize.ts (in-place)
if [ -f "$NORMALIZE" ]; then
  node - <<'NODE' "$NORMALIZE"
const fs=require('fs'), p=process.argv[2]; let s=fs.readFileSync(p,'utf8'), o=s, changed=false;
if(!s.includes('export type CanonicalProduct')){ s=`export type CanonicalProduct={id?:string|number;name:string;category:string;lenderName:string;country:string;minAmount:number;maxAmount:number;raw:any;};\n`+s; changed=true; }
if(!/export\s+const\s+toCanonical\s*=/.test(s)){
  s+=`\nconst num=(v:any,d=0)=>{const n=Number((v??'').toString().replace(/[$,_\\s]/g,''));return Number.isFinite(n)?n:d};\nconst up=(x:any)=> (x??'').toString().trim().toUpperCase();\nexport const toCanonical=(p:any)=>{const name=p.name??p.productName??p.title??\"\";const lenderName=p.lenderName??p.lender_name??p.lender??\"\";const cc=up(p.country??p.countryCode??p.region??\"\");const country=cc===\"CANADA\"?\"CA\":(cc===\"USA\"||cc===\"UNITED STATES\"?\"US\":(cc===\"US\"||cc===\"CA\"?cc:\"NA\"));const min=num(p.minAmount??p.min_amount??p.min??0,0);const mx=p.maxAmount??p.max_amount??p.max??null;const max=mx==null?Number.POSITIVE_INFINITY:num(mx,Number.POSITIVE_INFINITY);const category=p.category??p.type??\"Unknown\";return{ id:p.id,name,category,lenderName,country,minAmount:min,maxAmount:max,raw:p};};\n`; changed=true;
}
if(changed){fs.writeFileSync(p,s);console.log("Patched normalize:",p)}
NODE
else
  cat > "$NORMALIZE" <<'TS'
export type CanonicalProduct={id?:string|number;name:string;category:string;lenderName:string;country:string;minAmount:number;maxAmount:number;raw:any;};
const num=(v:any,d=0)=>{const n=Number((v??'').toString().replace(/[$,_\s]/g,''));return Number.isFinite(n)?n:d};
const up=(x:any)=> (x??'').toString().trim().toUpperCase();
export const toCanonical=(p:any)=>{const name=p.name??p.productName??p.title??"";const lenderName=p.lenderName??p.lender_name??p.lender??"";const cc=up(p.country??p.countryCode??p.region??"");const country=cc==="CANADA"?"CA":(cc==="USA"||cc==="UNITED STATES"?"US":(cc==="US"||cc==="CA"?cc:"NA"));const min=num(p.minAmount??p.min_amount??p.min??0,0);const mx=p.maxAmount??p.max_amount??p.max??null;const max=mx==null?Number.POSITIVE_INFINITY:num(mx,Number.POSITIVE_INFINITY);const category=p.category??p.type??"Unknown";return{ id:p.id,name,category,lenderName,country,minAmount:min,maxAmount:max,raw:p};};
TS
  echo "Created $NORMALIZE" | tee -a "$R/log.txt"
fi

# 2) Create/patch Step-1 adapter (in-place mapping for amount/country) used by Step 2 & 5
cat > "$ADAPTER" <<'TS'
export type Step1Canonical={amount:number;country:string};
const num=(v:any)=>{if(v==null)return 0;const s=(typeof v==='number')?String(v):String(v);const n=Number(s.replace(/[$,_\s]/g,''));return Number.isFinite(n)?n:0};
const cc=(v:any)=>{const s=(v??'').toString().trim().toUpperCase();if(!s)return"NA";if(["CA","CANADA"].includes(s))return"CA";if(["US","USA","UNITED STATES","U.S.","U.S.A."].includes(s))return"US";return s.length===2?s:"NA"};
export function normalizeStep1(d:any):Step1Canonical{
  const amount=num(d?.amountRequested)||num(d?.loanAmount)||num(d?.requestedAmount)||num(d?.requested_amount)||num(d?.amount)||num(d?.fundsNeeded)||num(d?.fundingAmount)||num(d?.loan_size)||0;
  const country=cc(d?.country)||cc(d?.countryCode)||cc(d?.applicantCountry)||cc(d?.region)||"NA";
  return{amount,country};
}
export function normalizeRequiredDocsShape(resp:any):string[]{ if(Array.isArray(resp))return resp; if(resp?.required_documents) return resp.required_documents; if(resp?.items) return resp.items; return []; }
TS

# 3) Patch FETCHER to expose fetchProducts(), fetchRequiredDocs(), getRecommendedProducts() (IN-PLACE)
if [ -f "$FETCHER" ]; then
  node - <<'NODE' "$FETCHER"
const fs=require('fs'); const p=process.argv[2]; let s=fs.readFileSync(p,'utf8'), o=s, changed=false;
const ensure=(needle, block)=>{ if(!new RegExp(needle).test(s)){ s+=`\n${block}\n`; changed=true; } };
ensure('\\bfetchProducts\\s*\\(', `
import { toCanonical } from "./normalize";
const BASES=[(import.meta.env.VITE_STAFF_API_URL||"https://staff.boreal.financial/api").replace(/\\/+$/,''),"http://localhost:5000/api"];
const TOKEN=(import.meta.env.VITE_CLIENT_APP_SHARED_TOKEN||""); const headers=TOKEN?{Authorization:\`Bearer \${TOKEN}\`}:{};
const norm=(d:any)=> Array.isArray(d)?d:(d.items||d.required_products||d.required_documents||[]);
export async function fetchProducts(){ for(const b of BASES){ try{ const r=await fetch(\`\${b}/v1/products\`,{headers,credentials:"include"}); if(r.ok) return norm(await r.json()); }catch{} } return []; }`);
ensure('\\bfetchRequiredDocs\\s*\\(', `
export async function fetchRequiredDocs(){ for(const b of BASES){ try{ const r=await fetch(\`\${b}/required-docs\`,{credentials:"include"}); if(r.ok){ const j=await r.json(); return Array.isArray(j)?j:(j.required_documents||j.items||[]);} }catch{} } return []; }`);
ensure('\\bgetRecommendedProducts\\s*\\(', `
function getStep1(){ try{ return JSON.parse(localStorage.getItem("formData")||"null")||{}; }catch{return{}} }
export async function getRecommendedProducts(){ const raw=await fetchProducts(); const list=raw.map(toCanonical); const s1:any=getStep1();
  const amt=Number(s1.amountRequested??s1.loanAmount??s1.requestedAmount??s1.requested_amount??s1.amount??s1.fundsNeeded??s1.fundingAmount??s1.loan_size??0)||0;
  const cc=(s1.country??s1.countryCode??s1.applicantCountry??s1.region??\"\").toString().toUpperCase(); const country=cc===\"CANADA\"?\"CA\":(cc===\"USA\"||cc===\"UNITED STATES\"?\"US\":cc);
  const matches=list.filter(p=>(!country||p.country===country)&&(!amt||(p.minAmount<=amt&&amt<=p.maxAmount))); return {all:list,matches}; }`);
if(changed){fs.writeFileSync(p,s);console.log("Patched fetcher:",p)}
NODE
else
  cat > "$FETCHER" <<'TS'
import { toCanonical } from "./normalize";
const BASES=[(import.meta.env.VITE_STAFF_API_URL||"https://staff.boreal.financial/api").replace(/\/+$/,''),"http://localhost:5000/api"];
const TOKEN=(import.meta.env.VITE_CLIENT_APP_SHARED_TOKEN||""); const headers=TOKEN?{Authorization:`Bearer ${TOKEN}`}:{};
const norm=(d:any)=> Array.isArray(d)?d:(d.items||d.required_products||d.required_documents||[]);
export async function fetchProducts(){ for(const b of BASES){ try{ const r=await fetch(`${b}/v1/products`,{headers,credentials:"include"}); if(r.ok) return norm(await r.json()); }catch{} } return []; }
export async function fetchRequiredDocs(){ for(const b of BASES){ try{ const r=await fetch(`${b}/required-docs`,{credentials:"i
