```txt
[CLIENT APP]

Goal: Fix blank screen + duplicate export errors. Ensure Step 2 & Step 5 load from ONE API surface and the app mounts correctly.

1) FILE: client/src/main.tsx  (REPLACE ENTIRE FILE)
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";
import "./index.css";

// IMPORTANT: no top-level await; load guard as a side-effect and ignore failures
import("./lib/fetch-guard").catch(console.warn);

ReactDOM.createRoot(document.getElementById("root")!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

2) FILE: client/src/lib/fetch-guard.ts  (CREATE/REPLACE – side-effect only)
(() => {
  // Put any fetch/interceptor/polyfill setup here.
  // Must not throw; keeps main bundle from failing at startup.
})();

3) FILE: client/src/lib/api.ts  (UNIFY & DEDUPE – PASTE BELOW AT TOP OF FILE, KEEPING ONLY ONE listDocuments/export)
export type CanonicalProduct = {
  id: string;
  name: string;
  lender_name: string;
  country: "US" | "CA" | string;
  category: string;
  min_amount: number;
  max_amount: number;
  active: boolean;
  required_documents?: RequiredDoc[];
  // keep optional rate/term fields if you already use them
};

export type IntakeInput = {
  amount: number;
  country: "US" | "CA" | string;
  timeInBusinessMonths?: number;
  monthlyRevenue?: number;
  creditScore?: number;
  category?: string;
};

export type RequiredDocsInput = {
  category?: string;
  country?: string;
  amount?: number;
  lenderId?: string;
  timeInBusinessMonths?: number;
  monthlyRevenue?: number;
  creditScore?: number;
};

export type RequiredDoc =
  | { key: string; label: string; required: boolean; reason?: string; months?: number }
  | string;

// ---- Canonical fetch with safe fallback (catalog → legacy) -----------------
export async function fetchCatalogProducts(): Promise<CanonicalProduct[]> {
  try {
    const r = await fetch("/api/catalog/export-products?includeInactive=1", { credentials: "include" });
    if (r.ok) {
      const j = await r.json();
      const items = j?.products ?? j ?? [];
      if (Array.isArray(items) && items.length) {
        return items.map((p: any) => ({
          id: p.id,
          name: p.name ?? p.productName,
          lender_name: p.lender_name ?? p.lenderName,
          country: String(p.country ?? p.countryOffered ?? "").toUpperCase(),
          category: p.category ?? p.productCategory ?? "Working Capital",
          min_amount: Number(p.min_amount ?? p.minimumLendingAmount ?? 0),
          max_amount: Number(p.max_amount ?? p.maximumLendingAmount ?? Number.MAX_SAFE_INTEGER),
          active: (p.active ?? p.isActive) !== false,
          required_documents: p.required_documents,
        }));
      }
    }
  } catch {/* fall back */}
  // Legacy fallback
  const r2 = await fetch("/api/lender-products", { credentials: "include" });
  const j2 = await r2.json();
  const items2 = j2?.products ?? [];
  return (items2 as any[]).map((p: any) => ({
    id: p.id,
    name: p.productName ?? p.name,
    lender_name: p.lenderName ?? p.lender_name,
    country: String(p.countryOffered ?? p.country ?? "").toUpperCase(),
    category: p.productCategory ?? p.category ?? "Working Capital",
    min_amount: Number(p.minimumLendingAmount ?? p.min_amount ?? 0),
    max_amount: Number(p.maximumLendingAmount ?? p.max_amount ?? Number.MAX_SAFE_INTEGER),
    active: (p.isActive ?? p.active) !== false,
    required_documents: p.required_documents,
  }));
}

// ---- Step 2: recommendations ------------------------------------------------
export type CategoryRecommendation = { category: string; products: CanonicalProduct[] };

export async function recommendProducts(intake: IntakeInput): Promise<CategoryRecommendation[]> {
  const all = await fetchCatalogProducts();
  const amt = intake.amount;
  const cc = String(intake.country).toUpperCase();

  const eligible = all.filter(p =>
    (p.country?.toUpperCase() === cc) &&
    p.active &&
    p.min_amount <= amt && amt <= p.max_amount
  );

  // simple score: closer max_amount is better
  const scored = eligible
    .map(p => ({ p, score: Math.abs((p.max_amount ?? Number.MAX_SAFE_INTEGER) - amt) }))
    .sort((a, b) => a.score - b.score)
    .map(s => s.p);

  const byCat = new Map<string, CanonicalProduct[]>();
  for (const p of scored) {
    const k = p.category || "Working Capital";
    if (!byCat.has(k)) byCat.set(k, []);
    byCat.get(k)!.push(p);
  }
  return Array.from(byCat.entries()).map(([category, products]) => ({ category, products }));
}

// ---- Step 5: required documents (Staff-first with guaranteed fallback) -----
const DOCS_FALLBACK: Record<string, RequiredDoc[]> = {
  "Working Capital": [
    { key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 },
  ],
  "Business Line of Credit": [
    { key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 },
  ],
  "Term Loan": [
    { key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 },
  ],
  "Equipment Financing": [
    { key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 },
  ],
  "Invoice Factoring": [
    { key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 },
  ],
  "Purchase Order Financing": [
    { key: "bank_6m", label: "Last 6 months bank statements", required: true, months: 6 },
  ],
};

export async function listDocuments(input: RequiredDocsInput): Promise<RequiredDoc[]> {
  try {
    const r = await fetch("/api/required-docs", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      credentials: "include",
      body: JSON.stringify(input),
    });
    if (r.ok) {
      const j = await r.json();
      const docs = j?.documents ?? j?.requiredDocs ?? j?.data ?? [];
      if (Array.isArray(docs) && docs.length) return docs as RequiredDoc[];
    }
  } catch { /* fall through */ }
  const cat = input.category ?? "Working Capital";
  return DOCS_FALLBACK[cat] ?? DOCS_FALLBACK["Working Capital"];
}

4) FILE: client/src/components/DynamicDocumentRequirements.tsx  (REPLACE EXPORT & NORMALIZATION ONLY)
import React from "react";
import { listDocuments, RequiredDoc } from "@/lib/api";

type Props = { category: string; country: string; amount: number };

export default function DynamicDocumentRequirements({ category, country, amount }: Props) {
  const [docs, setDocs] = React.useState<RequiredDoc[]>([]);
  React.useEffect(() => {
    listDocuments({ category, country, amount }).then(setDocs).catch(() => setDocs([]));
  }, [category, country, amount]);

  const items = (docs ?? []).map((d, i) =>
    typeof d === "string" ? { key: `doc_${i}`, label: d, required: true } : d
  );

  return (
    <ul className="space-y-2">
      {items.map((d: any) => (
        <li key={d.key} className="text-sm">
          <span className="font-medium">{d.label}</span>
          {d.required ? <span className="ml-2 text-red-600">(required)</span> : null}
        </li>
      ))}
    </ul>
  );
}

5) FILE: client/scripts/qa.sh  (NEW quick check – optional)
#!/usr/bin/env bash
set -e
echo "== Catalog (expects 200 via legacy fallback) =="; curl -sS /api/lender-products | jq '.products|length'
echo "== Recommendations (US $100k) =="; node -e 'import("./src/lib/api.ts").then(async m=>console.log((await m.recommendProducts({amount:100000,country:"US"})).map(x=>[x.category,x.products.length])))'
echo "== Docs fallback =="; curl -sS -X POST /api/required-docs -H 'Content-Type: application/json' -d '{"category":"Working Capital"}' | jq '.status? // "fallback"'


AFTER PASTE:
• Delete any older duplicates you may still have:
  - client/src/lib/catalog.ts
  - client/src/types/enhancedLenderProduct.ts
  - client/src/lib/finalizedLenderSync.ts
• npm run build && reload the browser.
```

```txt
[STAFF APP]

Goal: Stop 404s on Marketing → Google Ads and provide OAuth + accounts/campaigns + AI helpers (copy/audience/budget).

1) .env (ensure secrets exist)
GADS_DEVELOPER_TOKEN=__FILL_ME__
GADS_OAUTH_CLIENT_ID=__FILL_ME__
GADS_OAUTH_CLIENT_SECRET=__FILL_ME__
GADS_LOGIN_CUSTOMER_ID=__MANAGER_ID_NO_DASHES__
APP_BASE_URL=https://staff.boreal.financial
OPENAI_API_KEY=__FILL_ME__
# Optional
GADS_REFRESH_TOKEN=

2) FILE: server/boot.ts  (ADD MOUNT BEFORE STRICT AUTH)
import googleAds from "./routes/google-ads.mjs";
app.use(googleAds);

3) FILE: server/routes/google-ads.mjs  (CREATE – full OAuth + endpoints)
# Use the exact file provided in my previous message. Paste it verbatim.

4) Optional UI hook-up:
- Add a simple page at staff/src/pages/marketing/GoogleAds.tsx (from my previous message) and route:
  { path: "/staff/marketing/google-ads", element: <GoogleAds /> }

AFTER PASTE:
• Restart staff app. Visit /api/ads/google/status (should show {connected:false/true}).
• Click “Connect Google Ads Account” → complete OAuth → status becomes connected.
• /api/ads/google/accounts and /api/ads/google/campaigns?customerId=XXXX should return data.
• AI helpers: POST to /api/ads/google/ai/copy | /ai/audiences | /ai/budget.
```

**Why this fixes your blank screen + duplicates:**

* Removes the top-level `await` that blocked React from mounting.
* Enforces a single `listDocuments` + single canonical fetch path.
* Normalizes both legacy and catalog product shapes to avoid Step 2/5 drift.
* Staff Ads endpoints eliminate the 404 spam and enable the AI features you asked for.

If anything still throws in the console after this, tell me the first red error line and the file path—I’ll zero in on it.
