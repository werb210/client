You’re seeing two different problems at once:

1. **Your changes don’t show up (or show inconsistently).**
2. **A bunch of “new” features look broken because the UI is still running stale JS.**

The root cause is almost certainly **aggressive caching + a service worker** that’s still serving old build assets. I can see “Service worker registered” and repeated CSP notices in your client screenshot, and the staff app logs show requests hitting outdated routes (e.g., 500 on `/server/routes/support.ts`: “app.use is not a function” → that’s the *old* router signature). So even after you patch code, the browser is still running yesterday’s bundle.

Below is a focused fix + a clean test plan that exercises **everything we touched in the last \~8 hours** across both apps.

---

# A) Make changes display reliably (kill stale caches)

Do these once in **both apps** (client + staff):

### 1) One-time purge in your browser console (in the preview tab)

Paste and run:

```js
(async () => {
  for (const r of await navigator.serviceWorker.getRegistrations()) await r.unregister();
  const keys = await caches.keys(); await Promise.all(keys.map(k => caches.delete(k)));
  sessionStorage.clear(); localStorage.clear();
  location.reload(true);
})();
```

### 2) Disable the service worker in non-production

In your **main entry/client** (`client/src/main.tsx` or wherever you register it), guard SW:

```ts
if ('serviceWorker' in navigator) {
  if (import.meta.env.MODE !== 'production') {
    // Dev/staging: never keep a SW around
    navigator.serviceWorker.getRegistrations().then(regs => regs.forEach(r => r.unregister()));
  } else {
    navigator.serviceWorker.register('/sw.js', { scope: '/' });
  }
}
```

### 3) Serve `index.html` as **no-store** (prevents HTML from being cached)

In each app’s **Express** boot (client & staff):

```ts
app.use((req, res, next) => {
  // For HTML entrypoint only
  if (req.accepts('html') && req.method === 'GET' && !req.path.startsWith('/api/')) {
    res.setHeader('Cache-Control', 'no-store, must-revalidate');
  }
  next();
});

// Static assets can be cached safely:
app.use(express.static('dist/public', { maxAge: '7d', immutable: true }));
```

### 4) Add a visible build stamp so you *know* the page is new

Server:

```ts
const BUILD_ID = process.env.GIT_COMMIT || new Date().toISOString();
app.get('/__version', (_req, res) => res.json({ app: 'staff', build: BUILD_ID }));
```

Client header/footer: fetch `/__version` once and render `build` (e.g., “staff 2025-08-24T14:45Z”). If you don’t see it change after a deploy, you’re still cached.

---

# B) Quick fixes for recurring console errors (staff)

These are the ones I see in your screenshots:

* **`app.use is not a function`** from `server/routes/support.ts`
  You’re likely doing `app.use(support())` while `support` already exports a `Router`. Fix:

  ```ts
  import supportRouter from './routes/support';
  app.use('/api/support', supportRouter);  // no () if it exports a Router
  ```

  Or, if it *exports a function*, call it *and* pass `app`:

  ```ts
  import registerSupport from './routes/support';
  registerSupport(app);
  ```

* **401s in Communications tabs** (voicemail, talk-to-human)
  These are public webhooks / internal APIs being fetched without a token. Gate the fetches in the UI until `auth.ready === true`, and make sure your server auth bypass includes:

  ```
  /api/voice/*
  /api/public/applications
  ```

  …while keeping all staff-only UI behind `Authorization`.

* **WebSocket connection failed**
  You removed Socket.IO earlier (good). The remaining WS attempts come from old bundles. Once SW is disabled and HTML is no-store, these go away. Also grep for any lingering `io()` init in the staff UI and strip it.

---

# C) One-command smoke test for *everything we added today*

Create **`scripts/smoke.sh`** in each repo (client + staff) and run it. It prints PASS/FAIL in your Replit shell—no guessing from the UI.

```bash
#!/usr/bin/env bash
set -euo pipefail

BASE="${1:-http://localhost:5000}"

say() { printf "\n\033[1m%s\033[0m\n" "$*"; }
pass(){ echo "✅ $*"; }
fail(){ echo "❌ $*"; exit 1; }

say "1) Version + health"
curl -fsS "$BASE/__version" && pass "__version"
curl -fsS "$BASE/api/health"  && pass "health"

say "2) Public intake -> UUID -> card API"
APP_JSON=$(curl -fsS -X POST "$BASE/api/public/applications" \
  -H 'Content-Type: application/json' \
  -d '{"businessInformation":{"legalBusinessName":"SMOKE CORP"},
       "applicantInformation":{"firstName":"Smoke","lastName":"Test","email":"smoke@test.com"},
       "finance":{"requestedAmount":123000}}')
APP_ID=$(echo "$APP_JSON" | jq -r .applicationId)
[[ "$APP_ID" =~ ^[0-9a-f-]{36}$ ]] || fail "Invalid applicationId: $APP_ID"
pass "Public application created: $APP_ID"

CARD=$(curl -fsS "$BASE/api/pipeline/cards/$APP_ID/application")
BN=$(echo "$CARD" | jq -r '.application.businessName')
[[ "$BN" != "null" && -n "$BN" ]] || fail "Card API missing businessName"
pass "Card API has businessName: $BN"

say "3) Documents pipeline (presign -> upload -> list)"
PS=$(curl -fsS -X POST "$BASE/api/documents/presign" \
  -H 'Content-Type: application/json' \
  -d "{\"applicationId\":\"$APP_ID\",\"fileName\":\"bank.pdf\",\"contentType\":\"application/pdf\"}")
URL=$(echo "$PS" | jq -r .url); [[ "$URL" == http* ]] || fail "No presign URL"

# tiny test file
echo "%PDF-1.4 test" > /tmp/bank.pdf
curl -fsS -X PUT -H 'Content-Type: application/pdf' --data-binary @/tmp/bank.pdf "$URL" && pass "Uploaded to S3"

LIST=$(curl -fsS "$BASE/api/documents/$APP_ID")
COUNT=$(echo "$LIST" | jq '.items | length')
[[ "$COUNT" -ge 1 ]] && pass "Documents listed ($COUNT)" || fail "No documents listed"

say "4) Communications sanity"
# endpoints should exist (even if auth-protected they must 401, not 404/500)
curl -s -o /dev/null -w "%{http_code}" "$BASE/api/support/issues" | grep -Eq '200|401' || fail "/api/support/issues not mounted"
curl -s -o /dev/null -w "%{http_code}" "$BASE/api/voice/mailboxes" | grep -Eq '200|401' || fail "/api/voice/mailboxes not mounted"
pass "Comms routes mounted"

say "5) AI/chat handshake"
curl -s -o /dev/null -w "%{http_code}" "$BASE/api/chat/handshake" | grep -Eq '200|401' && pass "chat/handshake reachable" || fail "chat/handshake missing"

say "ALL CHECKS PASSED"
```

Run:

```
chmod +x scripts/smoke.sh
scripts/smoke.sh http://localhost:5000
```

> Do this in **staff** first (it hosts most APIs). In **client**, the script still works but some routes will proxy/501 depending on your wiring—that’s fine; we’re hunting 404/500.

---

# D) Feature-by-feature test map (last \~8 hours)

**Staff app**

* ✅ Public application intake mounted in `boot.ts` → **covered by smoke step 2**
* ✅ UUID normalization & schema mapping (legal\_business\_name / contact\_\* fields) → **step 2**
* ✅ Documents: presign/upload/list → **step 3**
* ✅ Dashboard switched to real data (KPIs/Stats/Activity) → Check `/api/v1/system/dashboard/*` return 200 in network tab
* ✅ Communications hub tabs render + global dialer button → after cache purge, look for the **“Open Dialer”** button; it should also appear when a contact is selected (we restored the floating FAB; if you still want the legacy bottom-right green FAB, I can drop it back in `Shell.tsx`)
* ✅ Voicemail/IVR mounting (401 if not authed, 200 if authed) → **step 4**
* ✅ “Talk to a Human” endpoints mounted (should not 404) → **step 4**

**Client app**

* ✅ Chatbot greets immediately and collects name/email/consent (local flow) → open page, verify the greeting appears *without* network
* ✅ CSRF-safe fetch wrapper → try asking a question; check POST includes `X-CSRF-Token` and `credentials: include`
* ✅ Security headers/CSP/XFO → `curl -I /api/health` and check `Content-Security-Policy` + `X-Frame-Options` (if you want A+)

---

# E) If the UI still looks “stuck”

Nine times out of ten it’s the SW/HTML cache. If it still happens after A), check:

* **Do you see a *new* build stamp** from `/__version` on the visible page? If not, you’re not looking at the new app.
* **Two routers bound to the same path.** You previously had `/api/public/applications` defined twice (boot.ts + route file). Remove the duplicate.
* **Guard your data fetches.** A lot of 401s are from calling protected endpoints before auth is ready. Only fetch after your auth hook settles.

---

# F) A couple of yes/no decisions I need from you

1. **Do you want the legacy floating green dialer FAB back on *every* staff page?**
   If yes, I’ll re-add the FAB to `Shell.tsx` so it’s omnipresent (and keep the “Open Dialer” button inside Communications too).

2. **Staging policy:** should we **permanently disable service workers** in staging (Replit) to avoid this class of issue?
   My default would be *yes* (dev/staging: SW off; prod: SW on).

Give me those two answers and I’ll ship the tiny code diffs. In the meantime, run the **cache purge** and the **smoke script**—you’ll immediately see which endpoints are green and where anything is still red.
