Got it — you want the **client app** de-duplicated so changes made in the form actually show up everywhere (other steps, review page, submit). Here’s a **minimal, safe** drop-in that gives you a **single source of truth** with aliasing, so old/duplicate keys all read/write the **same canonical field**. It won’t touch Step 2 recommender or Step 5 uploads.

---

# What you’ll add (4 tiny files)

## 1) `src/canonical/aliases.ts` — map all duplicate/legacy names → one canonical key

```ts
// One canonical key per concept (use these everywhere going forward)
export type CanonKey =
  // Step 1 – Financial
  | "country" | "industry" | "amount" | "useOfFunds"
  | "salesHistoryYears" | "annualRevenue" | "monthlyRevenue"
  | "accountsReceivableBalance" | "fixedAssetsValue" | "equipmentValue"
  // Step 2 – Product
  | "productCategory" | "productCategoryName" | "productId" | "productName" | "lenderName"
  // Step 3 – Business
  | "legalName" | "tradeName" | "businessStreet" | "businessCity" | "businessState" | "businessPostalCode"
  | "businessPhone" | "businessStartDate" | "businessStructure" | "employeeCount" | "businessWebsite"
  // Step 4 – Applicant
  | "applicantFirstName" | "applicantLastName" | "applicantEmail" | "applicantPhone"
  | "applicantAddress" | "applicantCity" | "applicantState" | "applicantPostalCode"
  | "applicantDob" | "applicantSsn" | "ownershipPercentage"
  | "hasPartner" | "partnerFirstName" | "partnerLastName" | "partnerEmail" | "partnerPhone"
  | "partnerAddress" | "partnerCity" | "partnerState" | "partnerPostalCode" | "partnerDob" | "partnerSsn" | "partnerOwnershipPercentage"
  // Step 5–7
  | "uploadedDocuments" | "signatureAccepted";

// For each canonical key, list every legacy/duplicate path we currently use.
// First hit wins. Extend this list if you discover more.
export const ALIASES: Record<CanonKey, string[]> = {
  // Step 1
  country: ["country", "businessLocation", "headquarters"],
  industry: ["industry", "formData.businessInfo.industry"],
  amount: ["amount", "fundingAmount", "requestedAmount", "loanAmount", "step1.requestedAmount"],
  useOfFunds: ["useOfFunds", "fundsPurpose", "purpose", "formData.businessInfo.useOfFunds"],
  salesHistoryYears: ["salesHistory", "yearsInBusiness"],
  annualRevenue: ["annualRevenue", "estimatedYearlyRevenue", "revenueLastYear", "last12moRevenue"],
  monthlyRevenue: ["monthlyRevenue", "avgMonthlyRevenue", "averageMonthlyRevenue"],
  accountsReceivableBalance: ["accountsReceivableBalance", "arBalance"],
  fixedAssetsValue: ["fixedAssetsValue", "fixedAssets"],
  equipmentValue: ["equipmentValue"],

  // Step 2
  productCategory: ["productCategory", "selectedCategory"],
  productCategoryName: ["productCategoryName", "selectedCategoryName"],
  productId: ["productId", "selectedProductId", "lenderProductId"],
  productName: ["productName", "selectedProductName"],
  lenderName: ["lenderName", "selectedLenderName"],

  // Step 3
  legalName: ["legalName", "businessName", "formData.businessInfo.legalName"],
  tradeName: ["tradeName", "operatingName"],
  businessStreet: ["businessStreet", "businessStreetAddress", "business.address.line1"],
  businessCity: ["businessCity", "business.address.city"],
  businessState: ["businessState", "headquartersState", "business.address.state"],
  businessPostalCode: ["businessPostalCode", "business.address.postal_code"],
  businessPhone: ["businessPhone"],
  businessStartDate: ["businessStartDate"],
  businessStructure: ["businessStructure"],
  employeeCount: ["employeeCount"],
  businessWebsite: ["businessWebsite", "website", "formData.businessInfo.website"],

  // Step 4
  applicantFirstName: ["applicantFirstName", "step4.firstName"],
  applicantLastName: ["applicantLastName", "step4.lastName"],
  applicantEmail: ["applicantEmail", "step4.email"],
  applicantPhone: ["applicantPhone", "step4.phone"],
  applicantAddress: ["applicantAddress"],
  applicantCity: ["applicantCity"],
  applicantState: ["applicantState"],
  applicantPostalCode: ["applicantPostalCode", "applicantZipCode"],
  applicantDob: ["applicantDob", "applicantDateOfBirth"],
  applicantSsn: ["applicantSsn", "applicantSSN"],
  ownershipPercentage: ["ownershipPercentage"],
  hasPartner: ["hasPartner"],
  partnerFirstName: ["partnerFirstName"],
  partnerLastName: ["partnerLastName"],
  partnerEmail: ["partnerEmail"],
  partnerPhone: ["partnerPhone"],
  partnerAddress: ["partnerAddress"],
  partnerCity: ["partnerCity"],
  partnerState: ["partnerState"],
  partnerPostalCode: ["partnerPostalCode", "partnerZipCode"],
  partnerDob: ["partnerDob", "partnerDateOfBirth"],
  partnerSsn: ["partnerSsn", "partnerSSN"],
  partnerOwnershipPercentage: ["partnerOwnershipPercentage"],

  // Step 5–7
  uploadedDocuments: ["uploadedDocuments", "formData.documents"],
  signatureAccepted: ["signatureAccepted", "termsAccepted", "signed"]
};
```

## 2) `src/canonical/utils.ts` — resolve any path + presence check

```ts
export function deepGet(obj: any, path: string) {
  return path.split(".").reduce((a, k) => (a && a[k] !== undefined ? a[k] : undefined), obj);
}
export function present(v: any) {
  if (v === null || v === undefined) return false;
  if (typeof v === "string") return v.trim().length > 0;
  if (Array.isArray(v)) return v.length > 0;
  if (typeof v === "number") return !Number.isNaN(v);
  if (typeof v === "object") return Object.keys(v).length > 0;
  return !!v;
}
```

## 3) `src/canonical/store.ts` — single source of truth (Zustand; 30 lines)

```ts
import { create } from "zustand";
import { persist } from "zustand/middleware";
import type { CanonKey } from "./aliases";
import { ALIASES } from "./aliases";
import { deepGet, present } from "./utils";

type CanonData = Partial<Record<CanonKey, any>>;

type CanonState = {
  data: CanonData;
  get: <T = any>(key: CanonKey, ...sources: any[]) => T | undefined;
  set: (key: CanonKey, value: any) => void;
  setMany: (kv: CanonData) => void;
};

export const useCanon = create<CanonState>()(
  persist(
    (set, get) => ({
      data: {},
      get: (key, ...sources) => {
        const state = get().data;
        if (present(state[key])) return state[key];
        for (const path of ALIASES[key] || []) {
          for (const src of sources) {
            const v = deepGet(src, path);
            if (present(v)) return v;
          }
        }
        return undefined;
      },
      set: (key, value) => set(s => ({ data: { ...s.data, [key]: value } })),
      setMany: (kv) => set(s => ({ data: { ...s.data, ...kv } }))
    }),
    { name: "bf:canonical" }
  )
);
```

## 4) `src/canonical/hook.ts` — plug into existing steps with 1 line per input

```ts
import { useCanon } from "./store";
import type { CanonKey } from "./aliases";

/** Use in any component:
 *  const [val, setVal] = useCanonField('legalName', legacySourceObj);
 */
export function useCanonField<T = any>(key: CanonKey, ...legacySources: any[]) {
  const get = useCanon(s => s.get);
  const set = useCanon(s => s.set);
  const value = get<T>(key, ...legacySources);
  const setter = (v: T) => set(key, v);
  return [value as T, setter] as const;
}
```

---

# How to integrate (no big refactor)

1. **Bootstrap once** (e.g., in `src/main.tsx`):

```ts
import { useCanon } from "@/canonical/store";
import { ALIASES } from "@/canonical/aliases";
import { deepGet, present } from "@/canonical/utils";

// Optional: initial hydrate from your existing localStorage slices
(() => {
  try {
    const ls = (k:string) => JSON.parse(localStorage.getItem(k) || "{}");
    const sources = [ls("bf:intake"), ls("bf:step2"), ls("bf:step3"), ls("bf:step4"), ls("bf:docs"), (window as any).__APP_STATE__ || {}];
    const setMany = useCanon.getState().setMany;
    const seed: any = {};
    (Object.keys(ALIASES) as (keyof typeof ALIASES)[]).forEach((canon) => {
      for (const p of ALIASES[canon]) {
        const val = sources.map(s => deepGet(s, p)).find(present);
        if (present(val)) { seed[canon] = val; break; }
      }
    });
    setMany(seed);
  } catch {}
})();
```

2. **Update inputs** gradually (one line each), e.g. in Step 3:

```tsx
import { useCanonField } from "@/canonical/hook";

// inside component (pass any legacy object you already have)
const [legalName, setLegalName] = useCanonField("legalName", formState, formData?.businessInfo);
<input value={legalName || ""} onChange={e => setLegalName(e.target.value)} />
```

Do the same for `amount`, `annualRevenue`, `monthlyRevenue`, `legalName`, `tradeName`, addresses, contact fields, etc.
You can roll this change out step-by-step; the canonical store unifies reads/writes so **changes appear everywhere** immediately.

3. **Keep Step 2 & Step 5 untouched**

* Product recommender continues to read its own state; for display/submit, read canonical via `useCanon.get('productId', step2State)`.
* Document upload stays as-is (FormData → `/v1/applications/:id/docs`). If you store document metadata in state, mirror the types into `uploadedDocuments` canonical key once per upload completion.

4. **Submit payload** (no breaking change) – derive from canonical keys:

```ts
import { useCanon } from "@/canonical/store";

// wherever you prepare the submit payload
const c = useCanon.getState().data;
const payload = {
  product_id: c.productId,
  country: c.country,
  amount: c.amount,
  years_in_business: c.salesHistoryYears,             // or compute from startDate
  monthly_revenue: c.monthlyRevenue,
  business_legal_name: c.legalName,
  industry: c.industry,
  contact_name: [c.applicantFirstName, c.applicantLastName].filter(Boolean).join(" "),
  contact_email: c.applicantEmail,
  contact_phone: c.applicantPhone,
  documents: (c.uploadedDocuments || []).map((d:any)=>({ type: d.type, url: d.url }))
};
// (optional) add lossless snapshot if you want:
const body = { ...payload, payload: c, formFields: c };
```

---

# Sanity checks (quick)

* On any step, open DevTools console:

```js
const c = JSON.parse(localStorage.getItem('bf:canonical')||'{}');
console.log('canonical keys', Object.keys(c).length, c);
```

* Change `legalName` in Step 3 → switch to review/submit → the value should match, because all reads now come from the same canonical key.

---

# Why your changes didn’t appear before (root cause)

* Different steps were reading/writing **different keys** for the same concept (e.g., `fundingAmount` vs `requestedAmount` vs `amount`; `avgMonthlyRevenue` vs `monthlyRevenue`; `legalName` vs `businessName`, etc.).
* This adapter eliminates that by **always resolving to and writing** the canonical key, while still understanding old names via `ALIASES`.

---

If you paste your **final preferred names** (camelCase) for any fields I guessed, I’ll tweak `ALIASES` so it matches your exact model.
