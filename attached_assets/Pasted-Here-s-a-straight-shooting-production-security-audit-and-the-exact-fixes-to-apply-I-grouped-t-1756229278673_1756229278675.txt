Here‚Äôs a straight-shooting **production + security audit** and the exact fixes to apply. I grouped them by urgency, gave code you can paste, and included quick verification commands.

---

# üî¥ Blockers (fix before exposing to users)

### 1) Hardcoded admin login

**Found:** `server/routes/auth.ts` checks `email === "todd.w@boreal.financial" && password === "admin123"`.

**Fix (use env + hashed password):**

```ts
// server/routes/auth.ts
import { Router } from 'express';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { z } from 'zod';

const router = Router();

const ADMIN_EMAIL = process.env.ADMIN_EMAIL!;
const ADMIN_PASSWORD_HASH = process.env.ADMIN_PASSWORD_HASH!; // bcrypt hash
const JWT_PRIVATE_KEY = (process.env.JWT_PRIVATE_KEY || '').replace(/\\n/g, '\n');

const loginSchema = z.object({ email: z.string().email(), password: z.string().min(8) });

router.post('/auth/login', async (req, res) => {
  const parsed = loginSchema.safeParse(req.body);
  if (!parsed.success) return res.status(400).json({ error: 'invalid_input' });

  const { email, password } = parsed.data;
  const ok = email === ADMIN_EMAIL && (await bcrypt.compare(password, ADMIN_PASSWORD_HASH));
  if (!ok) return res.status(401).json({ error: 'invalid_credentials' });

  const payload = { sub: email, role: 'admin' };
  const token = jwt.sign(payload, JWT_PRIVATE_KEY || process.env.JWT_SECRET!, {
    algorithm: JWT_PRIVATE_KEY ? 'RS256' : 'HS256',
    issuer: 'bf.staff',
    audience: 'bf.staff.web',
    expiresIn: '15m',
  });

  res.cookie('bf_auth', token, {
    httpOnly: true,
    secure: true,
    sameSite: 'lax',
    path: '/',
    maxAge: 15 * 60 * 1000,
  });
  res.json({ token }); // keep for SPA header auth too
});

export default router;
```

**Rotate & set env:**

* Generate bcrypt hash: `node -e "console.log(require('bcryptjs').hashSync(process.argv[1], 12))" 'STRONG_PASSWORD'`
* Set secrets: `ADMIN_EMAIL`, `ADMIN_PASSWORD_HASH`, **either** `JWT_SECRET` (32+ chars) **or** `JWT_PRIVATE_KEY`/`JWT_PUBLIC_KEY` (PEM).

> Also **re-enable MFA in prod**: set `REQUIRE_MFA_FOR_ALL=true` and remove any bypass flags you used for debugging.

---

### 2) Exposed API keys / secrets

If any real keys are in `.env` or code, **rotate immediately** (OpenAI, AWS, Sendgrid, Twilio, etc.), store in your secrets manager, and **remove from repo**. Use least-privilege IAM policies for cloud keys.

---

### 3) Environment mismatch

**Found:** `NODE_ENV=development` while running in a production-like context.

**Fix:** set `NODE_ENV=production` for deploys and start with:

```
npm ci --omit=dev
npm run build    # client + server build as applicable
node server/index.js
```

(Or your PM2/Procfile equivalent.)

---

# üü° High priority hardening (next 24‚Äì72h)

### 4) Rate limiting & brute-force protection

```ts
// server/index.ts
import rateLimit from 'express-rate-limit';

// Per-endpoint limits
app.use('/api/auth/login', rateLimit({ windowMs: 15 * 60 * 1000, max: 20, standardHeaders: true, legacyHeaders: false }));
app.use('/api/', rateLimit({ windowMs: 60 * 1000, max: 240 }));
```

### 5) Security headers (helmet), CORS & proxy

```ts
import helmet from 'helmet';
import cors from 'cors';

app.set('trust proxy', 1); // if behind proxy
app.use(helmet({
  crossOriginResourcePolicy: { policy: 'same-site' },
  contentSecurityPolicy: {
    useDefaults: true,
    directives: {
      'script-src': ["'self'"],
      'connect-src': ["'self'", 'https://staff.boreal.financial'], // add API origins you call
    },
  },
}));
app.use(cors({ origin: ['https://yourdomain.tld', /\.replit\.dev$/], credentials: true }));
```

### 6) Input validation everywhere

Use Zod (as above for login) for any POST/PUT/PATCH; reject on invalid payloads. Never `JSON.parse` responses without checking `content-type` first (you already added an HTTP guard‚Äîthat‚Äôs good).

### 7) Disable debug/diagnostic endpoints in prod

Remove or guard any `/api/_diag/*` and MFA bypass flags. Return **minimal** info on `/healthz`.

### 8) Logging hygiene

* Replace `console.log/error` with a structured logger (pino/winston).
* **Redact** tokens, auth codes, PII.
* Do not log 3rd-party credentials or full request bodies.

### 9) Dependency hygiene

* `npm audit --production` and patch.
* Pin versions where feasible.
* At deploy: `npm ci --omit=dev`.

---

# üü¢ Nice-to-have (this week)

* **JWT improvements:** Prefer RS256 (keypair) over HS256; rotate keys quarterly; keep token lifetime short (15‚Äì30m) and use refresh if needed.
* **TLS/HSTS:** terminate HTTPS at your edge; set `Strict-Transport-Security: max-age=31536000; includeSubDomains`.
* **DB least privilege:** connection user limited to the schema you need; no superuser. Ensure ORM (Drizzle) for all queries.
* **Source maps:** disable in prod builds or host behind auth.
* **Duplicate/Drift guards:** keep your duplicate-file detector in pre-commit/pre-deploy. Fail CI on collisions and on banned strings (`admin123`, `MFA_BYPASS`, etc.).

Example CI guard (put in `scripts/ci-guard.sh`, run in CI):

```bash
#!/usr/bin/env bash
set -euo pipefail

echo "üîé Guard: secrets & anti-patterns"
! git grep -nE 'admin123|MFA_BYPASS|JWT_SECRET\s*=\s*["'\''].*["'\'']' -- . ':!node_modules' || { echo "‚ùå Banned string found"; exit 1; }

echo "üîé Guard: console logs"
! git grep -nE 'console\.(log|error)\(' -- server ':!**/*.test.*' || { echo "‚ùå console.* in server code"; exit 1; }

echo "üîé Guard: duplicate basenames"
dups=$(find client/src -type f \( -iname '*.ts' -o -iname '*.tsx' -o -iname '*.js' -o -iname '*.jsx' \) -printf '%f\n' | tr '[:upper:]' '[:lower:]' | sort | uniq -d | wc -l)
[ "$dups" -eq 0 ] || { echo "‚ùå duplicate basenames detected"; exit 1; }
echo "‚úÖ Guards passed"
```

---

## Quick verification commands (run now)

**Auth path returns JSON (not HTML):**

```bash
curl -s -i http://localhost:5000/api/auth/login | sed -n '1p;/content-type/p'
```

**API returns JSON (guard working):**

```bash
curl -s -i http://localhost:5000/api/reports/summary | sed -n '1p;/content-type/p'
```

**Rate limit works:**

```bash
for i in {1..25}; do curl -s -o /dev/null -w "%{http_code}\n" http://localhost:5000/api/auth/login; done
# Expect 429 after limit
```

**No diagnostic endpoints exposed:**

```bash
curl -s -o /dev/null -w "%{http_code}\n" http://localhost:5000/api/_diag/routes
# Expect 404/401 in prod
```

---

## Deployment checklist (copy/pin)

* [ ] `NODE_ENV=production`
* [ ] `ADMIN_EMAIL`, `ADMIN_PASSWORD_HASH` set (bcrypt hash)
* [ ] `JWT_PRIVATE_KEY` / `JWT_PUBLIC_KEY` **or** strong `JWT_SECRET`
* [ ] `REQUIRE_MFA_FOR_ALL=true` (and MFA verified end-to-end)
* [ ] Secrets rotated & stored in your secrets manager (not committed)
* [ ] `npm ci --omit=dev && npm run build`
* [ ] Helmet + CORS + rate-limit enabled
* [ ] CI guard for duplicates / banned strings passing
* [ ] Remove/disable `_diag` and any bypass flags

If you want, paste the current `server/index.ts` middleware stack (top of file) and I‚Äôll inline the exact `helmet/cors/rateLimit` placement for your app layout.
