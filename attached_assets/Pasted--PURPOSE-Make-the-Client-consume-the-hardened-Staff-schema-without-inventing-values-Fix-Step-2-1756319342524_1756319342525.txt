# PURPOSE
# Make the Client consume the hardened Staff schema without inventing values.
# Fix Step 2 (recommendations) and Step 5 (docs) so country/category/amounts
# are honored, and submission payloads include required fields.

set -euo pipefail

echo "== 1) Single source fetch (no US defaults, prefer v1, fallback legacy) =="
mkdir -p client/src/lib
cat > client/src/lib/products.ts <<'TS'
export type CanonicalProduct = {
  id: string;
  name: string;             // from productName/name
  lender_name?: string|null;
  country: "CA"|"US"|null;
  category: string|null;
  min_amount: number|null;
  max_amount: number|null;
  active: boolean;
  required_documents: string[];
  min_time_in_business: number|null;
  min_monthly_revenue: number|null;
  excluded_industries?: string[]|null;
};

function normCountry(x:any): "CA"|"US"|null {
  const v = (x??"").toString().trim().toUpperCase();
  return v==="CA"||v==="US" ? v as any : null;
}

function toCanonicalFromV1(p:any): CanonicalProduct {
  return {
    id: p.id,
    name: p.productName ?? p.name ?? "",
    lender_name: p.lenderName ?? null,
    country: normCountry(p.countryOffered ?? p.country),
    category: p.productCategory ?? p.category ?? null,
    min_amount: p.minimumLendingAmount ?? p.min_amount ?? null,
    max_amount: p.maximumLendingAmount ?? p.max_amount ?? null,
    active: (p.isActive ?? p.active ?? true) === true,
    required_documents: Array.isArray(p.required_documents) ? p.required_documents : [],
    min_time_in_business: p.min_time_in_business ?? null,
    min_monthly_revenue: p.min_monthly_revenue ?? null,
    excluded_industries: Array.isArray(p.excluded_industries) ? p.excluded_industries : null,
  };
}

function toCanonicalFromLegacy(p:any): CanonicalProduct {
  return {
    id: p.id,
    name: p.name ?? p.productName ?? "",
    lender_name: p.lender_name ?? p.lenderName ?? null,
    country: normCountry(p.country ?? p.countryOffered),
    category: p.category ?? p.productCategory ?? null,
    min_amount: p.min_amount ?? p.minimumLendingAmount ?? null,
    max_amount: p.max_amount ?? p.maximumLendingAmount ?? null,
    active: (p.active ?? p.isActive ?? true) === true,
    required_documents: Array.isArray(p.required_documents) ? p.required_documents : [],
    min_time_in_business: p.min_time_in_business ?? null,
    min_monthly_revenue: p.min_monthly_revenue ?? null,
    excluded_industries: Array.isArray(p.excluded_industries) ? p.excluded_industries : null,
  };
}

export async function fetchProducts(): Promise<CanonicalProduct[]> {
  // 1) try v1 (preferred)
  try {
    const r = await fetch("/api/v1/products", { credentials: "include" });
    if (r.ok) {
      const j = await r.json();
      if (Array.isArray(j)) {
        return j.map(toCanonicalFromV1);
      }
    }
  } catch {}
  // 2) fallback legacy
  const r2 = await fetch("/api/lender-products", { credentials: "include" });
  if (!r2.ok) throw new Error("Failed to load products");
  const j2 = await r2.json();
  const list = Array.isArray(j2?.products) ? j2.products : [];
  return list.map(toCanonicalFromLegacy);
}
TS

echo "== 2) Step 2 Recommendation: respect country/amount + business rules =="
cat > client/src/lib/recommend.ts <<'TS'
import type { CanonicalProduct } from "./products";

export type Intake = {
  country: "CA"|"US";
  amount: number;
  timeInBusinessMonths?: number;
  monthlyRevenue?: number;
  categoryPreference?: string|null; // optional
};

export function recommend(intake: Intake, products: CanonicalProduct[]) {
  const eligible = products.filter(p => {
    if (!p.active) return false;
    if ((p.country ?? intake.country) !== intake.country) return false;
    if (p.min_amount != null && intake.amount < p.min_amount) return false;
    if (p.max_amount != null && intake.amount > p.max_amount) return false;
    if (p.min_time_in_business != null && (intake.timeInBusinessMonths ?? 0) < p.min_time_in_business) return false;
    if (p.min_monthly_revenue != null && (intake.monthlyRevenue ?? 0) < p.min_monthly_revenue) return false;
    return true;
  });

  const scored = eligible.map(p => {
    const dist =
      (p.min_amount!=null && intake.amount < p.min_amount) ? (p.min_amount - intake.amount) :
      (p.max_amount!=null && intake.amount > p.max_amount) ? (intake.amount - p.max_amount) : 0;
    const catBonus = (intake.categoryPreference && p.category === intake.categoryPreference) ? -1000 : 0;
    return { p, score: dist + catBonus };
  }).sort((a,b)=>a.score-b.score);

  // group by category for UI
  const byCat = new Map<string, CanonicalProduct[]>();
  for (const {p} of scored) {
    const k = p.category ?? "Uncategorized";
    if (!byCat.has(k)) byCat.set(k, []);
    byCat.get(k)!.push(p);
  }
  return { eligible: scored.map(x=>x.p), byCategory: byCat };
}
TS

echo "== 3) Step 5 Required Docs: use product.required_documents first =="
cat > client/src/lib/requiredDocs.ts <<'TS'
import type { CanonicalProduct } from "./products";

const FALLBACK: Record<string,string[]> = {
  "Equipment Financing": ["Equipment Quote","Bank Statements (6 months)","Business Tax Returns"],
  "Business Line of Credit": ["Bank Statements (6 months)","Financial Statements","Business Tax Returns"],
  "Working Capital": ["Bank Statements (6 months)","Financial Statements","Cash Flow Statement"],
  "Term Loan": ["Bank Statements (6 months)","Business Tax Returns","Financial Statements"],
  "Invoice Factoring": ["A/R Aging","Bank Statements (3–6 months)","Customer List"],
  "Purchase Order Financing": ["Purchase Order(s)","Supplier Quote","Bank Statements (3–6 months)"],
};

export function docsFor(product: CanonicalProduct): string[] {
  if (product.required_documents && product.required_documents.length) return product.required_documents;
  const key = product.category ?? "Working Capital";
  return FALLBACK[key] ?? ["Bank Statements (6 months)", "Business Tax Returns"];
}
TS

echo "== 4) Submission payload: send selected product + answers cleanly =="
cat > client/src/lib/submitApplication.ts <<'TS'
import type { CanonicalProduct } from "./products";

export type ApplicationPayload = {
  applicant: { name: string; email: string; phone?: string };
  business: { legalName: string; country: "CA"|"US"; monthlyRevenue?: number; timeInBusinessMonths?: number };
  request: { amount: number; category?: string|null };
  product: Pick<CanonicalProduct,"id"|"name"|"lender_name"|"country"|"category"|"min_amount"|"max_amount">;
  documents: Array<{ key:string; url?:string; filename?:string }>;
};

export async function submitApplication(apiBase:string, token:string|undefined, payload: ApplicationPayload) {
  const r = await fetch(`${apiBase}/api/applications`, {
    method: "POST",
    headers: { "Content-Type":"application/json", ...(token?{Authorization:`Bearer ${token}`}:{}) },
    body: JSON.stringify(payload),
    credentials: "include"
  });
  if (!r.ok) throw new Error(`Submission failed: ${r.status}`);
  return r.json();
}
TS

echo "== 5) QA smoke (3 cases; adjust as needed) =="
node - <<'NODE'
(async()=>{
  const v1 = await fetch("http://localhost:5000/api/v1/products").then(r=>r.ok?r.json():[]);
  const legacy = await fetch("http://localhost:5000/api/lender-products").then(r=>r.ok?r.json():{products:[]});
  console.log("V1 count:", Array.isArray(v1)?v1.length:0);
  console.log("Legacy count:", legacy?.total ?? legacy?.products?.length ?? 0);
})();
NODE

echo "== DONE (Client) =="
