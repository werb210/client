Got it ‚Äî let‚Äôs lock the **client** audit into CI and make it fail-safe with a strict mode (no `package.json` edits needed).

---

# üß± OIB ‚Äî Client Audit: CI Guard + Strict Mode (No package.json edits)

**GLOBAL RULES:** non-destructive; prod-safe; no new endpoints; S3-only docs; zero bypasses; show console output.

## CLIENT APPLICATION

### Files touched

* `scripts/client-audit.sh` **(replace with strict-capable version)**
* `scripts/ci-run-client-audit.sh` **(new)**
* `.github/workflows/client-audit.yml` **(new)**

---

## 1) Replace `scripts/client-audit.sh` (adds strict mode + extra checks)

> Overwrite the file with this exact content.

```bash
#!/usr/bin/env bash
# scripts/client-audit.sh
set -euo pipefail

# Strict mode: set AUDIT_STRICT=1 to fail on warnings
STRICT="${AUDIT_STRICT:-0}"

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
SRC="$ROOT_DIR/client/src"
DIST_ROOT_A="$ROOT_DIR/dist/public/assets"
DIST_ROOT_B="$ROOT_DIR/dist/assets"
DIST_HTML_A="$ROOT_DIR/dist/public/index.html"
DIST_HTML_B="$ROOT_DIR/dist/index.html"

DIST=""
INDEX_HTML=""
if [[ -d "$DIST_ROOT_A" ]]; then DIST="$DIST_ROOT_A"; INDEX_HTML="$DIST_HTML_A";
elif [[ -d "$DIST_ROOT_B" ]]; then DIST="$DIST_ROOT_B"; INDEX_HTML="$DIST_HTML_B";
elif [[ -d "$ROOT_DIR/dist" ]]; then DIST="$ROOT_DIR/dist"; INDEX_HTML="$DIST_HTML_B";
fi

ok(){ printf "‚úÖ %s\n" "$1"; }
warn(){ printf "‚ö†Ô∏è  %s\n" "$1"; WARNS=$((WARNS+1)); }
fail(){ printf "‚ùå %s\n" "$1"; FAILS=$((FAILS+1)); }
die(){ printf "‚ùå %s\n" "$1"; exit 1; }

WARNS=0
FAILS=0

echo "üß™ Client Audit ‚Äî security ‚Ä¢ production ‚Ä¢ performance"
echo "ROOT: $ROOT_DIR"
echo "STRICT: $STRICT"

# 0) Build presence
if [[ -z "$DIST" || ! -d "$DIST" ]]; then
  warn "No built assets found (dist/*). Run a build before auditing."
  echo "   tip: rm -rf dist && npm run build"
  [[ "$STRICT" == "1" ]] && die "Strict mode: failing due to missing build."
  exit 0
fi

# 1) Asset sizes
echo "‚Äî Top asset sizes (KB) ‚Äî"
# shellcheck disable=SC2012
ls -1 "$DIST" | xargs -I{} bash -c 'printf "%7.1f\t%s\n" "$(stat -c%s "'"$DIST"'"/{})/1024" "{}"' \
  | sort -nr | head -20 || true

MAIN_JS="$(ls "$DIST"/index-*.js 2>/dev/null | head -1 || true)"
if [[ -n "$MAIN_JS" ]]; then
  MAIN_SIZE=$(stat -c%s "$MAIN_JS" 2>/dev/null || echo 0)
  KB=$(( (MAIN_SIZE + 1023) / 1024 ))
  if (( KB > 900 )); then
    warn "Main bundle ~${KB}KB exceeds 900KB budget (OK if heavy pages are lazy)."
  else
    ok "Main bundle within 900KB budget (~${KB}KB)."
  fi
else
  warn "No index-*.js main bundle found (custom naming?)."
fi

# 2) Dist sanity: dev URLs & secrets & legacy /api/public
BAD_URLS=$(grep -RIlE 'http://(localhost|127\.0\.0\.1)|https?://192\.168\.' "$DIST" || true)
if [[ -n "$BAD_URLS" ]]; then
  warn "Dev/localhost URLs found in dist (expected only in test builds):"
  echo "$BAD_URLS" | sed 's/^/   ‚Ä¢ /'
else
  ok "No localhost/LAN URLs in dist."
fi

SECRETS=$(grep -RIlE 'OPENAI_API_KEY|SENDGRID_API_KEY|AWS_SECRET|SIGNNOW_' "$DIST" || true)
if [[ -n "$SECRETS" ]]; then
  fail "Secret-like tokens found in dist!"
  echo "$SECRETS" | sed 's/^/   ‚Ä¢ /'
else
  ok "No secret-like tokens in dist."
fi

LEGACY_PUBLIC=$(grep -RIlE '/api/public/' "$DIST" || true)
if [[ -n "$LEGACY_PUBLIC" ]]; then
  warn "Legacy /api/public references in dist (likely from stale build cache):"
  echo "$LEGACY_PUBLIC" | sed 's/^/   ‚Ä¢ /'
  echo "   tip: rm -rf dist && npm run build"
else
  ok "No legacy /api/public references in dist."
fi

# 3) Hashed filenames (cache-busting)
HASHED_ISSUES=0
while IFS= read -r f; do
  # Allow chunk/hash patterns like "-[hash].js"
  if [[ "$f" =~ \.(js|css|svg|png|jpg|jpeg|webp|woff2)$ ]]; then
    base="$(basename "$f")"
    if [[ ! "$base" =~ -[A-Za-z0-9]{6,}\. ]]; then
      # tolerate vendor-* or assets without hashes if not served immutable
      HASHED_ISSUES=$((HASHED_ISSUES+1))
      echo "   ‚Ä¢ Unhashed asset: $base"
    fi
  fi
done < <(find "$DIST" -maxdepth 1 -type f)
if (( HASHED_ISSUES > 0 )); then
  warn "Some assets appear un-hashed (consider ensuring hashed filenames for long-term caching)."
else
  ok "Assets appear hashed for caching."
fi

# 4) Source checks (only if ripgrep available)
if command -v rg >/dev/null 2>&1; then
  echo "‚Äî Source static checks (rg) ‚Äî"

  # fetch without credentials (exclude tests/debug)
  MISSING_CREDS=$(rg -n 'fetch\([^)]*\)' "$SRC" -g '!**/*.test.*' -g '!**/debug/**' \
    | rg -v 'credentials:\s*["'\''"]include["'\''"]' || true)
  if [[ -n "$MISSING_CREDS" ]]; then
    warn "Some fetch() calls lack credentials: 'include' (review if hitting protected routes):"
    echo "$MISSING_CREDS" | head -20 | sed 's/^/   ‚Ä¢ /'
  else
    ok "All fetch() calls include credentials (or are public)."
  fi

  # console noise (exclude tests/debug)
  NOISY=$(rg -n 'console\.(log|debug)\(' "$SRC" -g '!**/*.test.*' -g '!**/debug/**' || true)
  if [[ -n "$NOISY" ]]; then
    warn "console.log/debug present in source:"
    echo "$NOISY" | head -20 | sed 's/^/   ‚Ä¢ /'
  else
    ok "No stray console logs in source."
  fi

  # Lazy patterns for heavy routes/components
  if rg -n 'React\.lazy|lazy\(\s*\(\)\s*=>\s*import' "$SRC" | rg -q 'Step4|Step5|Step6|ChatBot'; then
    ok "Heavy components are lazy-loaded (Step4/5/6/ChatBot)."
  else
    warn "Could not confirm lazy-loading for heavy components."
  fi
else
  warn "ripgrep not available; skipping source checks."
fi

# 5) CSP presence (meta) ‚Äî OK if served via headers
if [[ -f "$INDEX_HTML" ]]; then
  if grep -iq 'http-equiv="Content-Security-Policy"' "$INDEX_HTML"; then
    ok "CSP meta present in index.html."
  else
    warn "No CSP meta in index.html (OK if CSP via server headers)."
  fi
fi

echo ""
echo "‚Äî Summary ‚Äî"
echo "Warnings: $WARNS  Failures: $FAILS"
if (( FAILS > 0 )); then
  die "Client audit: FAIL"
fi
if [[ "$STRICT" == "1" && "$WARNS" -gt 0 ]]; then
  die "Client audit: STRICT failure due to warnings."
fi

ok "Client audit: PASS"
```

---

## 2) Add CI runner script (strict by default)

Create `scripts/ci-run-client-audit.sh`:

```bash
#!/usr/bin/env bash
set -euo pipefail
echo "üõ°Ô∏è CI: building client and running strict audit‚Ä¶"
# Build; if your build command differs, adjust here.
npm run build || (echo "Build failed." && exit 1)
# Strict mode will fail on warnings
AUDIT_STRICT=1 bash scripts/client-audit.sh
```

Make both scripts executable:

```bash
chmod +x scripts/client-audit.sh
chmod +x scripts/ci-run-client-audit.sh
```

---

## 3) Add GitHub Actions workflow (runs on every push)

Create `.github/workflows/client-audit.yml`:

```yaml
name: client-audit
on:
  push:
  workflow_dispatch:

jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Install deps
        run: npm ci --ignore-scripts

      - name: Make scripts executable
        run: |
          chmod +x scripts/client-audit.sh || true
          chmod +x scripts/ci-run-client-audit.sh || true

      - name: Build + Strict Audit
        run: scripts/ci-run-client-audit.sh
```

---

## 4) Verification (local)

```bash
# Clean old build to remove cached /api/public refs if any
rm -rf dist
npm run build

# Non-strict (dev inspection)
bash scripts/client-audit.sh

# Strict (treats warnings as failures)
AUDIT_STRICT=1 bash scripts/client-audit.sh
```

**Pass criteria (strict):**

* No `localhost`/LAN URLs in `dist/`
* No secret-like tokens in `dist/`
* No legacy `/api/public/` in `dist/`
* Lazy-load patterns found for Step4/5/6/ChatBot
* Either CSP meta present **or** you‚Äôre serving CSP via server headers

---

### Notes & Tips

* If strict fails due to a **stale legacy reference**, it‚Äôs usually a cached artifact. Run:

  ```bash
  rm -rf dist && npm run build
  ```

* If strict flags a legit `fetch()` without credentials on a protected route, fix by adding:

  ```ts
  fetch(url, { credentials: "include", ... })
  ```

  (Public, anonymous endpoints may omit credentials.)

* You can toggle strictness per-branch in CI by editing the runner script (e.g., allow warnings on `dev`, strict on `main`).

---

That‚Äôs it ‚Äî your **client audit is now enforceable** in CI with a single, strict switch, no `package.json` edits required.
