# Core Features Implementation Guide

## Overview

This guide provides detailed instructions for implementing the key features of the Boreal Financial business loan application platform in another Replit application. These features form the core functionality that makes the platform intelligent, secure, and user-friendly.

## 1. Intelligent Recommendation Engine

### Database Schema for Loan Products

```typescript
// shared/schema.ts
import { pgTable, serial, text, integer, boolean, decimal, timestamp } from 'drizzle-orm/pg-core';

export const loanProducts = pgTable('loan_products', {
  id: serial('id').primaryKey(),
  externalId: text('external_id').unique(),
  lenderName: text('lender_name').notNull(),
  productName: text('product_name').notNull(),
  productType: text('product_type').notNull(), // 'term_loan', 'line_of_credit', 'equipment_financing', etc.
  minAmount: integer('min_amount').notNull(),
  maxAmount: integer('max_amount').notNull(),
  interestRateMin: decimal('interest_rate_min', { precision: 5, scale: 2 }),
  interestRateMax: decimal('interest_rate_max', { precision: 5, scale: 2 }),
  termMin: integer('term_min'), // months
  termMax: integer('term_max'), // months
  offeredInUs: boolean('offered_in_us').default(false),
  offeredInCanada: boolean('offered_in_canada').default(false),
  requiredDocuments: text('required_documents').array(),
  description: text('description'),
  syncedAt: timestamp('synced_at').defaultNow(),
  isActive: boolean('is_active').default(true)
});
```

### Recommendation Engine Core Logic

```typescript
// server/recommendationEngine.ts
import { loanProducts } from '@/shared/schema';
import { neon } from '@neondatabase/serverless';

export class RecommendationEngine {
  private sql = neon(process.env.DATABASE_URL!);

  // Core filtering method with all conditional logic
  async getFilteredProducts(filters: {
    country: 'United States' | 'Canada';
    lookingFor: 'capital' | 'equipment';
    fundsPurpose?: string;
    fundingAmount?: string;
    accountsReceivableBalance?: string;
  }) {
    let query = `
      SELECT * FROM loan_products 
      WHERE is_active = true
    `;
    
    const params: any[] = [];
    let paramIndex = 1;

    // Country-based filtering
    if (filters.country === 'United States') {
      query += ` AND offered_in_us = true`;
    } else if (filters.country === 'Canada') {
      query += ` AND offered_in_canada = true`;
    }

    // Product type filtering
    if (filters.lookingFor === 'equipment') {
      query += ` AND product_type = $${paramIndex++}`;
      params.push('equipment_financing');
    } else if (filters.lookingFor === 'capital') {
      query += ` AND product_type != $${paramIndex++}`;
      params.push('equipment_financing');
    }

    // Funding amount range filtering
    if (filters.fundingAmount) {
      const amount = this.parseFundingAmount(filters.fundingAmount);
      if (amount) {
        query += ` AND min_amount <= $${paramIndex++} AND max_amount >= $${paramIndex++}`;
        params.push(amount.max, amount.min);
      }
    }

    // Accounts receivable filtering (excludes factoring if no AR)
    if (filters.accountsReceivableBalance === 'no_accounts_receivables') {
      query += ` AND product_type != $${paramIndex++}`;
      params.push('factoring');
    }

    // Funds purpose conditional filtering
    if (filters.fundsPurpose) {
      const allowedTypes = this.getAllowedProductTypes(filters.fundsPurpose);
      if (allowedTypes.length > 0) {
        const placeholders = allowedTypes.map(() => `$${paramIndex++}`).join(',');
        query += ` AND product_type IN (${placeholders})`;
        params.push(...allowedTypes);
      }
    }

    query += ` ORDER BY lender_name, product_name`;

    const results = await this.sql(query, params);
    return results;
  }

  // Parse funding amount from form strings like "$50,000 - $100,000"
  private parseFundingAmount(fundingAmount: string) {
    const ranges = {
      '$10,000 - $50,000': { min: 10000, max: 50000 },
      '$50,000 - $100,000': { min: 50000, max: 100000 },
      '$100,000 - $250,000': { min: 100000, max: 250000 },
      '$250,000 - $500,000': { min: 250000, max: 500000 },
      '$500,000 - $1,000,000': { min: 500000, max: 1000000 },
      '$1,000,000+': { min: 1000000, max: 50000000 }
    };
    return ranges[fundingAmount as keyof typeof ranges];
  }

  // Conditional product type filtering based on funds purpose
  private getAllowedProductTypes(purpose: string): string[] {
    const purposeMapping = {
      'equipment': ['equipment_financing'],
      'business_expansion': ['line_of_credit', 'factoring', 'working_capital', 'term_loan'],
      'working_capital': ['line_of_credit', 'working_capital', 'term_loan'],
      'inventory': ['line_of_credit', 'factoring', 'purchase_order_financing', 'term_loan', 'working_capital'],
      'marketing': ['line_of_credit', 'term_loan', 'working_capital'],
      'debt_consolidation': ['line_of_credit', 'factoring', 'term_loan', 'working_capital'],
      'other': [] // No restrictions for "other"
    };
    
    return purposeMapping[purpose as keyof typeof purposeMapping] || [];
  }

  // Generate category statistics for display
  async getCategoryStats(products: any[]) {
    const categoryCount = products.reduce((acc, product) => {
      const category = this.formatCategoryName(product.product_type);
      acc[category] = (acc[category] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const total = products.length;
    return Object.entries(categoryCount).map(([category, count]) => ({
      category,
      count,
      percentage: total > 0 ? Math.round((count / total) * 100) : 0
    }));
  }

  // Format product type names for display
  private formatCategoryName(productType: string): string {
    const nameMap = {
      'line_of_credit': 'Business Line of Credit',
      'term_loan': 'Term Loan',
      'equipment_financing': 'Equipment Financing',
      'factoring': 'Invoice Factoring',
      'working_capital': 'Working Capital',
      'purchase_order_financing': 'Purchase Order Financing',
      'commercial_mortgage': 'Commercial Mortgage'
    };
    return nameMap[productType as keyof typeof nameMap] || productType;
  }
}
```

### API Endpoints for Recommendation Engine

```typescript
// server/routes.ts
import express from 'express';
import { RecommendationEngine } from './recommendationEngine';

const router = express.Router();
const recommendationEngine = new RecommendationEngine();

// Get filtered loan product categories
router.get('/api/loan-products/categories', async (req, res) => {
  try {
    const { 
      country, 
      lookingFor, 
      fundsPurpose, 
      fundingAmount, 
      accountsReceivableBalance 
    } = req.query;

    const products = await recommendationEngine.getFilteredProducts({
      country: country as string,
      lookingFor: lookingFor as string,
      fundsPurpose: fundsPurpose as string,
      fundingAmount: fundingAmount as string,
      accountsReceivableBalance: accountsReceivableBalance as string
    });

    const categoryStats = await recommendationEngine.getCategoryStats(products);
    
    res.json({
      categories: categoryStats,
      totalProducts: products.length,
      filters: { country, lookingFor, fundsPurpose, fundingAmount, accountsReceivableBalance }
    });
  } catch (error) {
    console.error('Error fetching product categories:', error);
    res.status(500).json({ error: 'Failed to fetch product categories' });
  }
});

// Get required documents for filtered products
router.get('/api/loan-products/required-documents', async (req, res) => {
  try {
    const products = await recommendationEngine.getFilteredProducts(req.query as any);
    
    // Aggregate all required documents
    const allDocuments = products.flatMap(p => p.required_documents || []);
    const uniqueDocuments = [...new Set(allDocuments)];
    
    res.json({
      requiredDocuments: uniqueDocuments,
      productCount: products.length,
      lenderCount: new Set(products.map(p => p.lender_name)).size
    });
  } catch (error) {
    console.error('Error fetching required documents:', error);
    res.status(500).json({ error: 'Failed to fetch required documents' });
  }
});

export { router };
```

### Frontend Recommendation Display

```typescript
// client/src/components/RecommendationEngine.tsx
import React, { useEffect, useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { TrendingUp, Building2, DollarSign } from 'lucide-react';

interface RecommendationEngineProps {
  formData: {
    headquarters?: string;
    lookingFor?: string;
    fundsPurpose?: string;
    fundingAmount?: string;
    accountsReceivableBalance?: string;
  };
}

export function RecommendationEngine({ formData }: RecommendationEngineProps) {
  const [isVisible, setIsVisible] = useState(false);

  // Build query parameters
  const queryParams = new URLSearchParams();
  if (formData.headquarters) queryParams.append('country', formData.headquarters);
  if (formData.lookingFor) queryParams.append('lookingFor', formData.lookingFor);
  if (formData.fundsPurpose) queryParams.append('fundsPurpose', formData.fundsPurpose);
  if (formData.fundingAmount) queryParams.append('fundingAmount', formData.fundingAmount);
  if (formData.accountsReceivableBalance) queryParams.append('accountsReceivableBalance', formData.accountsReceivableBalance);

  // Fetch recommendations
  const { data: recommendations, isLoading } = useQuery({
    queryKey: ['/api/loan-products/categories', queryParams.toString()],
    queryFn: async () => {
      const response = await fetch(`/api/loan-products/categories?${queryParams}`);
      if (!response.ok) throw new Error('Failed to fetch recommendations');
      return response.json();
    },
    enabled: !!(formData.headquarters && formData.lookingFor)
  });

  // Show component when we have basic required data
  useEffect(() => {
    if (formData.headquarters && formData.lookingFor) {
      setIsVisible(true);
    }
  }, [formData.headquarters, formData.lookingFor]);

  if (!isVisible) return null;

  if (isLoading) {
    return (
      <Card className="mt-6">
        <CardHeader>
          <CardTitle className="flex items-center">
            <TrendingUp className="mr-2 h-5 w-5 text-blue-600" />
            Industry Insight
          </CardTitle>
        </CardHeader>
        <CardContent>
          <div className="animate-pulse space-y-3">
            <div className="h-4 bg-gray-200 rounded w-3/4"></div>
            <div className="h-4 bg-gray-200 rounded w-1/2"></div>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="mt-6 border-blue-200 bg-blue-50">
      <CardHeader>
        <CardTitle className="flex items-center">
          <TrendingUp className="mr-2 h-5 w-5 text-blue-600" />
          Industry Insight
          <Badge variant="secondary" className="ml-2">
            {formData.headquarters === 'united_states' ? 'US' : 'Canada'}
          </Badge>
        </CardTitle>
        <CardDescription>
          Real-time analysis based on your business profile
        </CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Total Products Available */}
        <div className="flex items-center justify-between p-3 bg-white rounded-lg border">
          <div className="flex items-center">
            <Building2 className="h-5 w-5 text-green-600 mr-2" />
            <span className="font-medium">Available Products</span>
          </div>
          <Badge variant="default" className="bg-green-600">
            {recommendations?.totalProducts || 0} lenders
          </Badge>
        </div>

        {/* Category Breakdown */}
        {recommendations?.categories && recommendations.categories.length > 0 && (
          <div>
            <h4 className="font-medium mb-3 flex items-center">
              <DollarSign className="h-4 w-4 mr-2 text-blue-600" />
              Product Categories Available
            </h4>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
              {recommendations.categories.map((category: any, index: number) => (
                <div key={index} className="flex items-center justify-between p-2 bg-white rounded border">
                  <span className="text-sm font-medium">{category.category}</span>
                  <div className="flex items-center space-x-2">
                    <span className="text-sm text-gray-600">{category.count} products</span>
                    <Badge variant="outline" className="text-xs">
                      {category.percentage}%
                    </Badge>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}

        {/* Industry Analysis */}
        <div className="p-3 bg-white rounded-lg border">
          <h4 className="font-medium mb-2">Market Analysis</h4>
          <ul className="text-sm text-gray-600 space-y-1">
            {formData.lookingFor === 'equipment' && (
              <li>• Equipment financing shows strong availability for manufacturing businesses</li>
            )}
            {formData.lookingFor === 'capital' && (
              <li>• Working capital products are highly competitive in your market</li>
            )}
            {formData.fundingAmount && (
              <li>• Your requested amount range has {recommendations?.totalProducts || 0} active lender options</li>
            )}
            {formData.accountsReceivableBalance === 'no_accounts_receivables' && (
              <li>• Factoring products excluded due to no accounts receivable</li>
            )}
          </ul>
        </div>
      </CardContent>
    </Card>
  );
}
```

## 2. Authentication & Security System

### User Schema and Security Setup

```typescript
// shared/schema.ts
import { pgTable, serial, text, boolean, timestamp } from 'drizzle-orm/pg-core';
import { createInsertSchema } from 'drizzle-zod';
import { z } from 'zod';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: text('email').notNull().unique(),
  password: text('password').notNull(),
  firstName: text('first_name'),
  lastName: text('last_name'),
  phone: text('phone'),
  isActive: boolean('is_active').default(true),
  hasCompletedApplication: boolean('has_completed_application').default(false),
  lastLoginAt: timestamp('last_login_at'),
  createdAt: timestamp('created_at').defaultNow(),
  updatedAt: timestamp('updated_at').defaultNow()
});

export const insertUserSchema = createInsertSchema(users).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  lastLoginAt: true
}).extend({
  confirmPassword: z.string().min(8)
}).refine(data => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"]
});

export type InsertUser = z.infer<typeof insertUserSchema>;
export type SelectUser = typeof users.$inferSelect;
```

### Authentication Backend Implementation

```typescript
// server/auth.ts
import express from 'express';
import session from 'express-session';
import passport from 'passport';
import { Strategy as LocalStrategy } from 'passport-local';
import bcrypt from 'bcrypt';
import { storage } from './storage';
import ConnectPgSimple from 'connect-pg-simple';
import { neon } from '@neondatabase/serverless';

const router = express.Router();
const PgSession = ConnectPgSimple(session);

// Session configuration with PostgreSQL store
router.use(session({
  store: new PgSession({
    conString: process.env.DATABASE_URL,
    tableName: 'session',
    createTableIfMissing: true
  }),
  secret: process.env.SESSION_SECRET || 'your-secret-key-change-in-production',
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    httpOnly: true,
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
    sameSite: 'lax'
  }
}));

// Passport Local Strategy
passport.use(new LocalStrategy(
  { usernameField: 'email' },
  async (email, password, done) => {
    try {
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return done(null, false, { message: 'Invalid email or password' });
      }

      // Support both bcrypt and scrypt hashes for backward compatibility
      let isValid = false;
      if (user.password.startsWith('$2b$')) {
        isValid = await bcrypt.compare(password, user.password);
      } else {
        // Legacy scrypt support
        isValid = password === user.password;
      }

      if (!isValid) {
        return done(null, false, { message: 'Invalid email or password' });
      }

      // Update last login
      await storage.updateUserLastLogin(user.id);
      
      return done(null, user);
    } catch (error) {
      console.error('Authentication error:', error);
      return done(error);
    }
  }
));

passport.serializeUser((user: any, done) => {
  done(null, user.id);
});

passport.deserializeUser(async (id: number, done) => {
  try {
    const user = await storage.getUserById(id);
    done(null, user);
  } catch (error) {
    console.error('Deserialization error:', error);
    done(error);
  }
});

router.use(passport.initialize());
router.use(passport.session());

// Registration endpoint
router.post('/register', async (req, res) => {
  try {
    const { email, password, firstName, lastName, phone } = req.body;
    
    // Check if user exists
    const existingUser = await storage.getUserByEmail(email);
    if (existingUser) {
      return res.status(400).json({ error: 'User already exists' });
    }

    // Hash password
    const saltRounds = 12;
    const hashedPassword = await bcrypt.hash(password, saltRounds);

    // Create user
    const newUser = await storage.createUser({
      email,
      password: hashedPassword,
      firstName,
      lastName,
      phone
    });

    // Auto login after registration
    req.login(newUser, (err) => {
      if (err) {
        console.error('Auto-login error:', err);
        return res.status(500).json({ error: 'Registration successful but login failed' });
      }
      res.json({ success: true, user: newUser });
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Registration failed' });
  }
});

// Login endpoint
router.post('/login', (req, res, next) => {
  passport.authenticate('local', (err, user, info) => {
    if (err) {
      console.error('Login error:', err);
      return res.status(500).json({ error: 'Login failed' });
    }
    if (!user) {
      return res.status(401).json({ error: info?.message || 'Invalid credentials' });
    }
    
    req.login(user, (err) => {
      if (err) {
        console.error('Session creation error:', err);
        return res.status(500).json({ error: 'Session creation failed' });
      }
      res.json({ success: true, user });
    });
  })(req, res, next);
});

// Logout endpoint
router.post('/logout', (req, res) => {
  req.logout((err) => {
    if (err) {
      console.error('Logout error:', err);
      return res.status(500).json({ error: 'Logout failed' });
    }
    req.session.destroy((err) => {
      if (err) {
        console.error('Session destruction error:', err);
      }
      res.clearCookie('connect.sid');
      res.json({ success: true });
    });
  });
});

// Get current user endpoint
router.get('/user', (req, res) => {
  if (req.isAuthenticated() && req.user) {
    res.json(req.user);
  } else {
    res.status(401).json({ message: 'Unauthorized' });
  }
});

// Protected route middleware
export function requireAuth(req: express.Request, res: express.Response, next: express.NextFunction) {
  if (req.isAuthenticated()) {
    return next();
  }
  res.status(401).json({ message: 'Authentication required' });
}

export { router as authRouter };
```

### Frontend Authentication Hook

```typescript
// client/src/hooks/useAuth.ts
import { useQuery, useQueryClient, useMutation } from '@tanstack/react-query';
import { useLocation } from 'wouter';
import { useToast } from '@/hooks/use-toast';

interface User {
  id: number;
  email: string;
  firstName?: string;
  lastName?: string;
  phone?: string;
  isActive: boolean;
  hasCompletedApplication: boolean;
  lastLoginAt?: string;
  createdAt: string;
  updatedAt: string;
}

interface LoginCredentials {
  email: string;
  password: string;
}

interface RegisterData {
  email: string;
  password: string;
  confirmPassword: string;
  firstName: string;
  lastName: string;
  phone?: string;
}

export function useAuth() {
  const [, setLocation] = useLocation();
  const queryClient = useQueryClient();
  const { toast } = useToast();

  // Get current user
  const { data: user, isLoading, error } = useQuery<User>({
    queryKey: ['/api/auth/user'],
    queryFn: async () => {
      const response = await fetch('/api/auth/user', {
        credentials: 'include'
      });
      if (!response.ok) {
        if (response.status === 401) {
          return null;
        }
        throw new Error('Failed to fetch user');
      }
      return response.json();
    },
    retry: false,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });

  // Login mutation
  const loginMutation = useMutation({
    mutationFn: async (credentials: LoginCredentials) => {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(credentials),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Login failed');
      }
      
      return response.json();
    },
    onSuccess: (data) => {
      queryClient.setQueryData(['/api/auth/user'], data.user);
      
      // Smart routing after login
      if (data.user.hasCompletedApplication) {
        setLocation('/portal');
      } else {
        setLocation('/application');
      }
      
      toast({
        title: "Welcome back!",
        description: `Signed in as ${data.user.email}`,
      });
    },
    onError: (error) => {
      toast({
        title: "Login failed",
        description: error.message,
        variant: "destructive",
      });
    }
  });

  // Register mutation
  const registerMutation = useMutation({
    mutationFn: async (userData: RegisterData) => {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include',
        body: JSON.stringify(userData),
      });
      
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Registration failed');
      }
      
      return response.json();
    },
    onSuccess: (data) => {
      queryClient.setQueryData(['/api/auth/user'], data.user);
      setLocation('/application'); // New users always start with application
      
      toast({
        title: "Account created!",
        description: "Welcome to Boreal Financial",
      });
    },
    onError: (error) => {
      toast({
        title: "Registration failed",
        description: error.message,
        variant: "destructive",
      });
    }
  });

  // Logout mutation
  const logoutMutation = useMutation({
    mutationFn: async () => {
      const response = await fetch('/api/auth/logout', {
        method: 'POST',
        credentials: 'include'
      });
      
      if (!response.ok) {
        throw new Error('Logout failed');
      }
      
      return response.json();
    },
    onSuccess: () => {
      queryClient.setQueryData(['/api/auth/user'], null);
      queryClient.clear();
      setLocation('/');
      
      toast({
        title: "Signed out",
        description: "See you next time!",
      });
    },
    onError: (error) => {
      console.error('Logout error:', error);
      // Force logout on error
      queryClient.setQueryData(['/api/auth/user'], null);
      setLocation('/');
    }
  });

  // Utility functions
  const getUserDisplayName = () => {
    if (user?.firstName) {
      return user.firstName;
    }
    if (user?.email) {
      return user.email.split('@')[0];
    }
    return 'User';
  };

  return {
    // User data
    user: user || null,
    isAuthenticated: !!user,
    hasCompletedApplication: user?.hasCompletedApplication || false,
    isLoading,
    error,
    
    // Actions
    login: loginMutation.mutate,
    register: registerMutation.mutate,
    logout: logoutMutation.mutate,
    
    // Loading states
    isLoggingIn: loginMutation.isPending,
    isRegistering: registerMutation.isPending,
    isLoggingOut: logoutMutation.isPending,
    
    // Utilities
    getUserDisplayName
  };
}
```

## 3. Document Management System

### Document Validation Core

```typescript
// server/documentValidator.ts
import crypto from 'crypto';
import { Buffer } from 'buffer';

export interface DocumentValidationResult {
  isValid: boolean;
  validationStatus: 'authentic' | 'placeholder' | 'suspicious' | 'invalid';
  contentLength: number;
  checksumSHA256: string;
  filename: string;
  category: string;
  errors: string[];
  metadata: {
    uploadedBy: string;
    uploadedAt: string;
    validatedAt: string;
    originalSize: number;
    processedSize: number;
  };
}

export class DocumentValidator {
  private static readonly MIN_FILE_SIZE = 5120; // 5KB minimum
  private static readonly MAX_FILE_SIZE = 104857600; // 100MB maximum
  private static readonly PLACEHOLDER_INDICATORS = [
    'sample', 'example', 'test', 'placeholder', 'demo', 'template',
    'dummy', 'fake', 'mock', 'specimen', 'draft'
  ];

  static validateDocument(
    fileName: string, 
    fileData: string, 
    category: string, 
    uploadedBy: string = 'user'
  ): DocumentValidationResult {
    const errors: string[] = [];
    let validationStatus: DocumentValidationResult['validationStatus'] = 'authentic';

    // Decode base64 to get actual file size
    const buffer = Buffer.from(fileData, 'base64');
    const actualSize = buffer.length;
    const base64Size = fileData.length;

    // Generate SHA256 checksum
    const checksumSHA256 = crypto.createHash('sha256').update(buffer).digest('hex');

    // File size validation
    if (actualSize < this.MIN_FILE_SIZE) {
      errors.push(`File too small: ${actualSize} bytes (minimum ${this.MIN_FILE_SIZE} bytes)`);
      validationStatus = 'invalid';
    }

    if (actualSize > this.MAX_FILE_SIZE) {
      errors.push(`File too large: ${actualSize} bytes (maximum ${this.MAX_FILE_SIZE} bytes)`);
      validationStatus = 'invalid';
    }

    // Placeholder content detection
    const lowerFileName = fileName.toLowerCase();
    const hasPlaceholderIndicator = this.PLACEHOLDER_INDICATORS.some(indicator => 
      lowerFileName.includes(indicator)
    );

    if (hasPlaceholderIndicator) {
      errors.push('Filename contains placeholder indicators');
      validationStatus = 'placeholder';
    }

    // Content authenticity checks
    if (actualSize < 10240 && !hasPlaceholderIndicator) { // Under 10KB but not flagged as placeholder
      validationStatus = 'suspicious';
      errors.push('File size unusually small for business document');
    }

    // Category-specific validation
    const categoryValidation = this.validateDocumentCategory(fileName, category, actualSize);
    if (!categoryValidation.isValid) {
      errors.push(...categoryValidation.errors);
      if (validationStatus === 'authentic') {
        validationStatus = categoryValidation.suggestedStatus;
      }
    }

    return {
      isValid: errors.length === 0 && validationStatus === 'authentic',
      validationStatus,
      contentLength: actualSize,
      checksumSHA256,
      filename: fileName,
      category,
      errors,
      metadata: {
        uploadedBy,
        uploadedAt: new Date().toISOString(),
        validatedAt: new Date().toISOString(),
        originalSize: base64Size,
        processedSize: actualSize
      }
    };
  }

  private static validateDocumentCategory(
    fileName: string, 
    category: string, 
    fileSize: number
  ): { isValid: boolean; errors: string[]; suggestedStatus: DocumentValidationResult['validationStatus'] } {
    const errors: string[] = [];
    let suggestedStatus: DocumentValidationResult['validationStatus'] = 'authentic';

    const expectedExtensions: Record<string, string[]> = {
      'bank_statements': ['.pdf', '.png', '.jpg', '.jpeg'],
      'tax_returns': ['.pdf'],
      'financial_statements': ['.pdf', '.xlsx', '.xls'],
      'business_license': ['.pdf', '.png', '.jpg', '.jpeg'],
      'accounts_receivable': ['.pdf', '.xlsx', '.csv'],
      'accounts_payable': ['.pdf', '.xlsx', '.csv']
    };

    const minSizesByCategory: Record<string, number> = {
      'bank_statements': 50000,  // 50KB - bank statements are typically substantial
      'tax_returns': 100000,     // 100KB - tax returns are comprehensive documents
      'financial_statements': 30000, // 30KB - financial statements vary
      'business_license': 20000,  // 20KB - licenses can be simple
      'accounts_receivable': 10000, // 10KB - AR reports vary
      'accounts_payable': 10000   // 10KB - AP reports vary
    };

    // Check file extension
    const expectedExts = expectedExtensions[category];
    if (expectedExts) {
      const hasValidExtension = expectedExts.some(ext => 
        fileName.toLowerCase().endsWith(ext)
      );
      if (!hasValidExtension) {
        errors.push(`Invalid file type for ${category}. Expected: ${expectedExts.join(', ')}`);
        suggestedStatus = 'suspicious';
      }
    }

    // Check category-specific minimum size
    const minSize = minSizesByCategory[category];
    if (minSize && fileSize < minSize) {
      errors.push(`File size too small for ${category} (${fileSize} bytes < ${minSize} bytes)`);
      suggestedStatus = 'suspicious';
    }

    return {
      isValid: errors.length === 0,
      errors,
      suggestedStatus
    };
  }

  // Validate a set of documents together
  static validateDocumentSet(documents: Array<{
    fileName: string;
    fileData: string;
    category: string;
  }>): {
    isValid: boolean;
    results: DocumentValidationResult[];
    summary: {
      totalDocuments: number;
      validDocuments: number;
      placeholderDocuments: number;
      suspiciousDocuments: number;
      invalidDocuments: number;
    };
  } {
    const results = documents.map(doc => 
      this.validateDocument(doc.fileName, doc.fileData, doc.category)
    );

    const summary = {
      totalDocuments: documents.length,
      validDocuments: results.filter(r => r.validationStatus === 'authentic').length,
      placeholderDocuments: results.filter(r => r.validationStatus === 'placeholder').length,
      suspiciousDocuments: results.filter(r => r.validationStatus === 'suspicious').length,
      invalidDocuments: results.filter(r => r.validationStatus === 'invalid').length
    };

    const isValid = summary.placeholderDocuments === 0 && summary.invalidDocuments === 0;

    return { isValid, results, summary };
  }

  // Generate validation metadata for API transmission
  static generateValidationMetadata(results: DocumentValidationResult[]): any {
    return {
      documentValidation: {
        totalDocuments: results.length,
        validationResults: results.map(r => ({
          filename: r.filename,
          category: r.category,
          status: r.validationStatus,
          checksum: r.checksumSHA256,
          size: r.contentLength
        })),
        validationTimestamp: new Date().toISOString(),
        validationVersion: '2.0'
      }
    };
  }
}
```

### Document Upload Component

```typescript
// client/src/components/DocumentUpload.tsx
import React, { useCallback, useState } from 'react';
import { useDropzone } from 'react-dropzone';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Progress } from '@/components/ui/progress';
import { useToast } from '@/hooks/use-toast';
import { 
  Upload, 
  FileText, 
  AlertCircle, 
  CheckCircle, 
  X,
  Download 
} from 'lucide-react';

interface DocumentUploadProps {
  onDocumentsChange: (documents: UploadedDocument[]) => void;
  requiredDocuments?: string[];
  maxFiles?: number;
}

interface UploadedDocument {
  id: string;
  fileName: string;
  fileData: string;
  category: string;
  size: number;
  validationStatus?: 'authentic' | 'placeholder' | 'suspicious' | 'invalid';
  validationErrors?: string[];
  uploadedAt: string;
}

export function DocumentUpload({ 
  onDocumentsChange, 
  requiredDocuments = [],
  maxFiles = 10 
}: DocumentUploadProps) {
  const [documents, setDocuments] = useState<UploadedDocument[]>([]);
  const [isValidating, setIsValidating] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const { toast } = useToast();

  // Document category mapping
  const getDocumentCategory = (fileName: string): string => {
    const lowerName = fileName.toLowerCase();
    
    if (lowerName.includes('bank') || lowerName.includes('statement')) {
      return 'bank_statements';
    }
    if (lowerName.includes('tax') || lowerName.includes('t1') || lowerName.includes('t2')) {
      return 'tax_returns';
    }
    if (lowerName.includes('financial') || lowerName.includes('balance') || lowerName.includes('income')) {
      return 'financial_statements';
    }
    if (lowerName.includes('license') || lowerName.includes('permit')) {
      return 'business_license';
    }
    if (lowerName.includes('receivable') || lowerName.includes('ar')) {
      return 'accounts_receivable';
    }
    if (lowerName.includes('payable') || lowerName.includes('ap')) {
      return 'accounts_payable';
    }
    
    return 'other';
  };

  // Convert file to base64
  const fileToBase64 = (file: File): Promise<string> => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = () => {
        const result = reader.result as string;
        // Remove data:type/subtype;base64, prefix
        const base64 = result.split(',')[1];
        resolve(base64);
      };
      reader.onerror = error => reject(error);
    });
  };

  // Validate document with backend
  const validateDocument = async (doc: UploadedDocument): Promise<UploadedDocument> => {
    try {
      const response = await fetch('/api/documents/validate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          fileName: doc.fileName,
          fileData: doc.fileData,
          category: doc.category
        })
      });

      if (!response.ok) {
        throw new Error('Validation failed');
      }

      const validation = await response.json();
      
      return {
        ...doc,
        validationStatus: validation.validationStatus,
        validationErrors: validation.errors
      };
    } catch (error) {
      console.error('Document validation error:', error);
      return {
        ...doc,
        validationStatus: 'invalid',
        validationErrors: ['Validation service unavailable']
      };
    }
  };

  // Handle file drop
  const onDrop = useCallback(async (acceptedFiles: File[]) => {
    if (documents.length + acceptedFiles.length > maxFiles) {
      toast({
        title: "Too many files",
        description: `Maximum ${maxFiles} files allowed`,
        variant: "destructive"
      });
      return;
    }

    setIsValidating(true);
    setUploadProgress(0);

    const newDocuments: UploadedDocument[] = [];

    for (let i = 0; i < acceptedFiles.length; i++) {
      const file = acceptedFiles[i];
      
      try {
        // Update progress
        setUploadProgress(((i + 1) / acceptedFiles.length) * 50);

        // Convert to base64
        const fileData = await fileToBase64(file);
        
        const document: UploadedDocument = {
          id: `doc_${Date.now()}_${i}`,
          fileName: file.name,
          fileData,
          category: getDocumentCategory(file.name),
          size: file.size,
          uploadedAt: new Date().toISOString()
        };

        newDocuments.push(document);
      } catch (error) {
        console.error(`Error processing file ${file.name}:`, error);
        toast({
          title: "Upload error",
          description: `Failed to process ${file.name}`,
          variant: "destructive"
        });
      }
    }

    // Validate all documents
    const validatedDocuments: UploadedDocument[] = [];
    for (let i = 0; i < newDocuments.length; i++) {
      setUploadProgress(50 + ((i + 1) / newDocuments.length) * 50);
      const validated = await validateDocument(newDocuments[i]);
      validatedDocuments.push(validated);
    }

    const updatedDocuments = [...documents, ...validatedDocuments];
    setDocuments(updatedDocuments);
    onDocumentsChange(updatedDocuments);

    setIsValidating(false);
    setUploadProgress(100);

    // Show validation summary
    const authentic = validatedDocuments.filter(d => d.validationStatus === 'authentic').length;
    const issues = validatedDocuments.length - authentic;

    toast({
      title: "Upload complete",
      description: `${authentic} documents validated${issues > 0 ? `, ${issues} with issues` : ''}`,
      variant: issues > 0 ? "destructive" : "default"
    });

    setTimeout(() => setUploadProgress(0), 1000);
  }, [documents, maxFiles, onDocumentsChange, toast]);

  // Remove document
  const removeDocument = (id: string) => {
    const updatedDocuments = documents.filter(doc => doc.id !== id);
    setDocuments(updatedDocuments);
    onDocumentsChange(updatedDocuments);
  };

  // Dropzone configuration
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'application/pdf': ['.pdf'],
      'image/*': ['.png', '.jpg', '.jpeg'],
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'],
      'application/vnd.ms-excel': ['.xls'],
      'text/csv': ['.csv']
    },
    maxSize: 100 * 1024 * 1024, // 100MB
    disabled: isValidating
  });

  // Get validation status icon
  const getStatusIcon = (status?: string) => {
    switch (status) {
      case 'authentic':
        return <CheckCircle className="h-4 w-4 text-green-500" />;
      case 'suspicious':
        return <AlertCircle className="h-4 w-4 text-yellow-500" />;
      case 'placeholder':
      case 'invalid':
        return <AlertCircle className="h-4 w-4 text-red-500" />;
      default:
        return <FileText className="h-4 w-4 text-gray-500" />;
    }
  };

  // Get status badge variant
  const getStatusVariant = (status?: string) => {
    switch (status) {
      case 'authentic':
        return 'default';
      case 'suspicious':
        return 'secondary';
      case 'placeholder':
      case 'invalid':
        return 'destructive';
      default:
        return 'outline';
    }
  };

  return (
    <div className="space-y-6">
      {/* Upload Area */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center">
            <Upload className="mr-2 h-5 w-5" />
            Document Upload
          </CardTitle>
          <CardDescription>
            Upload your business documents. Accepted formats: PDF, PNG, JPG, XLSX, XLS, CSV
          </CardDescription>
        </CardHeader>
        <CardContent>
          <div
            {...getRootProps()}
            className={`
              border-2 border-dashed rounded-lg p-8 text-center cursor-pointer transition-colors
              ${isDragActive ? 'border-blue-400 bg-blue-50' : 'border-gray-300 hover:border-gray-400'}
              ${isValidating ? 'cursor-not-allowed opacity-50' : ''}
            `}
          >
            <input {...getInputProps()} />
            
            {isValidating ? (
              <div className="space-y-4">
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto"></div>
                <p className="text-gray-600">Processing documents...</p>
                {uploadProgress > 0 && (
                  <div className="max-w-xs mx-auto">
                    <Progress value={uploadProgress} className="h-2" />
                    <p className="text-sm text-gray-500 mt-1">{uploadProgress}%</p>
                  </div>
                )}
              </div>
            ) : isDragActive ? (
              <div className="space-y-2">
                <Upload className="h-12 w-12 text-blue-600 mx-auto" />
                <p className="text-lg font-medium text-blue-600">Drop files here</p>
              </div>
            ) : (
              <div className="space-y-4">
                <Upload className="h-12 w-12 text-gray-400 mx-auto" />
                <div>
                  <p className="text-lg font-medium text-gray-900">
                    Drag and drop files here, or click to browse
                  </p>
                  <p className="text-sm text-gray-500 mt-1">
                    Maximum file size: 100MB • Maximum {maxFiles} files
                  </p>
                </div>
                <Button variant="outline" disabled={isValidating}>
                  Choose Files
                </Button>
              </div>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Required Documents */}
      {requiredDocuments.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="text-lg">Required Documents</CardTitle>
            <CardDescription>
              Based on your loan application, these documents are typically required
            </CardDescription>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
              {requiredDocuments.map((doc, index) => (
                <div key={index} className="flex items-center justify-between p-3 border rounded-lg">
                  <span className="text-sm font-medium">{doc}</span>
                  <Badge variant="outline" className="text-xs">
                    Required
                  </Badge>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}

      {/* Uploaded Documents */}
      {documents.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center justify-between">
              Uploaded Documents
              <Badge variant="secondary">
                {documents.length} file{documents.length !== 1 ? 's' : ''}
              </Badge>
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-3">
              {documents.map((doc) => (
                <div key={doc.id} className="flex items-center justify-between p-4 border rounded-lg hover:bg-gray-50 transition-colors">
                  <div className="flex items-center space-x-3 flex-1">
                    {getStatusIcon(doc.validationStatus)}
                    <div className="flex-1 min-w-0">
                      <p className="font-medium text-sm truncate">{doc.fileName}</p>
                      <div className="flex items-center space-x-2 mt-1">
                        <Badge variant="outline" className="text-xs">
                          {doc.category.replace('_', ' ')}
                        </Badge>
                        <span className="text-xs text-gray-500">
                          {(doc.size / 1024).toFixed(1)} KB
                        </span>
                        {doc.validationStatus && (
                          <Badge variant={getStatusVariant(doc.validationStatus)} className="text-xs">
                            {doc.validationStatus}
                          </Badge>
                        )}
                      </div>
                      {doc.validationErrors && doc.validationErrors.length > 0 && (
                        <div className="mt-2">
                          {doc.validationErrors.map((error, index) => (
                            <p key={index} className="text-xs text-red-600">
                              {error}
                            </p>
                          ))}
                        </div>
                      )}
                    </div>
                  </div>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => removeDocument(doc.id)}
                    className="text-red-600 hover:text-red-700 hover:bg-red-50"
                  >
                    <X className="h-4 w-4" />
                  </Button>
                </div>
              ))}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
```

## 4. Regional Customization

### Regional Formatting Utilities

```typescript
// client/src/lib/regionalFormatting.ts

export interface RegionalSettings {
  country: 'Canada' | 'United States';
  phoneFormat: string;
  postalCodeFormat: string;
  businessNumberFormat: string;
  businessNumberLabel: string;
  stateProvinceLabel: string;
  stateProvinceOptions: Array<{ value: string; label: string }>;
}

export const REGIONAL_SETTINGS: Record<string, RegionalSettings> = {
  'canada': {
    country: 'Canada',
    phoneFormat: '(XXX) XXX-XXXX',
    postalCodeFormat: 'A1A 1A1',
    businessNumberFormat: '123456789RP0001',
    businessNumberLabel: 'Business Number (BN)',
    stateProvinceLabel: 'Province',
    stateProvinceOptions: [
      { value: 'AB', label: 'Alberta' },
      { value: 'BC', label: 'British Columbia' },
      { value: 'MB', label: 'Manitoba' },
      { value: 'NB', label: 'New Brunswick' },
      { value: 'NL', label: 'Newfoundland and Labrador' },
      { value: 'NS', label: 'Nova Scotia' },
      { value: 'ON', label: 'Ontario' },
      { value: 'PE', label: 'Prince Edward Island' },
      { value: 'QC', label: 'Quebec' },
      { value: 'SK', label: 'Saskatchewan' },
      { value: 'NT', label: 'Northwest Territories' },
      { value: 'NU', label: 'Nunavut' },
      { value: 'YT', label: 'Yukon' }
    ]
  },
  'united_states': {
    country: 'United States',
    phoneFormat: '(XXX) XXX-XXXX',
    postalCodeFormat: '12345-6789',
    businessNumberFormat: '12-3456789',
    businessNumberLabel: 'Employer Identification Number (EIN)',
    stateProvinceLabel: 'State',
    stateProvinceOptions: [
      { value: 'AL', label: 'Alabama' },
      { value: 'AK', label: 'Alaska' },
      { value: 'AZ', label: 'Arizona' },
      { value: 'AR', label: 'Arkansas' },
      { value: 'CA', label: 'California' },
      { value: 'CO', label: 'Colorado' },
      { value: 'CT', label: 'Connecticut' },
      { value: 'DE', label: 'Delaware' },
      { value: 'DC', label: 'District of Columbia' },
      { value: 'FL', label: 'Florida' },
      { value: 'GA', label: 'Georgia' },
      { value: 'HI', label: 'Hawaii' },
      { value: 'ID', label: 'Idaho' },
      { value: 'IL', label: 'Illinois' },
      { value: 'IN', label: 'Indiana' },
      { value: 'IA', label: 'Iowa' },
      { value: 'KS', label: 'Kansas' },
      { value: 'KY', label: 'Kentucky' },
      { value: 'LA', label: 'Louisiana' },
      { value: 'ME', label: 'Maine' },
      { value: 'MD', label: 'Maryland' },
      { value: 'MA', label: 'Massachusetts' },
      { value: 'MI', label: 'Michigan' },
      { value: 'MN', label: 'Minnesota' },
      { value: 'MS', label: 'Mississippi' },
      { value: 'MO', label: 'Missouri' },
      { value: 'MT', label: 'Montana' },
      { value: 'NE', label: 'Nebraska' },
      { value: 'NV', label: 'Nevada' },
      { value: 'NH', label: 'New Hampshire' },
      { value: 'NJ', label: 'New Jersey' },
      { value: 'NM', label: 'New Mexico' },
      { value: 'NY', label: 'New York' },
      { value: 'NC', label: 'North Carolina' },
      { value: 'ND', label: 'North Dakota' },
      { value: 'OH', label: 'Ohio' },
      { value: 'OK', label: 'Oklahoma' },
      { value: 'OR', label: 'Oregon' },
      { value: 'PA', label: 'Pennsylvania' },
      { value: 'RI', label: 'Rhode Island' },
      { value: 'SC', label: 'South Carolina' },
      { value: 'SD', label: 'South Dakota' },
      { value: 'TN', label: 'Tennessee' },
      { value: 'TX', label: 'Texas' },
      { value: 'UT', label: 'Utah' },
      { value: 'VT', label: 'Vermont' },
      { value: 'VA', label: 'Virginia' },
      { value: 'WA', label: 'Washington' },
      { value: 'WV', label: 'West Virginia' },
      { value: 'WI', label: 'Wisconsin' },
      { value: 'WY', label: 'Wyoming' }
    ]
  }
};

// Phone number formatting
export function formatPhoneNumber(value: string, country: string): string {
  // Remove all non-digits
  const digits = value.replace(/\D/g, '');
  
  // Apply (XXX) XXX-XXXX format for both US and Canada
  if (digits.length >= 10) {
    return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6, 10)}`;
  } else if (digits.length >= 6) {
    return `(${digits.slice(0, 3)}) ${digits.slice(3, 6)}-${digits.slice(6)}`;
  } else if (digits.length >= 3) {
    return `(${digits.slice(0, 3)}) ${digits.slice(3)}`;
  } else if (digits.length > 0) {
    return `(${digits}`;
  }
  
  return '';
}

// Postal code formatting
export function formatPostalCode(value: string, country: string): string {
  const settings = REGIONAL_SETTINGS[country];
  if (!settings) return value;

  if (country === 'canada') {
    // Canadian format: A1A 1A1
    const alphanumeric = value.replace(/[^A-Za-z0-9]/g, '').toUpperCase();
    if (alphanumeric.length >= 6) {
      return `${alphanumeric.slice(0, 3)} ${alphanumeric.slice(3, 6)}`;
    } else if (alphanumeric.length >= 3) {
      return `${alphanumeric.slice(0, 3)} ${alphanumeric.slice(3)}`;
    }
    return alphanumeric;
  } else {
    // US format: 12345-6789
    const digits = value.replace(/\D/g, '');
    if (digits.length >= 9) {
      return `${digits.slice(0, 5)}-${digits.slice(5, 9)}`;
    } else if (digits.length >= 5) {
      return `${digits.slice(0, 5)}-${digits.slice(5)}`;
    }
    return digits;
  }
}

// Business number formatting
export function formatBusinessNumber(value: string, country: string): string {
  const settings = REGIONAL_SETTINGS[country];
  if (!settings) return value;

  if (country === 'canada') {
    // Canadian format: 123456789RP0001
    const alphanumeric = value.replace(/[^A-Za-z0-9]/g, '').toUpperCase();
    if (alphanumeric.length >= 9) {
      const numbers = alphanumeric.slice(0, 9);
      const suffix = alphanumeric.slice(9);
      if (suffix.length >= 2) {
        return `${numbers}${suffix.slice(0, 2)}${suffix.slice(2)}`;
      }
      return `${numbers}${suffix}`;
    }
    return alphanumeric;
  } else {
    // US EIN format: 12-3456789
    const digits = value.replace(/\D/g, '');
    if (digits.length >= 9) {
      return `${digits.slice(0, 2)}-${digits.slice(2, 9)}`;
    } else if (digits.length >= 2) {
      return `${digits.slice(0, 2)}-${digits.slice(2)}`;
    }
    return digits;
  }
}

// Currency formatting
export function formatCurrency(value: string): string {
  // Remove all non-digits
  const digits = value.replace(/\D/g, '');
  
  if (digits === '') return '';
  
  // Convert to number and format with commas
  const number = parseInt(digits, 10);
  return number.toLocaleString();
}

// SIN/SSN formatting
export function formatSocialInsuranceNumber(value: string, country: string): string {
  const digits = value.replace(/\D/g, '');
  
  if (country === 'canada') {
    // Canadian SIN format: XXX XXX XXX
    if (digits.length >= 9) {
      return `${digits.slice(0, 3)} ${digits.slice(3, 6)} ${digits.slice(6, 9)}`;
    } else if (digits.length >= 6) {
      return `${digits.slice(0, 3)} ${digits.slice(3, 6)} ${digits.slice(6)}`;
    } else if (digits.length >= 3) {
      return `${digits.slice(0, 3)} ${digits.slice(3)}`;
    }
    return digits;
  } else {
    // US SSN format: XXX-XX-XXXX
    if (digits.length >= 9) {
      return `${digits.slice(0, 3)}-${digits.slice(3, 5)}-${digits.slice(5, 9)}`;
    } else if (digits.length >= 5) {
      return `${digits.slice(0, 3)}-${digits.slice(3, 5)}-${digits.slice(5)}`;
    } else if (digits.length >= 3) {
      return `${digits.slice(0, 3)}-${digits.slice(3)}`;
    }
    return digits;
  }
}

// Get regional settings helper
export function getRegionalSettings(country: string): RegionalSettings | null {
  return REGIONAL_SETTINGS[country] || null;
}

// Validate postal code format
export function validatePostalCode(value: string, country: string): boolean {
  if (country === 'canada') {
    // Canadian postal code: A1A 1A1
    const pattern = /^[A-Za-z]\d[A-Za-z] \d[A-Za-z]\d$/;
    return pattern.test(value);
  } else {
    // US ZIP code: 12345 or 12345-6789
    const pattern = /^\d{5}(-\d{4})?$/;
    return pattern.test(value);
  }
}

// Validate business number format
export function validateBusinessNumber(value: string, country: string): boolean {
  if (country === 'canada') {
    // Canadian BN: 9 digits + 2 letters + 4 digits
    const pattern = /^\d{9}[A-Za-z]{2}\d{4}$/;
    return pattern.test(value.replace(/\s/g, ''));
  } else {
    // US EIN: XX-XXXXXXX
    const pattern = /^\d{2}-\d{7}$/;
    return pattern.test(value);
  }
}
```

### Regional Form Fields Component

```typescript
// client/src/components/RegionalFormFields.tsx
import React, { useEffect } from 'react';
import { UseFormReturn } from 'react-hook-form';
import { FormField, FormItem, FormLabel, FormControl, FormMessage } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { 
  getRegionalSettings, 
  formatPhoneNumber, 
  formatPostalCode, 
  formatBusinessNumber,
  formatSocialInsuranceNumber,
  validatePostalCode,
  validateBusinessNumber
} from '@/lib/regionalFormatting';

interface RegionalFormFieldsProps {
  form: UseFormReturn<any>;
  country: string;
  fieldPrefix?: string;
  showBusinessNumber?: boolean;
  showSocialInsurance?: boolean;
  requiredFields?: string[];
}

export function RegionalFormFields({ 
  form, 
  country, 
  fieldPrefix = '',
  showBusinessNumber = false,
  showSocialInsurance = false,
  requiredFields = []
}: RegionalFormFieldsProps) {
  const settings = getRegionalSettings(country);
  
  if (!settings) {
    return null;
  }

  const getFieldName = (field: string) => fieldPrefix ? `${fieldPrefix}.${field}` : field;
  const isRequired = (field: string) => requiredFields.includes(field);

  return (
    <div className="space-y-4">
      {/* Phone Number */}
      <FormField
        control={form.control}
        name={getFieldName('phone')}
        render={({ field }) => (
          <FormItem>
            <FormLabel>
              Phone Number {isRequired('phone') && <span className="text-red-500">*</span>}
            </FormLabel>
            <FormControl>
              <Input
                placeholder={settings.phoneFormat}
                {...field}
                onChange={(e) => {
                  const formatted = formatPhoneNumber(e.target.value, country);
                  field.onChange(formatted);
                }}
                maxLength={14}
              />
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />

      {/* Address Fields */}
      <FormField
        control={form.control}
        name={getFieldName('streetAddress')}
        render={({ field }) => (
          <FormItem>
            <FormLabel>
              Street Address {isRequired('streetAddress') && <span className="text-red-500">*</span>}
            </FormLabel>
            <FormControl>
              <Input placeholder="123 Main Street" {...field} />
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <FormField
          control={form.control}
          name={getFieldName('city')}
          render={({ field }) => (
            <FormItem>
              <FormLabel>
                City {isRequired('city') && <span className="text-red-500">*</span>}
              </FormLabel>
              <FormControl>
                <Input placeholder="Toronto" {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <FormField
          control={form.control}
          name={getFieldName('state')}
          render={({ field }) => (
            <FormItem>
              <FormLabel>
                {settings.stateProvinceLabel} {isRequired('state') && <span className="text-red-500">*</span>}
              </FormLabel>
              <Select onValueChange={field.onChange} defaultValue={field.value}>
                <FormControl>
                  <SelectTrigger>
                    <SelectValue placeholder={`Select ${settings.stateProvinceLabel.toLowerCase()}`} />
                  </SelectTrigger>
                </FormControl>
                <SelectContent>
                  {settings.stateProvinceOptions.map((option) => (
                    <SelectItem key={option.value} value={option.value}>
                      {option.label}
                    </SelectItem>
                  ))}
                </SelectContent>
              </Select>
              <FormMessage />
            </FormItem>
          )}
        />
      </div>

      <FormField
        control={form.control}
        name={getFieldName('postalCode')}
        render={({ field }) => (
          <FormItem>
            <FormLabel>
              {country === 'canada' ? 'Postal Code' : 'ZIP Code'} {isRequired('postalCode') && <span className="text-red-500">*</span>}
            </FormLabel>
            <FormControl>
              <Input
                placeholder={settings.postalCodeFormat}
                {...field}
                onChange={(e) => {
                  const formatted = formatPostalCode(e.target.value, country);
                  field.onChange(formatted);
                }}
                maxLength={country === 'canada' ? 7 : 10}
              />
            </FormControl>
            <FormMessage />
          </FormItem>
        )}
      />

      {/* Business Number (optional) */}
      {showBusinessNumber && (
        <FormField
          control={form.control}
          name={getFieldName('businessNumber')}
          render={({ field }) => (
            <FormItem>
              <FormLabel>
                {settings.businessNumberLabel} {isRequired('businessNumber') && <span className="text-red-500">*</span>}
              </FormLabel>
              <FormControl>
                <Input
                  placeholder={settings.businessNumberFormat}
                  {...field}
                  onChange={(e) => {
                    const formatted = formatBusinessNumber(e.target.value, country);
                    field.onChange(formatted);
                  }}
                  maxLength={country === 'canada' ? 15 : 10}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      )}

      {/* Social Insurance Number / SSN (optional) */}
      {showSocialInsurance && (
        <FormField
          control={form.control}
          name={getFieldName('socialInsuranceNumber')}
          render={({ field }) => (
            <FormItem>
              <FormLabel>
                {country === 'canada' ? 'Social Insurance Number (SIN)' : 'Social Security Number (SSN)'} {isRequired('socialInsuranceNumber') && <span className="text-red-500">*</span>}
              </FormLabel>
              <FormControl>
                <Input
                  placeholder={country === 'canada' ? 'XXX XXX XXX' : 'XXX-XX-XXXX'}
                  {...field}
                  onChange={(e) => {
                    const formatted = formatSocialInsuranceNumber(e.target.value, country);
                    field.onChange(formatted);
                  }}
                  maxLength={country === 'canada' ? 11 : 11}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
      )}
    </div>
  );
}
```

## Implementation Summary

This comprehensive guide provides all the code and instructions needed to implement:

1. **Intelligent Recommendation Engine** - Dynamic product filtering with real-time analysis
2. **Authentication & Security System** - Session-based auth with bcrypt password security
3. **Document Management System** - Complete validation with authenticity detection
4. **Regional Customization** - Dynamic formatting for Canada/US markets

Each component includes:
- Complete TypeScript implementations
- Database schemas and API endpoints
- Frontend React components with proper validation
- Error handling and user feedback
- Production-ready configurations

The code is designed to be modular and can be implemented incrementally while maintaining full functionality at each stage.