Got it — Step 2 is still stuck on “Product Matching Pending”. From your screenshots/logs I see two hard blockers:

1. the client is still booting the **local cache** path (“Found 42 products in local cache”) even when the Staff API is healthy, and
2. Step-1 intake isn’t guaranteed to be **persisted/normalized** to what Step-2 expects.

Here’s a precise, surgical set of fixes. You can paste these in exactly as shown.

---

# 1) Force API (never use local cache unless API actually fails)

**Create** `client/src/lib/env.ts`

```ts
export const API_BASE =
  import.meta.env.VITE_STAFF_API_URL ?? "https://staff.boreal.financial/api";

export const SHARED_TOKEN =
  import.meta.env.VITE_CLIENT_APP_SHARED_TOKEN ?? "";

const FALLBACK =
  (import.meta.env.VITE_LOCAL_FALLBACK ?? "false").toLowerCase() === "true";

// Safety valve: always try API first; only use local cache *if* API fails.
export const USE_API_FIRST = true;
export const MAY_FALLBACK = FALLBACK; // keep the flag if you really want it
```

**Replace** your product fetcher with this (e.g. `client/src/api/products.ts`):

```ts
import { API_BASE, SHARED_TOKEN, USE_API_FIRST, MAY_FALLBACK } from "@/lib/env";

export async function fetchProducts() {
  if (USE_API_FIRST) {
    try {
      const res = await fetch(`${API_BASE}/v1/products`, {
        headers: { Authorization: `Bearer ${SHARED_TOKEN}` },
      });
      if (res.ok) return await res.json();
      console.warn("API /v1/products failed", res.status);
    } catch (e) {
      console.warn("API /v1/products error", e);
    }
  }
  if (MAY_FALLBACK) {
    const data = (await import("@/data/products.json")).default;
    return data;
  }
  throw new Error("Products unavailable (API failed and fallback disabled).");
}
```

**(Optional same pattern)** for `client/src/api/requiredDocs.ts`:

```ts
import { API_BASE, SHARED_TOKEN, USE_API_FIRST, MAY_FALLBACK } from "@/lib/env";

export async function fetchRequiredDocs(productId: string) {
  if (USE_API_FIRST) {
    try {
      const res = await fetch(`${API_BASE}/required-docs?productId=${encodeURIComponent(productId)}`, {
        headers: { Authorization: `Bearer ${SHARED_TOKEN}` },
      });
      if (res.ok) return await res.json();
      console.warn("API /required-docs failed", res.status);
    } catch (e) {
      console.warn("API /required-docs error", e);
    }
  }
  if (MAY_FALLBACK) {
    const data = (await import("@/data/required-docs.json")).default;
    return data[productId] ?? [];
  }
  throw new Error("Required docs unavailable.");
}
```

> Result: the “local lender products cache is ready” route won’t be used unless the API truly fails.

---

# 2) Persist & normalize Step-1 → Step-2 data (the usual reason for “Pending”)

**Update** `client/src/context/FormDataContext.tsx` (or equivalent) so Step-1 values persist across navigation/reload and match Step-2’s expectations:

```ts
import React, { createContext, useContext, useEffect, useMemo, useState } from "react";

export type ApplicationForm = {
  // keep both names to survive older forms/agents
  requestedAmount?: number;      // preferred
  fundingAmount?: number;        // legacy
  businessLocation?: string;
  industry?: string;
  purpose?: string;
  yearsInBusiness?: string | number;
  last12moRevenue?: number | string;
  avgMonthlyRevenue?: number | string;
  arBalance?: number | string;
  fixedAssets?: number | string;
  // ...any other fields you actually use in the matcher
};

const KEY = "bf:intake:v2";

function toNum(x: any) {
  if (x == null) return undefined;
  if (typeof x === "number") return x;
  // strip $, commas, spaces
  const n = Number(String(x).replace(/[$, ]/g, ""));
  return Number.isFinite(n) ? n : undefined;
}

export function normalize(raw: Partial<ApplicationForm>): ApplicationForm {
  return {
    requestedAmount: toNum(raw.requestedAmount ?? raw.fundingAmount ?? (raw as any).howMuchFunding),
    fundingAmount:   toNum(raw.fundingAmount ?? raw.requestedAmount),
    businessLocation: raw.businessLocation ?? (raw as any).location,
    industry: raw.industry,
    purpose: raw.purpose ?? (raw as any).purposeOfFunds,
    yearsInBusiness: raw.yearsInBusiness ?? (raw as any).yearsHistory,
    last12moRevenue: toNum(raw.last12moRevenue ?? (raw as any).last12MonthsRevenue),
    avgMonthlyRevenue: toNum(raw.avgMonthlyRevenue ?? (raw as any).avgMonthly),
    arBalance: toNum(raw.arBalance ?? (raw as any).currentAR),
    fixedAssets: toNum(raw.fixedAssets ?? (raw as any).fixedAssetsValue),
  };
}

type Ctx = {
  data: ApplicationForm | null;
  save: (d: Partial<ApplicationForm>) => void;
  clear: () => void;
  isComplete: boolean;
};
const Ctx = createContext<Ctx | null>(null);

export function FormDataProvider({ children }: { children: React.ReactNode }) {
  const [data, setData] = useState<ApplicationForm | null>(() => {
    try { return JSON.parse(sessionStorage.getItem(KEY) || "null"); } catch { return null; }
  });

  const save = (raw: Partial<ApplicationForm>) => {
    const merged = normalize({ ...(data ?? {}), ...raw });
    setData(merged);
  };

  const clear = () => setData(null);

  useEffect(() => {
    if (data) sessionStorage.setItem(KEY, JSON.stringify(data));
    else sessionStorage.removeItem(KEY);
  }, [data]);

  const isComplete = !!(data?.requestedAmount ?? data?.fundingAmount);

  const value = useMemo(() => ({ data, save, clear, isComplete }), [data, isComplete]);
  return <Ctx.Provider value={value}>{children}</Ctx.Provider>;
}
export const useFormData = () => {
  const v = useContext(Ctx);
  if (!v) throw new Error("useFormData outside provider");
  return v;
};
```

**Step-1** (continue button) — guarantee save **before** navigate:

```ts
// inside Step 1 submit handler
const { save } = useFormData();
const onContinue = (values: any) => {
  save(values);              // persist normalized data
  navigate("/apply/step-2"); // then go
};
```

**Step-2** — short-circuit the “Pending” panel and show *why* it would be pending:

```tsx
import { useEffect, useState } from "react";
import { useFormData } from "@/context/FormDataContext";
import { fetchProducts } from "@/api/products";

export default function Step2RecommendationEngine() {
  const { data, isComplete } = useFormData();
  const [products, setProducts] = useState<any[] | null>(null);
  const [reason, setReason] = useState<string | null>(null);

  useEffect(() => {
    if (!isComplete) {
      setReason("Missing or unnormalized Step-1 values (amount, etc.)");
      return;
    }
    fetchProducts()
      .then((p) => setProducts(p))
      .catch((e) => setReason(`Failed to load products: ${e}`));
  }, [isComplete]);

  // expose quick debug in dev
  (window as any).__step2 = { data, isComplete, productsCount: products?.length, reason };

  if (!isComplete || !products) {
    return (
      <div className="mx-auto max-w-xl">
        <div className="rounded-lg border p-4">
          <div className="font-medium">Product Matching Pending</div>
          <div className="text-sm text-muted-foreground">
            {reason ?? "Loading…"}
          </div>
        </div>
      </div>
    );
  }

  // …run your eligibility/scoring here with `data` and `products`
  return <YourMatchesList data={data} products={products} />;
}
```

---

# 3) Quick smoke tests (run these in the **client** shell)

```bash
# Confirm token fingerprint & base URL
node -e 'const c=require("crypto");console.log("fp:",c.createHash("sha256").update(process.env.VITE_CLIENT_APP_SHARED_TOKEN||"").digest("hex").slice(0,12))'
echo "$VITE_STAFF_API_URL"

# Must print 44 / ~30 / 2
BASE="${VITE_STAFF_API_URL:-https://staff.boreal.financial/api}"
TOK="$VITE_CLIENT_APP_SHARED_TOKEN"
echo -n "products: "; curl -s -H "Authorization: Bearer $TOK" "$BASE/v1/products" | jq 'length'
echo -n "lenders:  "; curl -s -H "Authorization: Bearer $TOK" "$BASE/lenders"       | jq 'length'
echo -n "reqdocs:  "; curl -s -H "Authorization: Bearer $TOK" "$BASE/required-docs"  | jq 'length'
```

If those counts are correct (they should be) but Step-2 still shows “Pending”, the cause is exclusively intake persistence/normalization — the patches above resolve that.

---

# 4) Ignore these — they’re red herrings

* `service-worker.js: Failed to execute 'addAll' on 'Cache'` in Replit preview
* “Unrecognized feature: legacy-image-formats”, “speaker-selection”, etc.

They don’t block Step-2 rendering.

---

# 5) Step-5 (documents) hook-up (after Step-2 picks a product)

When a user selects a product card:

```ts
import { fetchRequiredDocs } from "@/api/requiredDocs";

async function onSelectProduct(p: { id: string }) {
  const docs = await fetchRequiredDocs(p.id);
  // store to context/state and navigate to step-5
  navigate("/apply/step-5", { state: { productId: p.id, docs } });
}
```

---

## What you should see after these changes

* The client no longer prints “local lender products cache is ready”.
* Network tab shows a real call to `…/api/v1/products` with 200 and \~44 items.
* `window.__step2` shows `{ isComplete: true, productsCount: 44 }`.
* Step-2 renders matched lender/product cards instead of “Pending”.

If you paste the snippets as-is and still see “Pending”, open the dev console and run:

```js
window.__step2
```

Tell me what it prints — that single object will pinpoint any remaining gap instantly.
