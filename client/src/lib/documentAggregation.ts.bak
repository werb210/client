import { fetchProducts } from "../api/products";
/**
 * Document Aggregation Logic for Step 5
 * Implements union of all required documents across eligible lender products
 * Based on ChatGPT team specifications
 */

// Document aggregation with normalization support
import { normalizeDocumentName } from '../../../shared/documentMapping';
import { getDocumentLabel } from '../../../shared/documentTypes';

interface LenderProduct {
  id: string;
  name: string;
  lender_name: string;
  category: string;
  country: string;
  min_amount: number;
  max_amount: number;
  doc_requirements?: string[];
  documentRequirements?: string[];
  requiredDocuments?: string[];
  required_documents?: string[];
}

interface DocumentAggregationResult {
  eligibleProducts: LenderProduct[];
  requiredDocuments: string[];
  message: string;
  hasMatches: boolean;
}

/**
 * Get document requirements using aggregation logic (union of all eligible products)
 * Following ChatGPT team specifications for complete document collection
 */
interface UserProfile {
  businessStructure?: string;
  businessStartDate?: string;
  ownershipPercentage?: number;
  applicantSSN?: string;
  hasPartner?: boolean;
  legalName?: string;
  operatingName?: string;
}

export async function getDocumentRequirementsAggregation(
  selectedCategory: string,
  selectedCountry: string,
  requestedAmount: number,
  userProfile: UserProfile = { /* ensure products fetched */ }
): Promise<DocumentAggregationResult> {
  
  console.log(`üîç [AGGREGATION] Starting document aggregation for: "${selectedCategory}" in ${selectedCountry} for $${requestedAmount.toLocaleString()}`);
  console.log(`üîç [AGGREGATION] User profile:`, {
    businessStructure: userProfile.businessStructure || 'not provided',
    ownershipPercentage: userProfile.ownershipPercentage || 'not provided',
    hasSSN: userProfile.applicantSSN ? 'yes' : 'no',
    hasPartner: userProfile.hasPartner || false
  });
  
  try {
    // Fetch all lender products from staff API - FIXED ENDPOINT
    const { fetchProducts } = await import('../api/products');
    const allProducts = await fetchProducts();
    
    if (allProducts.length === 0) {
      throw new Error(`Staff API error: ${response.status}`);
    }
    
    console.log(`üìä [AGGREGATION] Products fetched successfully, processing data...`);
    console.log(`üì¶ [AGGREGATION] Product count: ${allProducts.length} products`);
    
    // ‚úÖ CRITICAL FIX: Map Step 2 category names to backend category names
    const categoryMappings: Record<string, string[]> = {
      'Working Capital': ['Working Capital', 'working_capital', 'Working Capital Loan'],
      'Term Loan': ['Term Loan', 'term_loan', 'Term Loans'],
      'Business Line of Credit': ['Line of Credit', 'line_of_credit', 'Business Line of Credit', 'LOC'],
      'Equipment Financing': ['Equipment Financing', 'equipment_financing', 'Equipment Finance'],
      'Invoice Factoring': ['Invoice Factoring', 'invoice_factoring', 'Factoring'],
      'Purchase Order Financing': ['Purchase Order Financing', 'purchase_order_financing', 'PO Financing'],
      'Asset-Based Lending': ['Asset-Based Lending', 'asset_based_lending', 'ABL']
    };
    
    const mappedCategories = categoryMappings[selectedCategory] || [selectedCategory];
    console.log(`üóÇÔ∏è [AGGREGATION] Category "${selectedCategory}" mapped to: [${mappedCategories.join(', ')}]`);
    
    // Normalize country format
    const normalizedCountry = selectedCountry === 'canada' || selectedCountry === 'Canada' ? 'CA' :
                             selectedCountry === 'united-states' || selectedCountry === 'United States' ? 'US' :
                             selectedCountry;
    
    console.log(`üåç [AGGREGATION] Country normalized: "${selectedCountry}" ‚Üí "${normalizedCountry}"`);
    
    // ‚úÖ STEP 1: Filter all local lender products that match criteria - FIXED FIELD NAMES
    const eligibleProducts = allProducts.filter((product: any) => {
      // Category match - use flexible mapping - FIXED FIELD NAME
      const categoryMatch = mappedCategories.some(cat => 
        product.productCategory === cat || 
        product.productCategory?.toLowerCase() === cat.toLowerCase() ||
        product.productType === cat ||
        product.type === cat
      );
      
      // Country match - FIXED FIELD NAME
      const countryMatch = product.countryOffered === normalizedCountry || 
                          product.geography === normalizedCountry ||
                          product.region === normalizedCountry;
      
      // Amount range match - FIXED FIELD NAMES
      const minAmount = product.minimumLendingAmount || product.amountMin || product.amount_min || 0;
      const maxAmount = product.maximumLendingAmount || product.amountMax || product.amount_max || Number.MAX_SAFE_INTEGER;
      const amountMatch = minAmount <= requestedAmount && maxAmount >= requestedAmount;
      
      const isEligible = categoryMatch && countryMatch && amountMatch;
      
      // Enhanced logging for debugging - FIXED FIELD NAMES
      console.log(`üß™ [AGGREGATION] Product "${product.productName || product.lenderName}" - Category: ${categoryMatch ? '‚úÖ' : '‚ùå'} (${product.productCategory}), Country: ${countryMatch ? '‚úÖ' : '‚ùå'} (${product.countryOffered}), Amount: ${amountMatch ? '‚úÖ' : '‚ùå'} ($${minAmount}-$${maxAmount}), Eligible: ${isEligible ? '‚úÖ' : '‚ùå'}`);
      
      return isEligible;
    });
    
    console.log(`üéØ [AGGREGATION] Filtering complete: ${eligibleProducts.length} eligible products found`);
    
    if (eligibleProducts.length === 0) {
      console.log(`‚ùå [AGGREGATION] No products match criteria - providing fallback documents`);
      
      // ‚úÖ FALLBACK LOGIC: If no products match, provide standard documents based on category
      const fallbackDocuments = getFallbackDocumentsForCategory(selectedCategory);
      
      return {
        eligibleProducts: [],
        requiredDocuments: fallbackDocuments,
        message: `No exact matches found for ${selectedCategory} in ${selectedCountry} for $${requestedAmount.toLocaleString()}. Showing standard documents for ${selectedCategory}.`,
        hasMatches: false
      };
    }
    
    // ‚úÖ STEP 2: Aggregate and deduplicate required documents (UNION) - ENHANCED WITH NORMALIZATION
    // Following user specifications for canonical document type normalization
    const { mapToBackendDocumentType } = await import('./docNormalization');
    
    // Extract and normalize document requirements from all eligible products
    const allDocuments = new Set<string>();
    eligibleProducts.forEach(product => {
      const docRequirements = product.doc_requirements || 
                            product.documentRequirements || 
                            product.requiredDocuments || 
                            product.required_documents || 
                            [];
      
      docRequirements.forEach((doc: string) => {
        if (doc && typeof doc === 'string') {
          const normalized = mapToBackendDocumentType(doc);
          allDocuments.add(normalized);
        }
      });
    });
    
    const canonicalDocTypes = Array.from(allDocuments);
    console.log(`üîç [AGGREGATION] Normalized to ${canonicalDocTypes.length} canonical document types:`, canonicalDocTypes);
    
    // Convert canonical types to display labels for UI
    const transformedDocuments = canonicalDocTypes.map((docType: string) => {
      // Convert backend type to display label
      const displayLabel = docType.split('_').map(word => 
        word.charAt(0).toUpperCase() + word.slice(1)
      ).join(' ');
      
      console.log(`‚úÖ [AGGREGATION] Canonical document: ${docType} ‚Üí "${displayLabel}"`);
      return displayLabel;
    });
    
    // ‚úÖ ENHANCED: Add business structure-specific documents
    const getBusinessStructureDocuments = (structure: string): string[] => {
      const structureDocs: Record<string, string[]> = {
        'llc': ['Operating Agreement', 'Articles of Organization', 'Member Resolution'],
        'corporation': ['Corporate Bylaws', 'Articles of Incorporation', 'Board Resolution', 'Stock Certificates'],
        'partnership': ['Partnership Agreement', 'Partnership Registration'],
        'sole_proprietorship': ['DBA Filing', 'Personal Financial Statement'],
        'sole proprietorship': ['DBA Filing', 'Personal Financial Statement']
      };
      return structureDocs[structure?.toLowerCase()] || [];
    };

    // ‚úÖ ENHANCED: Add ownership-based documents  
    const getOwnershipDocuments = (ownershipPercentage: number): string[] => {
      if (ownershipPercentage >= 50) {
        return ['Personal Guarantee', 'Personal Financial Statement', 'Personal Credit Report Authorization'];
      }
      return [];
    };

    // ‚úÖ ENHANCED: Add SSN/identity documents
    const getIdentityDocuments = (hasSSN: boolean): string[] => {
      if (hasSSN) {
        return ['Driver License', 'Social Security Card Copy'];
      }
      return ['Government ID', 'Proof of Identity'];
    };

    // ‚úÖ NEW: Add user profile-based documents
    const profileBasedDocs = new Set<string>();
    
    if (userProfile.businessStructure) {
      getBusinessStructureDocuments(userProfile.businessStructure).forEach(doc => 
        profileBasedDocs.add(doc)
      );
      console.log(`üè¢ [PROFILE] Added ${getBusinessStructureDocuments(userProfile.businessStructure).length} business structure documents for ${userProfile.businessStructure}`);
    }
    
    if (userProfile.ownershipPercentage && userProfile.ownershipPercentage > 0) {
      getOwnershipDocuments(userProfile.ownershipPercentage).forEach(doc => 
        profileBasedDocs.add(doc)
      );
      console.log(`üë§ [PROFILE] Added ${getOwnershipDocuments(userProfile.ownershipPercentage).length} ownership documents for ${userProfile.ownershipPercentage}% ownership`);
    }
    
    if (userProfile.applicantSSN !== undefined) {
      getIdentityDocuments(!!userProfile.applicantSSN).forEach(doc => 
        profileBasedDocs.add(doc)
      );
      console.log(`üÜî [PROFILE] Added ${getIdentityDocuments(!!userProfile.applicantSSN).length} identity documents`);
    }

    // Combine lender-based and profile-based documents
    const finalDocuments = [...transformedDocuments, ...Array.from(profileBasedDocs)];
    const uniqueDocuments = [...new Set(finalDocuments)]; // Remove duplicates
    
    console.log(`‚úÖ [AGGREGATION] Combined ${transformedDocuments.length} lender docs + ${profileBasedDocs.size} profile docs = ${uniqueDocuments.length} total unique documents`);
    
    return {
      eligibleProducts,
      requiredDocuments: uniqueDocuments,
      message: `Documents required across ${eligibleProducts.length} eligible ${selectedCategory} lenders${profileBasedDocs.size > 0 ? ` plus ${profileBasedDocs.size} profile-specific documents` : ''}`,
      hasMatches: true
    };
    
  } catch (error) {
    console.error('‚ùå [AGGREGATION] Error calculating document requirements:', error);
    
    // Provide fallback documents even on error
    const fallbackDocuments = getFallbackDocumentsForCategory(selectedCategory);
    
    return {
      eligibleProducts: [],
      requiredDocuments: fallbackDocuments,
      message: `Error fetching requirements (${error instanceof Error ? error.message : 'Unknown error'}). Showing standard documents for ${selectedCategory}.`,
      hasMatches: false
    };
  }
}

/**
 * Get fallback document requirements when no products match
 */
function getFallbackDocumentsForCategory(category: string): string[] {
  const fallbackMappings: Record<string, string[]> = {
    'Working Capital': ['Bank Statements', 'Financial Statements', 'Business Tax Returns'],
    'Term Loan': ['Bank Statements', 'Business Tax Returns', 'Financial Statements', 'Cash Flow Statement'],
    'Business Line of Credit': ['Bank Statements', 'Financial Statements', 'Business Tax Returns'],
    'Equipment Financing': ['Equipment Quote', 'Bank Statements', 'Business Tax Returns'],
    'Invoice Factoring': ['Accounts Receivable Aging', 'Bank Statements', 'Invoice Samples'],
    'Purchase Order Financing': ['Purchase Orders', 'Bank Statements', 'Customer Credit Information'],
    'Asset-Based Lending': ['Asset Valuation', 'Bank Statements', 'Financial Statements']
  };
  
  const documents = fallbackMappings[category] || ['Bank Statements', 'Business Tax Returns', 'Financial Statements'];
  console.log(`üîÑ [FALLBACK] Providing ${documents.length} fallback documents for category "${category}": [${documents.join(', ')}]`);
  
  return documents;
}

/**
 * Helper function to validate that all lender products have required document fields
 */
export async function validateLenderProductDocumentFields(): Promise<{
  totalProducts: number;
  productsWithDocuments: number;
  missingDocumentFields: string[];
  sampleDocumentField: string;
}> {
  try {
    const { fetchProducts } = await import('../api/products');
    const allProducts = await fetchProducts();
    
    if (!allProducts || allProducts.length === 0) {
      throw new Error('Failed to fetch products');
    }
    
    const products = allProducts;
    const totalProducts = products.length;
    
    let productsWithDocuments = 0;
    let sampleDocumentField = '';
    const missingDocumentFields: string[] = [];
    
    products.forEach((product: LenderProduct, index: number) => {
      const hasDocuments = !!(
        product.doc_requirements ||
        product.documentRequirements ||
        product.requiredDocuments ||
        product.required_documents
      );
      
      if (hasDocuments) {
        productsWithDocuments++;
        if (!sampleDocumentField) {
          if (product.doc_requirements) sampleDocumentField = 'doc_requirements';
          else if (product.documentRequirements) sampleDocumentField = 'documentRequirements';
          else if (product.requiredDocuments) sampleDocumentField = 'requiredDocuments';
          else if (product.required_documents) sampleDocumentField = 'required_documents';
        }
      } else {
        missingDocumentFields.push(`${product.name} (${product.lender_name})`);
      }
    });
    
    return {
      totalProducts,
      productsWithDocuments,
      missingDocumentFields,
      sampleDocumentField
    };
    
  } catch (error) {
    console.error('‚ùå Error validating document fields:', error);
    return {
      totalProducts: 0,
      productsWithDocuments: 0,
      missingDocumentFields: [],
      sampleDocumentField: 'unknown'
    };
  }
}
// injected: local-first products fetch
import { getProducts, loadSelectedCategories } from "../api/products";
/* injected load on mount (pseudo):
useEffect(() => { (async () => {
  const cats = loadSelectedCategories();
  const products = await getProducts({ useCacheFirst: true });
  // apply category filter if present
  const selected = cats && cats.length ? products.filter(p => cats.includes((p.category||"").toLowerCase())) : products;
  setState({ products: selected });
})(); }, []);
*/
