import { getProducts } from "../api/products";
import { getRecommendedProducts } from "../api/products";
/**
 * Schema + Recommendation Engine Health Check
 * Comprehensive diagnostic for category mapping, country codes, amount filtering, and document intersection
 */

(async () => { /* ensure products fetched */ 
  // ------------- helpers -----------------
  const ok   = msg => // console.log(`%câœ” ${msg}`,'color:lime');
  const fail = msg => console.error(`âœ– ${msg}`);
  const info = msg => // console.log(`%cğŸ“Š ${msg}`,'color:cyan');

  info('ğŸ” BOREAL FINANCIAL - SCHEMA HEALTH CHECK');
  info('Testing: Category mapping, Country codes, Amount filtering, Document intersection');
  // console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

  try {
    // Fetch live data from staff API
    const response = await fetch('https://staff.boreal.financial/api/v1/products')
    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }
    
    const data = await response.json();
    const products = data.success ? data.products : [];
    
    if (!products || products.length === 0) {
      throw new Error('No products returned from API');
    }

    info(`Found ${products.length} products from staff API`);

    // Schema canonical categories (from unified schema)
    const schemaCategories = [
      'Working Capital',
      'Term Loan', 
      'Business Line of Credit',
      'Equipment Financing',
      'Invoice Factoring',
      'Purchase Order Financing',
      'Asset-Based Lending',
      'SBA Loan'
    ];

    // ---------- CATEGORY AUDIT ----------
    // console.log('\nğŸ·ï¸  CATEGORY MAPPING AUDIT');
    const badCats = products.filter(p => !schemaCategories.includes(p.category));
    const uniqueCategories = [...new Set(products.map(p => p.category))];
    
    if (badCats.length) {
      fail(`Bad categories found: ${badCats.map(p => `"${p.category}"`).join(', ')}`);
      // console.log('Products with bad categories:', badCats.map(p => `${p.name} (${p.lenderName})`));
    } else {
      ok('All products use canonical categories');
    }
    
    info(`Categories in use: ${uniqueCategories.join(', ')}`);

    // ---------- COUNTRY AUDIT ----------
    // console.log('\nğŸŒ COUNTRY CODE AUDIT');
    const validCountries = ['US', 'CA'];
    const badCountry = products.filter(p => !validCountries.includes(p.country));
    const countryStats = {};
    
    products.forEach(p => {
      countryStats[p.country] = (countryStats[p.country] || 0) + 1;
    });

    if (badCountry.length) {
      fail(`Bad country codes on ${badCountry.length} products`);
      // console.log('Invalid countries:', badCountry.map(p => `${p.name}: "${p.country}"`));
    } else {
      ok('All products use canonical country codes (US/CA)');
    }
    
    info(`Country distribution: ${Object.entries(countryStats).map(([k,v]) => `${k}: ${v}`).join(', ')}`);

    // ---------- AMOUNT FILTER SANITY CHECK ----------
    // console.log('\nğŸ’° AMOUNT RANGE AUDIT');
    
    // Test scenarios
    const testScenarios = [
      { amount: 10000, location: 'canada', category: 'Working Capital' },
      { amount: 40000, location: 'canada', category: 'Working Capital' },
      { amount: 75000, location: 'united-states', category: 'Term Loan' },
      { amount: 150000, location: 'canada', category: 'Equipment Financing' }
    ];

    for (const scenario of testScenarios) {
      const countryCode = scenario.location === 'canada' ? 'CA' : 'US';
      const matches = products.filter(p => {
        const categoryMatch = p.category === scenario.category;
        const countryMatch = p.country === countryCode;
        const amountMatch = (p.amountMin || 0) <= scenario.amount && (p.amountMax || Number.MAX_SAFE_INTEGER) >= scenario.amount;
        return categoryMatch && countryMatch && amountMatch;
      });
      
      if (matches.length > 0) {
        ok(`${scenario.category} ${scenario.location} $${scenario.amount.toLocaleString()}: ${matches.length} matches`);
        matches.forEach(m => // console.log(`   - ${m.name} (${m.lenderName}): $${m.amountMin?.toLocaleString()}-$${m.amountMax?.toLocaleString()}`));
      } else {
        fail(`${scenario.category} ${scenario.location} $${scenario.amount.toLocaleString()}: 0 matches`);
      }
    }

    // ---------- DOCUMENT INTERSECTION CHECK ----------
    // console.log('\nğŸ“‹ DOCUMENT REQUIREMENTS AUDIT');
    
    // Test AccordAccess specific scenario
    const canadianWorkingCapital = products.filter(p => 
      p.category === 'Working Capital' && 
      p.country === 'CA' && 
      (p.amountMin || 0) <= 40000 && 
      (p.amountMax || Number.MAX_SAFE_INTEGER) >= 40000
    );

    if (canadianWorkingCapital.length > 0) {
      ok(`Canadian Working Capital $40K: ${canadianWorkingCapital.length} matches`);
      
      canadianWorkingCapital.forEach(p => {
        // console.log(`   - ${p.name} (${p.lenderName})`);
        // console.log(`     Documents: ${p.requiredDocuments?.join(', ') || 'None specified'}`);
        // console.log(`     Amount range: $${p.amountMin?.toLocaleString()}-$${p.amountMax?.toLocaleString()}`);
      });

      // Document intersection
      const allDocLists = canadianWorkingCapital.map(p => p.requiredDocuments || []);
      if (allDocLists.length > 0) {
        let intersection = allDocLists[0];
        for (let i = 1; i < allDocLists.length; i++) {
          intersection = intersection.filter(doc => allDocLists[i].includes(doc));
        }
        
        if (intersection.length > 0) {
          ok(`Document intersection: ${intersection.join(', ')}`);
        } else {
          fail('No common documents across all matching lenders');
        }
      }
    } else {
      fail('Canadian Working Capital $40K: 0 matches - AccordAccess should be here!');
    }

    // ---------- INDIVIDUAL PRODUCT VALIDATION ----------
    // console.log('\nğŸ¯ INDIVIDUAL PRODUCT VALIDATION');
    
    // Check for missing fields
    const missingFields = products.filter(p => 
      !p.name || !p.lenderName || !p.category || !p.country || 
      typeof p.amountMin !== 'number' || typeof p.amountMax !== 'number'
    );

    if (missingFields.length > 0) {
      fail(`${missingFields.length} products missing required fields`);
      missingFields.forEach(p => {
        // console.log(`   - ${p.name || 'UNNAMED'} (${p.lenderName || 'UNKNOWN LENDER'})`);
        // console.log(`     Missing: ${!p.name ? 'name ' : ''}${!p.category ? 'category ' : ''}${!p.country ? 'country ' : ''}${typeof p.amountMin !== 'number' ? 'amountMin ' : ''}${typeof p.amountMax !== 'number' ? 'amountMax' : ''}`);
      });
    } else {
      ok('All products have required fields (name, lenderName, category, country, amountMin, amountMax)');
    }

    // Check for AccordAccess specifically
    const accordAccess = products.find(p => p.name === 'AccordAccess');
    if (accordAccess) {
      ok('AccordAccess product found');
      // console.log('   AccordAccess details:');
      // console.log(`     Category: "${accordAccess.category}"`);
      // console.log(`     Country: "${accordAccess.country}"`);
      // console.log(`     Amount: $${accordAccess.amountMin?.toLocaleString()}-$${accordAccess.amountMax?.toLocaleString()}`);
      // console.log(`     Documents: ${accordAccess.requiredDocuments?.join(', ')}`);
    } else {
      fail('AccordAccess product NOT FOUND - this is the primary test case!');
    }

    // ---------- SUMMARY ----------
    // console.log('\nğŸ“Š HEALTH CHECK SUMMARY');
    const totalIssues = badCats.length + badCountry.length + missingFields.length + (accordAccess ? 0 : 1);
    
    if (totalIssues === 0) {
      ok('ğŸ‰ ALL CHECKS PASSED - Schema and data are healthy!');
    } else {
      fail(`âŒ ${totalIssues} issues found - see details above`);
    }

    // console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    info('Health check complete. Review any âœ– failures above.');

  } catch (error) {
    fail(`Health check failed: ${error.message}`);
    console.error('Full error:', error);
  }
})();